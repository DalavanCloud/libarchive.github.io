Index: libarchive/archive_write_add_filter_program.c
===================================================================
--- libarchive/archive_write_add_filter_program.c	(revision 2914)
+++ libarchive/archive_write_add_filter_program.c	(working copy)
@@ -159,11 +159,11 @@
 	return (0);
 }
 
-static ssize_t
+static __LA_SSIZE_T
 child_write(struct archive_write_filter *f, const char *buf, size_t buf_len)
 {
 	struct private_data *data = f->data;
-	ssize_t ret;
+	__LA_SSIZE_T ret;
 
 	if (data->child_stdin == -1)
 		return (-1);
@@ -234,7 +234,7 @@
 archive_compressor_program_write(struct archive_write_filter *f,
     const void *buff, size_t length)
 {
-	ssize_t ret;
+	__LA_SSIZE_T ret;
 	const char *buf;
 
 	buf = buff;
@@ -260,7 +260,7 @@
 {
 	struct private_data *data = (struct private_data *)f->data;
 	int ret, r1, status;
-	ssize_t bytes_read;
+	__LA_SSIZE_T bytes_read;
 
 	ret = 0;
 	close(data->child_stdin);
Index: libarchive/archive_entry_strmode.c
===================================================================
--- libarchive/archive_entry_strmode.c	(revision 2914)
+++ libarchive/archive_entry_strmode.c	(working copy)
@@ -39,10 +39,10 @@
 const char *
 archive_entry_strmode(struct archive_entry *entry)
 {
-	static const mode_t permbits[] =
+	static const __LA_MODE_T permbits[] =
 	    { 0400, 0200, 0100, 0040, 0020, 0010, 0004, 0002, 0001 };
 	char *bp = entry->strmode;
-	mode_t mode;
+	__LA_MODE_T mode;
 	int i;
 
 	/* Fill in a default string, then selectively override. */
Index: libarchive/archive_acl_private.h
===================================================================
--- libarchive/archive_acl_private.h	(revision 2914)
+++ libarchive/archive_acl_private.h	(working copy)
@@ -44,7 +44,7 @@
 };
 
 struct archive_acl {
-	mode_t		mode;
+	__LA_MODE_T		mode;
 	struct archive_acl_entry	*acl_head;
 	struct archive_acl_entry	*acl_p;
 	int		 acl_state;	/* See acl_next for details. */
Index: libarchive/archive_write_add_filter_gzip.c
===================================================================
--- libarchive/archive_write_add_filter_gzip.c	(revision 2914)
+++ libarchive/archive_write_add_filter_gzip.c	(working copy)
@@ -68,7 +68,7 @@
 struct private_data {
 	int		 compression_level;
 	z_stream	 stream;
-	int64_t		 total_in;
+	__LA_INT64_T		 total_in;
 	unsigned char	*compressed;
 	size_t		 compressed_buffer_size;
 	unsigned long	 crc;
Index: libarchive/archive_endian.h
===================================================================
--- libarchive/archive_endian.h	(revision 2914)
+++ libarchive/archive_endian.h	(working copy)
@@ -53,7 +53,7 @@
 
 /* Alignment-agnostic encode/decode bytestream to/from little/big endian. */
 
-static inline uint16_t
+static inline __LA_UINT16_T
 archive_be16dec(const void *pp)
 {
 	unsigned char const *p = (unsigned char const *)pp;
@@ -61,7 +61,7 @@
 	return ((p[0] << 8) | p[1]);
 }
 
-static inline uint32_t
+static inline __LA_UINT32_T
 archive_be32dec(const void *pp)
 {
 	unsigned char const *p = (unsigned char const *)pp;
@@ -69,15 +69,15 @@
 	return ((p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3]);
 }
 
-static inline uint64_t
+static inline __LA_UINT64_T
 archive_be64dec(const void *pp)
 {
 	unsigned char const *p = (unsigned char const *)pp;
 
-	return (((uint64_t)archive_be32dec(p) << 32) | archive_be32dec(p + 4));
+	return (((__LA_UINT64_T)archive_be32dec(p) << 32) | archive_be32dec(p + 4));
 }
 
-static inline uint16_t
+static inline __LA_UINT16_T
 archive_le16dec(const void *pp)
 {
 	unsigned char const *p = (unsigned char const *)pp;
@@ -85,7 +85,7 @@
 	return ((p[1] << 8) | p[0]);
 }
 
-static inline uint32_t
+static inline __LA_UINT32_T
 archive_le32dec(const void *pp)
 {
 	unsigned char const *p = (unsigned char const *)pp;
@@ -93,16 +93,16 @@
 	return ((p[3] << 24) | (p[2] << 16) | (p[1] << 8) | p[0]);
 }
 
-static inline uint64_t
+static inline __LA_UINT64_T
 archive_le64dec(const void *pp)
 {
 	unsigned char const *p = (unsigned char const *)pp;
 
-	return (((uint64_t)archive_le32dec(p + 4) << 32) | archive_le32dec(p));
+	return (((__LA_UINT64_T)archive_le32dec(p + 4) << 32) | archive_le32dec(p));
 }
 
 static inline void
-archive_be16enc(void *pp, uint16_t u)
+archive_be16enc(void *pp, __LA_UINT16_T u)
 {
 	unsigned char *p = (unsigned char *)pp;
 
@@ -111,7 +111,7 @@
 }
 
 static inline void
-archive_be32enc(void *pp, uint32_t u)
+archive_be32enc(void *pp, __LA_UINT32_T u)
 {
 	unsigned char *p = (unsigned char *)pp;
 
@@ -122,7 +122,7 @@
 }
 
 static inline void
-archive_be64enc(void *pp, uint64_t u)
+archive_be64enc(void *pp, __LA_UINT64_T u)
 {
 	unsigned char *p = (unsigned char *)pp;
 
@@ -131,7 +131,7 @@
 }
 
 static inline void
-archive_le16enc(void *pp, uint16_t u)
+archive_le16enc(void *pp, __LA_UINT16_T u)
 {
 	unsigned char *p = (unsigned char *)pp;
 
@@ -140,7 +140,7 @@
 }
 
 static inline void
-archive_le32enc(void *pp, uint32_t u)
+archive_le32enc(void *pp, __LA_UINT32_T u)
 {
 	unsigned char *p = (unsigned char *)pp;
 
@@ -151,7 +151,7 @@
 }
 
 static inline void
-archive_le64enc(void *pp, uint64_t u)
+archive_le64enc(void *pp, __LA_UINT64_T u)
 {
 	unsigned char *p = (unsigned char *)pp;
 
Index: libarchive/archive_read_support_compression_rpm.c
===================================================================
--- libarchive/archive_read_support_compression_rpm.c	(revision 2914)
+++ libarchive/archive_read_support_compression_rpm.c	(working copy)
@@ -38,7 +38,7 @@
 #include "archive_read_private.h"
 
 struct rpm {
-	int64_t		 total_in;
+	__LA_INT64_T		 total_in;
 	size_t		 hpos;
 	size_t		 hlen;
 	unsigned char	 header[16];
@@ -59,7 +59,7 @@
 		    struct archive_read_filter *);
 static int	rpm_bidder_init(struct archive_read_filter *);
 
-static ssize_t	rpm_filter_read(struct archive_read_filter *,
+static __LA_SSIZE_T	rpm_filter_read(struct archive_read_filter *,
 		    const void **);
 static int	rpm_filter_close(struct archive_read_filter *);
 
@@ -87,7 +87,7 @@
     struct archive_read_filter *filter)
 {
 	const unsigned char *b;
-	ssize_t avail;
+	__LA_SSIZE_T avail;
 	int bits_checked;
 
 	(void)self; /* UNUSED */
@@ -155,15 +155,15 @@
 	return (ARCHIVE_OK);
 }
 
-static ssize_t
+static __LA_SSIZE_T
 rpm_filter_read(struct archive_read_filter *self, const void **buff)
 {
 	struct rpm *rpm;
 	const unsigned char *b;
-	ssize_t avail_in, total;
+	__LA_SSIZE_T avail_in, total;
 	size_t used, n;
-	uint32_t section;
-	uint32_t bytes;
+	__LA_UINT32_T section;
+	__LA_UINT32_T bytes;
 
 	rpm = (struct rpm *)self->data;
 	*buff = NULL;
Index: libarchive/archive_read_private.h
===================================================================
--- libarchive/archive_read_private.h	(revision 2914)
+++ libarchive/archive_read_private.h	(working copy)
@@ -76,16 +76,16 @@
  * corresponding bidder above.
  */
 struct archive_read_filter {
-	int64_t bytes_consumed;
+	__LA_INT64_T bytes_consumed;
 	/* Essentially all filters will need these values, so
 	 * just declare them here. */
 	struct archive_read_filter_bidder *bidder; /* My bidder. */
 	struct archive_read_filter *upstream; /* Who I read from. */
 	struct archive_read *archive; /* Associated archive. */
 	/* Return next block. */
-	ssize_t (*read)(struct archive_read_filter *, const void **);
+	__LA_SSIZE_T (*read)(struct archive_read_filter *, const void **);
 	/* Skip forward this many bytes. */
-	int64_t (*skip)(struct archive_read_filter *self, int64_t request);
+	__LA_INT64_T (*skip)(struct archive_read_filter *self, __LA_INT64_T request);
 	/* Close (just this filter) and free(self). */
 	int (*close)(struct archive_read_filter *self);
 	/* My private data. */
@@ -127,7 +127,7 @@
 	struct archive_entry	*entry;
 
 	/* Dev/ino of the archive being read/written. */
-	dev_t		  skip_file_dev;
+	__LA_DEV_T		  skip_file_dev;
 	ino_t		  skip_file_ino;
 
 	/*
@@ -135,8 +135,8 @@
 	 * data to client buffers, filling gaps with zero bytes.
 	 */
 	const char	 *read_data_block;
-	int64_t		  read_data_offset;
-	int64_t		  read_data_output_offset;
+	__LA_INT64_T		  read_data_offset;
+	__LA_INT64_T		  read_data_output_offset;
 	size_t		  read_data_remaining;
 
 	/* Callbacks to open/read/write/close client archive stream. */
@@ -149,7 +149,7 @@
 	struct archive_read_filter *filter;
 
 	/* File offset of beginning of most recently-read header. */
-	int64_t		  header_position;
+	__LA_INT64_T		  header_position;
 
 	/*
 	 * Format detection is mostly the same as compression
@@ -166,7 +166,7 @@
 		int	(*options)(struct archive_read *, const char *key,
 		    const char *value);
 		int	(*read_header)(struct archive_read *, struct archive_entry *);
-		int	(*read_data)(struct archive_read *, const void **, size_t *, int64_t *);
+		int	(*read_data)(struct archive_read *, const void **, size_t *, __LA_INT64_T *);
 		int	(*read_data_skip)(struct archive_read *);
 		int	(*cleanup)(struct archive_read *);
 	}	formats[11];
@@ -185,17 +185,17 @@
 	    int (*bid)(struct archive_read *),
 	    int (*options)(struct archive_read *, const char *, const char *),
 	    int (*read_header)(struct archive_read *, struct archive_entry *),
-	    int (*read_data)(struct archive_read *, const void **, size_t *, int64_t *),
+	    int (*read_data)(struct archive_read *, const void **, size_t *, __LA_INT64_T *),
 	    int (*read_data_skip)(struct archive_read *),
 	    int (*cleanup)(struct archive_read *));
 
 struct archive_read_filter_bidder
 	*__archive_read_get_bidder(struct archive_read *a);
 
-const void *__archive_read_ahead(struct archive_read *, size_t, ssize_t *);
+const void *__archive_read_ahead(struct archive_read *, size_t, __LA_SSIZE_T *);
 const void *__archive_read_filter_ahead(struct archive_read_filter *,
-    size_t, ssize_t *);
-int64_t	__archive_read_consume(struct archive_read *, int64_t);
-int64_t	__archive_read_filter_consume(struct archive_read_filter *, int64_t);
+    size_t, __LA_SSIZE_T *);
+__LA_INT64_T	__archive_read_consume(struct archive_read *, __LA_INT64_T);
+__LA_INT64_T	__archive_read_filter_consume(struct archive_read_filter *, __LA_INT64_T);
 int __archive_read_program(struct archive_read_filter *, const char *);
 #endif
Index: libarchive/archive_write_open_file.c
===================================================================
--- libarchive/archive_write_open_file.c	(revision 2914)
+++ libarchive/archive_write_open_file.c	(working copy)
@@ -53,7 +53,7 @@
 
 static int	file_close(struct archive *, void *);
 static int	file_open(struct archive *, void *);
-static ssize_t	file_write(struct archive *, void *, const void *buff, size_t);
+static __LA_SSIZE_T	file_write(struct archive *, void *, const void *buff, size_t);
 
 int
 archive_write_open_FILE(struct archive *a, FILE *f)
@@ -79,7 +79,7 @@
 	return (ARCHIVE_OK);
 }
 
-static ssize_t
+static __LA_SSIZE_T
 file_write(struct archive *a, void *client_data, const void *buff, size_t length)
 {
 	struct write_FILE_data	*mine;
Index: libarchive/archive_write_open_filename.c
===================================================================
--- libarchive/archive_write_open_filename.c	(revision 2914)
+++ libarchive/archive_write_open_filename.c	(working copy)
@@ -58,7 +58,7 @@
 
 static int	file_close(struct archive *, void *);
 static int	file_open(struct archive *, void *);
-static ssize_t	file_write(struct archive *, void *, const void *buff, size_t);
+static __LA_SSIZE_T	file_write(struct archive *, void *, const void *buff, size_t);
 
 int
 archive_write_open_file(struct archive *a, const char *filename)
@@ -135,11 +135,11 @@
 	return (ARCHIVE_OK);
 }
 
-static ssize_t
+static __LA_SSIZE_T
 file_write(struct archive *a, void *client_data, const void *buff, size_t length)
 {
 	struct write_file_data	*mine;
-	ssize_t	bytesWritten;
+	__LA_SSIZE_T	bytesWritten;
 
 	mine = (struct write_file_data *)client_data;
 	for (;;) {
Index: libarchive/archive_check_magic.c
===================================================================
--- libarchive/archive_check_magic.c	(revision 2914)
+++ libarchive/archive_check_magic.c	(working copy)
@@ -51,7 +51,7 @@
 errmsg(const char *m)
 {
 	size_t s = strlen(m);
-	ssize_t written;
+	__LA_SSIZE_T written;
 
 	while (s > 0) {
 		written = write(2, m, strlen(m));
Index: libarchive/archive_entry_sparse.c
===================================================================
--- libarchive/archive_entry_sparse.c	(revision 2914)
+++ libarchive/archive_entry_sparse.c	(working copy)
@@ -51,7 +51,7 @@
 
 void
 archive_entry_sparse_add_entry(struct archive_entry *entry,
-	int64_t offset, int64_t length)
+	__LA_INT64_T offset, __LA_INT64_T length)
 {
 	struct ae_sparse *sp;
 
@@ -121,7 +121,7 @@
 
 int
 archive_entry_sparse_next(struct archive_entry * entry,
-	int64_t *offset, int64_t *length)
+	__LA_INT64_T *offset, __LA_INT64_T *length)
 {
 	if (entry->sparse_p) {
 		*offset = entry->sparse_p->offset;
Index: libarchive/archive_read_support_compression_gzip.c
===================================================================
--- libarchive/archive_read_support_compression_gzip.c	(revision 2914)
+++ libarchive/archive_read_support_compression_gzip.c	(working copy)
@@ -54,13 +54,13 @@
 	char		 in_stream;
 	unsigned char	*out_block;
 	size_t		 out_block_size;
-	int64_t		 total_out;
+	__LA_INT64_T		 total_out;
 	unsigned long	 crc;
 	char		 eof; /* True = found end of compressed data. */
 };
 
 /* Gzip Filter. */
-static ssize_t	gzip_filter_read(struct archive_read_filter *, const void **);
+static __LA_SSIZE_T	gzip_filter_read(struct archive_read_filter *, const void **);
 static int	gzip_filter_close(struct archive_read_filter *);
 #endif
 
@@ -113,7 +113,7 @@
 peek_at_header(struct archive_read_filter *filter, int *pbits)
 {
 	const unsigned char *p;
-	ssize_t avail, len;
+	__LA_SSIZE_T avail, len;
 	int bits = 0;
 	int header_flags;
 
@@ -274,7 +274,7 @@
 consume_header(struct archive_read_filter *self)
 {
 	struct private_data *state;
-	ssize_t avail;
+	__LA_SSIZE_T avail;
 	size_t len;
 	int ret;
 
@@ -333,7 +333,7 @@
 {
 	struct private_data *state;
 	const unsigned char *p;
-	ssize_t avail;
+	__LA_SSIZE_T avail;
 
 	state = (struct private_data *)self->data;
 
@@ -361,12 +361,12 @@
 	return (ARCHIVE_OK);
 }
 
-static ssize_t
+static __LA_SSIZE_T
 gzip_filter_read(struct archive_read_filter *self, const void **p)
 {
 	struct private_data *state;
 	size_t decompressed;
-	ssize_t avail_in;
+	__LA_SSIZE_T avail_in;
 	int ret;
 
 	state = (struct private_data *)self->data;
Index: libarchive/archive_write_disk.3
===================================================================
--- libarchive/archive_write_disk.3	(revision 2914)
+++ libarchive/archive_write_disk.3	(working copy)
@@ -47,12 +47,12 @@
 .Ft int
 .Fn archive_write_disk_set_options "struct archive *" "int flags"
 .Ft int
-.Fn archive_write_disk_set_skip_file "struct archive *" "dev_t" "ino_t"
+.Fn archive_write_disk_set_skip_file "struct archive *" "__LA_DEV_T" "ino_t"
 .Ft int
 .Fo archive_write_disk_set_group_lookup
 .Fa "struct archive *"
 .Fa "void *"
-.Fa "gid_t (*)(void *, const char *gname, gid_t gid)"
+.Fa "__LA_GID_T (*)(void *, const char *gname, __LA_GID_T gid)"
 .Fa "void (*cleanup)(void *)"
 .Fc
 .Ft int
@@ -61,12 +61,12 @@
 .Fo archive_write_disk_set_user_lookup
 .Fa "struct archive *"
 .Fa "void *"
-.Fa "uid_t (*)(void *, const char *uname, uid_t uid)"
+.Fa "__LA_UID_T (*)(void *, const char *uname, __LA_UID_T uid)"
 .Fa "void (*cleanup)(void *)"
 .Fc
 .Ft int
 .Fn archive_write_header "struct archive *" "struct archive_entry *"
-.Ft ssize_t
+.Ft __LA_SSIZE_T
 .Fn archive_write_data "struct archive *" "const void *" "size_t"
 .Ft int
 .Fn archive_write_finish_entry "struct archive *"
Index: libarchive/archive_read_support_format_tar.c
===================================================================
--- libarchive/archive_read_support_format_tar.c	(revision 2914)
+++ libarchive/archive_read_support_format_tar.c	(working copy)
@@ -139,8 +139,8 @@
  */
 struct sparse_block {
 	struct sparse_block	*next;
-	int64_t	offset;
-	int64_t	remaining;
+	__LA_INT64_T	offset;
+	__LA_INT64_T	remaining;
 };
 
 struct tar {
@@ -160,32 +160,32 @@
 	wchar_t 		*pax_entry;
 	size_t			 pax_entry_length;
 	int			 header_recursion_depth;
-	int64_t			 entry_bytes_remaining;
-	int64_t			 entry_offset;
-	int64_t			 entry_padding;
-	int64_t 		 entry_bytes_unconsumed;
-	int64_t			 realsize;
+	__LA_INT64_T			 entry_bytes_remaining;
+	__LA_INT64_T			 entry_offset;
+	__LA_INT64_T			 entry_padding;
+	__LA_INT64_T 		 entry_bytes_unconsumed;
+	__LA_INT64_T			 realsize;
 	struct sparse_block	*sparse_list;
 	struct sparse_block	*sparse_last;
-	int64_t			 sparse_offset;
-	int64_t			 sparse_numbytes;
+	__LA_INT64_T			 sparse_offset;
+	__LA_INT64_T			 sparse_numbytes;
 	int			 sparse_gnu_major;
 	int			 sparse_gnu_minor;
 	char			 sparse_gnu_pending;
 };
 
-static ssize_t	UTF8_mbrtowc(wchar_t *pwc, const char *s, size_t n);
+static __LA_SSIZE_T	UTF8_mbrtowc(wchar_t *pwc, const char *s, size_t n);
 static int	archive_block_is_null(const unsigned char *p);
 static char	*base64_decode(const char *, size_t, size_t *);
 static void	 gnu_add_sparse_entry(struct tar *,
-		    int64_t offset, int64_t remaining);
+		    __LA_INT64_T offset, __LA_INT64_T remaining);
 static void	gnu_clear_sparse_list(struct tar *);
 static int	gnu_sparse_old_read(struct archive_read *, struct tar *,
 		    const struct archive_entry_header_gnutar *header, size_t *);
 static void	gnu_sparse_old_parse(struct tar *,
 		    const struct gnu_sparse *sparse, int length);
 static int	gnu_sparse_01_parse(struct tar *, const char *);
-static ssize_t	gnu_sparse_10_read(struct archive_read *, struct tar *,
+static __LA_SSIZE_T	gnu_sparse_10_read(struct archive_read *, struct tar *,
 			size_t *);
 static int	header_Solaris_ACL(struct archive_read *,  struct tar *,
 		    struct archive_entry *, const void *, size_t *);
@@ -212,7 +212,7 @@
 static int	archive_read_format_tar_bid(struct archive_read *);
 static int	archive_read_format_tar_cleanup(struct archive_read *);
 static int	archive_read_format_tar_read_data(struct archive_read *a,
-		    const void **buff, size_t *size, int64_t *offset);
+		    const void **buff, size_t *size, __LA_INT64_T *offset);
 static int	archive_read_format_tar_skip(struct archive_read *a);
 static int	archive_read_format_tar_read_header(struct archive_read *,
 		    struct archive_entry *);
@@ -221,15 +221,15 @@
 		    char *key, char *value);
 static int 	pax_header(struct archive_read *, struct tar *,
 		    struct archive_entry *, char *attr);
-static void	pax_time(const char *, int64_t *sec, long *nanos);
-static ssize_t	readline(struct archive_read *, struct tar *, const char **,
-		    ssize_t limit, size_t *);
+static void	pax_time(const char *, __LA_INT64_T *sec, long *nanos);
+static __LA_SSIZE_T	readline(struct archive_read *, struct tar *, const char **,
+		    __LA_SSIZE_T limit, size_t *);
 static int	read_body_to_string(struct archive_read *, struct tar *,
 		    struct archive_string *, const void *h, size_t *);
-static int64_t	tar_atol(const char *, unsigned);
-static int64_t	tar_atol10(const char *, unsigned);
-static int64_t	tar_atol256(const char *, unsigned);
-static int64_t	tar_atol8(const char *, unsigned);
+static __LA_INT64_T	tar_atol(const char *, unsigned);
+static __LA_INT64_T	tar_atol10(const char *, unsigned);
+static __LA_INT64_T	tar_atol256(const char *, unsigned);
+static __LA_INT64_T	tar_atol8(const char *, unsigned);
 static int	tar_read_header(struct archive_read *, struct tar *,
 		    struct archive_entry *, size_t *);
 static int	tohex(int c);
@@ -481,9 +481,9 @@
 
 static int
 archive_read_format_tar_read_data(struct archive_read *a,
-    const void **buff, size_t *size, int64_t *offset)
+    const void **buff, size_t *size, __LA_INT64_T *offset)
 {
-	ssize_t bytes_read;
+	__LA_SSIZE_T bytes_read;
 	struct tar *tar;
 	struct sparse_block *p;
 
@@ -539,7 +539,7 @@
 static int
 archive_read_format_tar_skip(struct archive_read *a)
 {
-	int64_t bytes_skipped;
+	__LA_INT64_T bytes_skipped;
 	struct tar* tar;
 
 	tar = (struct tar *)(a->format->data);
@@ -568,7 +568,7 @@
 tar_read_header(struct archive_read *a, struct tar *tar,
     struct archive_entry *entry, size_t *unconsumed)
 {
-	ssize_t bytes;
+	__LA_SSIZE_T bytes;
 	int err;
 	const void *h;
 	const struct archive_entry_header_ustar *header;
@@ -708,7 +708,7 @@
 		if (tar->sparse_gnu_pending) {
 			if (tar->sparse_gnu_major == 1 &&
 			    tar->sparse_gnu_minor == 0) {
-				ssize_t bytes_read;
+				__LA_SSIZE_T bytes_read;
 
 				tar->sparse_gnu_pending = 0;
 				/* Read initial sparse map. */
@@ -803,7 +803,7 @@
 	const struct archive_entry_header_ustar *header;
 	size_t size;
 	int err;
-	int64_t type;
+	__LA_INT64_T type;
 	char *acl, *p;
 	wchar_t *wp;
 
@@ -944,7 +944,7 @@
 read_body_to_string(struct archive_read *a, struct tar *tar,
     struct archive_string *as, const void *h, size_t *unconsumed)
 {
-	int64_t size;
+	__LA_INT64_T size;
 	const struct archive_entry_header_ustar *header;
 	const void *src;
 
@@ -1178,7 +1178,7 @@
 read_mac_metadata_blob(struct archive_read *a, struct tar *tar,
     struct archive_entry *entry, const void *h, size_t *unconsumed)
 {
-	int64_t size;
+	__LA_INT64_T size;
 	const void *data;
 	const char *p, *name;
 
@@ -1533,7 +1533,7 @@
 pax_attribute(struct tar *tar, struct archive_entry *entry,
     char *key, char *value)
 {
-	int64_t s;
+	__LA_INT64_T s;
 	long n;
 	wchar_t *wp;
 
@@ -1744,13 +1744,13 @@
  * parse a decimal time value, which may include a fractional portion
  */
 static void
-pax_time(const char *p, int64_t *ps, long *pn)
+pax_time(const char *p, __LA_INT64_T *ps, long *pn)
 {
 	char digit;
-	int64_t	s;
+	__LA_INT64_T	s;
 	unsigned long l;
 	int sign;
-	int64_t limit, last_digit_limit;
+	__LA_INT64_T limit, last_digit_limit;
 
 	limit = INT64_MAX / 10;
 	last_digit_limit = INT64_MAX % 10;
@@ -1798,7 +1798,7 @@
     struct archive_entry *entry, const void *h, size_t *unconsumed)
 {
 	const struct archive_entry_header_gnutar *header;
-	int64_t t;
+	__LA_INT64_T t;
 	int err = ARCHIVE_OK;
 
 	(void)a;
@@ -1867,7 +1867,7 @@
 }
 
 static void
-gnu_add_sparse_entry(struct tar *tar, int64_t offset, int64_t remaining)
+gnu_add_sparse_entry(struct tar *tar, __LA_INT64_T offset, __LA_INT64_T remaining)
 {
 	struct sparse_block *p;
 
@@ -1913,7 +1913,7 @@
 gnu_sparse_old_read(struct archive_read *a, struct tar *tar,
     const struct archive_entry_header_gnutar *header, size_t *unconsumed)
 {
-	ssize_t bytes_read;
+	__LA_SSIZE_T bytes_read;
 	const void *data;
 	struct extended {
 		struct gnu_sparse sparse[21];
@@ -1989,7 +1989,7 @@
 gnu_sparse_01_parse(struct tar *tar, const char *p)
 {
 	const char *e;
-	int64_t offset = -1, size = -1;
+	__LA_INT64_T offset = -1, size = -1;
 
 	for (;;) {
 		e = p;
@@ -2038,13 +2038,13 @@
  * integer followed by '\n'.  Returns positive integer value or
  * negative on error.
  */
-static int64_t
+static __LA_INT64_T
 gnu_sparse_10_atol(struct archive_read *a, struct tar *tar,
-    int64_t *remaining, size_t *unconsumed)
+    __LA_INT64_T *remaining, size_t *unconsumed)
 {
-	int64_t l, limit, last_digit_limit;
+	__LA_INT64_T l, limit, last_digit_limit;
 	const char *p;
-	ssize_t bytes_read;
+	__LA_SSIZE_T bytes_read;
 	int base, digit;
 
 	base = 10;
@@ -2084,12 +2084,12 @@
  * Returns length (in bytes) of the sparse data description
  * that was read.
  */
-static ssize_t
+static __LA_SSIZE_T
 gnu_sparse_10_read(struct archive_read *a, struct tar *tar, size_t *unconsumed)
 {
-	ssize_t bytes_read;
+	__LA_SSIZE_T bytes_read;
 	int entries;
-	int64_t offset, size, to_skip, remaining;
+	__LA_INT64_T offset, size, to_skip, remaining;
 
 	/* Clear out the existing sparse list. */
 	gnu_clear_sparse_list(tar);
@@ -2138,7 +2138,7 @@
  *
  * On read, this implementation supports both extensions.
  */
-static int64_t
+static __LA_INT64_T
 tar_atol(const char *p, unsigned char_cnt)
 {
 	/*
@@ -2155,10 +2155,10 @@
  * locale settings; you cannot simply substitute strtol here, since
  * it does obey locale.
  */
-static int64_t
+static __LA_INT64_T
 tar_atol8(const char *p, unsigned char_cnt)
 {
-	int64_t	l, limit, last_digit_limit;
+	__LA_INT64_T	l, limit, last_digit_limit;
 	int digit, sign, base;
 
 	base = 8;
@@ -2191,10 +2191,10 @@
  * locale settings; you cannot simply substitute strtol here, since
  * it does obey locale.
  */
-static int64_t
+static __LA_INT64_T
 tar_atol10(const char *p, unsigned char_cnt)
 {
-	int64_t l, limit, last_digit_limit;
+	__LA_INT64_T l, limit, last_digit_limit;
 	int base, digit, sign;
 
 	base = 10;
@@ -2227,10 +2227,10 @@
  * value in big-endian order, except that the high-order bit is
  * ignored.
  */
-static int64_t
+static __LA_INT64_T
 tar_atol256(const char *_p, unsigned char_cnt)
 {
-	int64_t	l, upper_limit, lower_limit;
+	__LA_INT64_T	l, upper_limit, lower_limit;
 	const unsigned char *p = (const unsigned char *)_p;
 
 	upper_limit = INT64_MAX / 256;
@@ -2238,7 +2238,7 @@
 
 	/* Pad with 1 or 0 bits, depending on sign. */
 	if ((0x40 & *p) == 0x40)
-		l = (int64_t)-1;
+		l = (__LA_INT64_T)-1;
 	else
 		l = 0;
 	l = (l << 6) | (0x3f & *p++);
@@ -2250,7 +2250,7 @@
 			l = INT64_MIN;
 			break;
 		}
-		l = (l << 8) | (0xff & (int64_t)*p++);
+		l = (l << 8) | (0xff & (__LA_INT64_T)*p++);
 	}
 	return (l);
 }
@@ -2261,12 +2261,12 @@
  * point to first character of line.  This avoids copying
  * when possible.
  */
-static ssize_t
+static __LA_SSIZE_T
 readline(struct archive_read *a, struct tar *tar, const char **start,
-    ssize_t limit, size_t *unconsumed)
+    __LA_SSIZE_T limit, size_t *unconsumed)
 {
-	ssize_t bytes_read;
-	ssize_t total_size = 0;
+	__LA_SSIZE_T bytes_read;
+	__LA_SSIZE_T total_size = 0;
 	const void *t;
 	const char *s;
 	void *p;
@@ -2331,7 +2331,7 @@
 utf8_decode(struct tar *tar, const char *src, size_t length)
 {
 	wchar_t *dest;
-	ssize_t n;
+	__LA_SSIZE_T n;
 
 	/* Ensure pax_entry buffer is big enough. */
 	if (tar->pax_entry_length <= length) {
@@ -2370,7 +2370,7 @@
 /*
  * Copied and simplified from FreeBSD libc/locale.
  */
-static ssize_t
+static __LA_SSIZE_T
 UTF8_mbrtowc(wchar_t *pwc, const char *s, size_t n)
 {
         int ch, i, len, mask;
Index: libarchive/archive_write_set_format_pax.c
===================================================================
--- libarchive/archive_write_set_format_pax.c	(revision 2914)
+++ libarchive/archive_write_set_format_pax.c	(working copy)
@@ -45,13 +45,13 @@
 struct sparse_block {
 	struct sparse_block	*next;
 	int		is_hole;
-	uint64_t	offset;
-	uint64_t	remaining;
+	__LA_UINT64_T	offset;
+	__LA_UINT64_T	remaining;
 };
 
 struct pax {
-	uint64_t	entry_bytes_remaining;
-	uint64_t	entry_padding;
+	__LA_UINT64_T	entry_bytes_remaining;
+	__LA_UINT64_T	entry_padding;
 	struct archive_string	pax_header;
 	struct archive_string	sparse_map;
 	size_t			sparse_map_padding;
@@ -62,13 +62,13 @@
 static void		 add_pax_attr(struct archive_string *, const char *key,
 			     const char *value);
 static void		 add_pax_attr_int(struct archive_string *,
-			     const char *key, int64_t value);
+			     const char *key, __LA_INT64_T value);
 static void		 add_pax_attr_time(struct archive_string *,
-			     const char *key, int64_t sec,
+			     const char *key, __LA_INT64_T sec,
 			     unsigned long nanos);
 static void		 add_pax_attr_w(struct archive_string *,
 			     const char *key, const wchar_t *wvalue);
-static ssize_t		 archive_write_pax_data(struct archive_write *,
+static __LA_SSIZE_T		 archive_write_pax_data(struct archive_write *,
 			     const void *, size_t);
 static int		 archive_write_pax_close(struct archive_write *);
 static int		 archive_write_pax_free(struct archive_write *);
@@ -80,10 +80,10 @@
 static char		*build_pax_attribute_name(char *dest, const char *src);
 static char		*build_ustar_entry_name(char *dest, const char *src,
 			     size_t src_length, const char *insert);
-static char		*format_int(char *dest, int64_t);
+static char		*format_int(char *dest, __LA_INT64_T);
 static int		 has_non_ASCII(const wchar_t *);
 static void		 sparse_list_clear(struct pax *);
-static int		 sparse_list_add(struct pax *, int64_t, int64_t);
+static int		 sparse_list_add(struct pax *, __LA_INT64_T, __LA_INT64_T);
 static char		*url_encode(const char *in);
 
 /*
@@ -150,7 +150,7 @@
  */
 static void
 add_pax_attr_time(struct archive_string *as, const char *key,
-    int64_t sec, unsigned long nanos)
+    __LA_INT64_T sec, unsigned long nanos)
 {
 	int digit, i;
 	char *t;
@@ -185,7 +185,7 @@
 }
 
 static char *
-format_int(char *t, int64_t i)
+format_int(char *t, __LA_INT64_T i)
 {
 	int sign;
 
@@ -204,7 +204,7 @@
 }
 
 static void
-add_pax_attr_int(struct archive_string *as, const char *key, int64_t value)
+add_pax_attr_int(struct archive_string *as, const char *key, __LA_INT64_T value)
 {
 	char tmp[1 + 3 * sizeof(value)];
 
@@ -427,7 +427,7 @@
 	const char *suffix;
 	int need_extension, r, ret;
 	int sparse_count;
-	uint64_t sparse_total, real_size;
+	__LA_UINT64_T sparse_total, real_size;
 	struct pax *pax;
 	const char *hdrcharset = NULL;
 	const char *hardlink;
@@ -587,7 +587,7 @@
 	else
 		sparse_count = 0;
 	if (sparse_count) {
-		int64_t offset, length, last_offset = 0;
+		__LA_INT64_T offset, length, last_offset = 0;
 		/* Get the last entry of sparse block. */
 		while (archive_entry_sparse_next(
 		    entry_main, &offset, &length) == ARCHIVE_OK)
@@ -754,7 +754,7 @@
 	archive_strcpy(&entry_name, archive_entry_pathname(entry_main));
 
 	/* If file size is too large, add 'size' to pax extended attrs. */
-	if (archive_entry_size(entry_main) >= (((int64_t)1) << 33)) {
+	if (archive_entry_size(entry_main) >= (((__LA_INT64_T)1) << 33)) {
 		add_pax_attr_int(&(pax->pax_header), "size",
 		    archive_entry_size(entry_main));
 		need_extension = 1;
@@ -826,7 +826,7 @@
 		 * If rdevmajor is too large, add 'SCHILY.devmajor' to
 		 * extended attributes.
 		 */
-		dev_t rdevmajor, rdevminor;
+		__LA_DEV_T rdevmajor, rdevminor;
 		rdevmajor = archive_entry_rdevmajor(entry_main);
 		rdevminor = archive_entry_rdevminor(entry_main);
 		if (rdevmajor >= (1 << 18)) {
@@ -955,7 +955,7 @@
 
 		/* We use GNU-tar-compatible sparse attributes. */
 		if (sparse_count > 0) {
-			int64_t soffset, slength;
+			__LA_INT64_T soffset, slength;
 
 			add_pax_attr_int(&(pax->pax_header),
 			    "GNU.sparse.major", 1);
@@ -1037,7 +1037,7 @@
 	 */
 	if (archive_strlen(&(pax->sparse_map))) {
 		size_t mapsize = archive_strlen(&(pax->sparse_map));
-		pax->sparse_map_padding = 0x1ff & (-(ssize_t)mapsize);
+		pax->sparse_map_padding = 0x1ff & (-(__LA_SSIZE_T)mapsize);
 		archive_entry_set_size(entry_main,
 		    mapsize + pax->sparse_map_padding + sparse_total);
 	}
@@ -1074,9 +1074,9 @@
 	if (archive_strlen(&(pax->pax_header)) > 0) {
 		struct archive_entry *pax_attr_entry;
 		time_t s;
-		uid_t uid;
-		gid_t gid;
-		mode_t mode;
+		__LA_UID_T uid;
+		__LA_GID_T gid;
+		__LA_MODE_T mode;
 
 		pax_attr_entry = archive_entry_new();
 		p = entry_name.s;
@@ -1087,11 +1087,11 @@
 		/* Copy uid/gid (but clip to ustar limits). */
 		uid = archive_entry_uid(entry_main);
 		if ((unsigned int)uid >= 1 << 18)
-			uid = (uid_t)(1 << 18) - 1;
+			uid = (__LA_UID_T)(1 << 18) - 1;
 		archive_entry_set_uid(pax_attr_entry, uid);
 		gid = archive_entry_gid(entry_main);
 		if ((unsigned int)gid >= 1 << 18)
-			gid = (gid_t)(1 << 18) - 1;
+			gid = (__LA_GID_T)(1 << 18) - 1;
 		archive_entry_set_gid(pax_attr_entry, gid);
 		/* Copy mode over (but not setuid/setgid bits) */
 		mode = archive_entry_mode(entry_main);
@@ -1146,7 +1146,7 @@
 		}
 
 		pax->entry_bytes_remaining = archive_strlen(&(pax->pax_header));
-		pax->entry_padding = 0x1ff & (-(int64_t)pax->entry_bytes_remaining);
+		pax->entry_padding = 0x1ff & (-(__LA_INT64_T)pax->entry_bytes_remaining);
 
 		r = __archive_write_output(a, pax->pax_header.s,
 		    archive_strlen(&(pax->pax_header)));
@@ -1180,7 +1180,7 @@
 		sparse_list_add(pax, 0, real_size);
 		sparse_total = real_size;
 	}
-	pax->entry_padding = 0x1ff & (-(int64_t)sparse_total);
+	pax->entry_padding = 0x1ff & (-(__LA_INT64_T)sparse_total);
 	archive_entry_free(entry_main);
 	archive_string_free(&entry_name);
 
@@ -1479,7 +1479,7 @@
 archive_write_pax_finish_entry(struct archive_write *a)
 {
 	struct pax *pax;
-	uint64_t remaining;
+	__LA_UINT64_T remaining;
 	int ret;
 
 	pax = (struct pax *)a->format_data;
@@ -1498,7 +1498,7 @@
 	return (ret);
 }
 
-static ssize_t
+static __LA_SSIZE_T
 archive_write_pax_data(struct archive_write *a, const void *buff, size_t s)
 {
 	struct pax *pax;
@@ -1676,7 +1676,7 @@
 }
 
 static int
-_sparse_list_add_block(struct pax *pax, int64_t offset, int64_t length,
+_sparse_list_add_block(struct pax *pax, __LA_INT64_T offset, __LA_INT64_T length,
     int is_hole)
 {
 	struct sparse_block *sb;
@@ -1698,9 +1698,9 @@
 }
 
 static int
-sparse_list_add(struct pax *pax, int64_t offset, int64_t length)
+sparse_list_add(struct pax *pax, __LA_INT64_T offset, __LA_INT64_T length)
 {
-	int64_t last_offset;
+	__LA_INT64_T last_offset;
 	int r;
 
 	if (pax->sparse_tail == NULL)
Index: libarchive/archive_write_set_format_xar.c
===================================================================
--- libarchive/archive_write_set_format_xar.c	(revision 2914)
+++ libarchive/archive_write_set_format_xar.c	(working copy)
@@ -148,11 +148,11 @@
 struct la_zstream {
 	const unsigned char	*next_in;
 	size_t			 avail_in;
-	uint64_t		 total_in;
+	__LA_UINT64_T		 total_in;
 
 	unsigned char		*next_out;
 	size_t			 avail_out;
-	uint64_t		 total_out;
+	__LA_UINT64_T		 total_out;
 
 	int			 valid;
 	void			*real_stream;
@@ -172,9 +172,9 @@
 struct heap_data {
 	int			 id;
 	struct heap_data	*next;
-	uint64_t		 temp_offset;
-	uint64_t		 length;	/* archived size.	*/
-	uint64_t		 size;		/* extracted size.	*/
+	__LA_UINT64_T		 temp_offset;
+	__LA_UINT64_T		 length;	/* archived size.	*/
+	__LA_UINT64_T		 size;		/* extracted size.	*/
 	enum enctype		 compression;
 	struct chksumval	 a_sum;		/* archived checksum.	*/
 	struct chksumval	 e_sum;		/* extracted checksum.	*/
@@ -231,14 +231,14 @@
 
 struct xar {
 	int			 temp_fd;
-	uint64_t		 temp_offset;
+	__LA_UINT64_T		 temp_offset;
 
 	int			 file_idx;
 	struct file		*root;
 	struct file		*cur_dirent;
 	struct archive_string	 cur_dirstr;
 	struct file		*cur_file;
-	uint64_t		 bytes_remaining;
+	__LA_UINT64_T		 bytes_remaining;
 	struct archive_string	 tstr;
 	struct archive_string	 vstr;
 
@@ -277,7 +277,7 @@
 		    const char *, const char *);
 static int	xar_write_header(struct archive_write *,
 		    struct archive_entry *);
-static ssize_t	xar_write_data(struct archive_write *,
+static __LA_SSIZE_T	xar_write_data(struct archive_write *,
 		    const void *, size_t);
 static int	xar_finish_entry(struct archive_write *);
 static int	xar_close(struct archive_write *);
@@ -609,7 +609,7 @@
 {
 	struct xar *xar;
 	unsigned char *p;
-	ssize_t ws;
+	__LA_SSIZE_T ws;
 
 	xar = (struct xar *)a->format_data;
 	p = (unsigned char *)buff;
@@ -627,7 +627,7 @@
 	return (ARCHIVE_OK);
 }
 
-static ssize_t
+static __LA_SSIZE_T
 xar_write_data(struct archive_write *a, const void *buff, size_t s)
 {
 	struct xar *xar;
@@ -709,7 +709,7 @@
 	struct xar *xar;
 	struct file *file;
 	size_t s;
-	ssize_t w;
+	__LA_SSIZE_T w;
 
 	xar = (struct xar *)a->format_data;
 	if (xar->cur_file == NULL)
@@ -850,7 +850,7 @@
 
 static int
 xmlwrite_mode(struct archive_write *a, xmlTextWriterPtr writer,
-	const char *key, mode_t mode)
+	const char *key, __LA_MODE_T mode)
 {
 	char ms[5];
 
@@ -1707,7 +1707,7 @@
 }
 
 static int
-copy_out(struct archive_write *a, uint64_t offset, uint64_t length)
+copy_out(struct archive_write *a, __LA_UINT64_T offset, __LA_UINT64_T length)
 {
 	struct xar *xar;
 	int r;
@@ -1719,7 +1719,7 @@
 	}
 	while (length) {
 		size_t rsize;
-		ssize_t rs;
+		__LA_SSIZE_T rs;
 		unsigned char *wb;
 
 		if (length > xar->wbuff_remaining)
@@ -1755,7 +1755,7 @@
 {
 	struct xar *xar;
 	unsigned char *wb;
-	uint64_t length;
+	__LA_UINT64_T length;
 	int r;
 
 	xar = (struct xar *)a->format_data;
@@ -2647,12 +2647,12 @@
 	 * a non-const pointer. */
 	strm->next_in = (char *)(uintptr_t)(const void *)lastrm->next_in;
 	strm->avail_in = lastrm->avail_in;
-	strm->total_in_lo32 = (uint32_t)(lastrm->total_in & 0xffffffff);
-	strm->total_in_hi32 = (uint32_t)(lastrm->total_in >> 32);
+	strm->total_in_lo32 = (__LA_UINT32_T)(lastrm->total_in & 0xffffffff);
+	strm->total_in_hi32 = (__LA_UINT32_T)(lastrm->total_in >> 32);
 	strm->next_out = (char *)lastrm->next_out;
 	strm->avail_out = lastrm->avail_out;
-	strm->total_out_lo32 = (uint32_t)(lastrm->total_out & 0xffffffff);
-	strm->total_out_hi32 = (uint32_t)(lastrm->total_out >> 32);
+	strm->total_out_lo32 = (__LA_UINT32_T)(lastrm->total_out & 0xffffffff);
+	strm->total_out_hi32 = (__LA_UINT32_T)(lastrm->total_out >> 32);
 	if (BZ2_bzCompressInit(strm, level, 0, 30) != BZ_OK) {
 		free(strm);
 		lastrm->real_stream = NULL;
@@ -2680,24 +2680,24 @@
 	 * a non-const pointer. */
 	strm->next_in = (char *)(uintptr_t)(const void *)lastrm->next_in;
 	strm->avail_in = lastrm->avail_in;
-	strm->total_in_lo32 = (uint32_t)(lastrm->total_in & 0xffffffff);
-	strm->total_in_hi32 = (uint32_t)(lastrm->total_in >> 32);
+	strm->total_in_lo32 = (__LA_UINT32_T)(lastrm->total_in & 0xffffffff);
+	strm->total_in_hi32 = (__LA_UINT32_T)(lastrm->total_in >> 32);
 	strm->next_out = (char *)lastrm->next_out;
 	strm->avail_out = lastrm->avail_out;
-	strm->total_out_lo32 = (uint32_t)(lastrm->total_out & 0xffffffff);
-	strm->total_out_hi32 = (uint32_t)(lastrm->total_out >> 32);
+	strm->total_out_lo32 = (__LA_UINT32_T)(lastrm->total_out & 0xffffffff);
+	strm->total_out_hi32 = (__LA_UINT32_T)(lastrm->total_out >> 32);
 	r = BZ2_bzCompress(strm,
 	    (action == ARCHIVE_Z_FINISH)? BZ_FINISH: BZ_RUN);
 	lastrm->next_in = (const unsigned char *)strm->next_in;
 	lastrm->avail_in = strm->avail_in;
 	lastrm->total_in =
-	    (((uint64_t)(uint32_t)strm->total_in_hi32) << 32)
-	    + (uint64_t)(uint32_t)strm->total_in_lo32;
+	    (((__LA_UINT64_T)(__LA_UINT32_T)strm->total_in_hi32) << 32)
+	    + (__LA_UINT64_T)(__LA_UINT32_T)strm->total_in_lo32;
 	lastrm->next_out = (unsigned char *)strm->next_out;
 	lastrm->avail_out = strm->avail_out;
 	lastrm->total_out =
-	    (((uint64_t)(uint32_t)strm->total_out_hi32) << 32)
-	    + (uint64_t)(uint32_t)strm->total_out_lo32;
+	    (((__LA_UINT64_T)(__LA_UINT32_T)strm->total_out_hi32) << 32)
+	    + (__LA_UINT64_T)(__LA_UINT32_T)strm->total_out_lo32;
 	switch (r) {
 	case BZ_RUN_OK:     /* Non-finishing */
 	case BZ_FINISH_OK:  /* Finishing: There's more work to do */
Index: libarchive/archive_write_disk_set_standard_lookup.c
===================================================================
--- libarchive/archive_write_disk_set_standard_lookup.c	(revision 2914)
+++ libarchive/archive_write_disk_set_standard_lookup.c	(working copy)
@@ -59,11 +59,11 @@
 static const size_t cache_size = 127;
 static unsigned int	hash(const char *);
 #if ARCHIVE_VERSION_NUMBER < 3000000
-static gid_t	lookup_gid(void *, const char *uname, gid_t);
-static uid_t	lookup_uid(void *, const char *uname, uid_t);
+static __LA_GID_T	lookup_gid(void *, const char *uname, __LA_GID_T);
+static __LA_UID_T	lookup_uid(void *, const char *uname, __LA_UID_T);
 #else
-static int64_t	lookup_gid(void *, const char *uname, int64_t);
-static int64_t	lookup_uid(void *, const char *uname, int64_t);
+static __LA_INT64_T	lookup_gid(void *, const char *uname, __LA_INT64_T);
+static __LA_INT64_T	lookup_uid(void *, const char *uname, __LA_INT64_T);
 #endif
 static void	cleanup(void *);
 
@@ -99,11 +99,11 @@
 }
 
 #if ARCHIVE_VERSION_NUMBER < 3000000
-static gid_t
-lookup_gid(void *private_data, const char *gname, gid_t gid)
+static __LA_GID_T
+lookup_gid(void *private_data, const char *gname, __LA_GID_T gid)
 #else
-static int64_t
-lookup_gid(void *private_data, const char *gname, int64_t gid)
+static __LA_INT64_T
+lookup_gid(void *private_data, const char *gname, __LA_INT64_T gid)
 #endif
 {
 	int h;
@@ -118,7 +118,7 @@
 	h = hash(gname);
 	b = &gcache[h % cache_size ];
 	if (b->name != NULL && b->hash == h && strcmp(gname, b->name) == 0)
-		return ((gid_t)b->id);
+		return ((__LA_GID_T)b->id);
 
 	/* Free the cache slot for a new entry. */
 	if (b->name != NULL)
@@ -174,11 +174,11 @@
 }
 
 #if ARCHIVE_VERSION_NUMBER < 3000000
-static uid_t
-lookup_uid(void *private_data, const char *uname, uid_t uid)
+static __LA_UID_T
+lookup_uid(void *private_data, const char *uname, __LA_UID_T uid)
 #else
-static int64_t
-lookup_uid(void *private_data, const char *uname, int64_t uid)
+static __LA_INT64_T
+lookup_uid(void *private_data, const char *uname, __LA_INT64_T uid)
 #endif
 {
 	int h;
@@ -193,7 +193,7 @@
 	h = hash(uname);
 	b = &ucache[h % cache_size ];
 	if (b->name != NULL && b->hash == h && strcmp(uname, b->name) == 0)
-		return ((uid_t)b->id);
+		return ((__LA_UID_T)b->id);
 
 	/* Free the cache slot for a new entry. */
 	if (b->name != NULL)
Index: libarchive/archive_read_disk_entry_from_file.c
===================================================================
--- libarchive/archive_read_disk_entry_from_file.c	(revision 2914)
+++ libarchive/archive_read_disk_entry_from_file.c	(working copy)
@@ -426,11 +426,11 @@
 
 		acl_get_tag_type(acl_entry, &acl_tag);
 		if (acl_tag == ACL_USER) {
-			ae_id = (int)*(uid_t *)acl_get_qualifier(acl_entry);
+			ae_id = (int)*(__LA_UID_T *)acl_get_qualifier(acl_entry);
 			ae_name = archive_read_disk_uname(&a->archive, ae_id);
 			ae_tag = ARCHIVE_ENTRY_ACL_USER;
 		} else if (acl_tag == ACL_GROUP) {
-			ae_id = (int)*(gid_t *)acl_get_qualifier(acl_entry);
+			ae_id = (int)*(__LA_GID_T *)acl_get_qualifier(acl_entry);
 			ae_name = archive_read_disk_gname(&a->archive, ae_id);
 			ae_tag = ARCHIVE_ENTRY_ACL_GROUP;
 		} else if (acl_tag == ACL_MASK) {
@@ -496,7 +496,7 @@
 setup_xattr(struct archive_read_disk *a,
     struct archive_entry *entry, const char *name, int fd)
 {
-	ssize_t size;
+	__LA_SSIZE_T size;
 	void *value = NULL;
 	const char *accpath;
 
@@ -545,7 +545,7 @@
 {
 	char *list, *p;
 	const char *path;
-	ssize_t list_size;
+	__LA_SSIZE_T list_size;
 
 
 	path = archive_entry_sourcepath(entry);
@@ -616,7 +616,7 @@
 setup_xattr(struct archive_read_disk *a, struct archive_entry *entry,
     int namespace, const char *name, const char *fullname, int fd)
 {
-	ssize_t size;
+	__LA_SSIZE_T size;
 	void *value = NULL;
 	const char *accpath;
 
@@ -665,7 +665,7 @@
 {
 	char buff[512];
 	char *list, *p;
-	ssize_t list_size;
+	__LA_SSIZE_T list_size;
 	const char *path;
 	int namespace = EXTATTR_NAMESPACE_USER;
 
@@ -768,7 +768,7 @@
 	char buff[4096];
 	struct fiemap *fm;
 	struct fiemap_extent *fe;
-	int64_t size;
+	__LA_INT64_T size;
 	int count, do_fiemap;
 	int initial_fd = fd;
 	int exit_sts = ARCHIVE_OK;
@@ -822,7 +822,7 @@
 			if (!(fe->fe_flags & FIEMAP_EXTENT_UNWRITTEN)) {
 				/* The fe_length of the last block does not
 				 * adjust itself to its size files. */
-				int64_t length = fe->fe_length;
+				__LA_INT64_T length = fe->fe_length;
 				if (fe->fe_logical + length > size)
 					length -= fe->fe_logical + length - size;
 				if (fe->fe_logical == 0 && length == size) {
@@ -859,7 +859,7 @@
 setup_sparse(struct archive_read_disk *a,
     struct archive_entry *entry, int fd)
 {
-	int64_t size;
+	__LA_INT64_T size;
 	int initial_fd = fd;
 	off_t initial_off; // FreeBSD/Solaris only, so off_t okay here
 	off_t off_s, off_e; // FreeBSD/Solaris only, so off_t okay here
Index: libarchive/archive_platform.h
===================================================================
--- libarchive/archive_platform.h	(revision 2914)
+++ libarchive/archive_platform.h	(working copy)
@@ -61,6 +61,12 @@
 #endif
 
 /*
+ * Note: Need to include archive.h for platform definitions such as
+ * __LA_INT64_T
+ */
+#include "archive.h"
+
+/*
  * The config files define a lot of feature macros.  The following
  * uses those macros to select/define replacements and include key
  * headers as required.
@@ -109,19 +115,19 @@
 #define	SIZE_MAX (~(size_t)0)
 #endif
 #if !HAVE_DECL_SSIZE_MAX
-#define	SSIZE_MAX ((ssize_t)(SIZE_MAX >> 1))
+#define	SSIZE_MAX ((__LA_SSIZE_T)(SIZE_MAX >> 1))
 #endif
 #if !HAVE_DECL_UINT32_MAX
-#define	UINT32_MAX (~(uint32_t)0)
+#define	UINT32_MAX (~(__LA_UINT32_T)0)
 #endif
 #if !HAVE_DECL_UINT64_MAX
-#define	UINT64_MAX (~(uint64_t)0)
+#define	UINT64_MAX (~(__LA_UINT64_T)0)
 #endif
 #if !HAVE_DECL_INT64_MAX
-#define	INT64_MAX ((int64_t)(UINT64_MAX >> 1))
+#define	INT64_MAX ((__LA_INT64_T)(UINT64_MAX >> 1))
 #endif
 #if !HAVE_DECL_INT64_MIN
-#define	INT64_MIN ((int64_t)(~INT64_MAX))
+#define	INT64_MIN ((__LA_INT64_T)(~INT64_MAX))
 #endif
 
 /*
Index: libarchive/archive_read_support_format_cpio.c
===================================================================
--- libarchive/archive_read_support_format_cpio.c	(revision 2914)
+++ libarchive/archive_read_support_format_cpio.c	(working copy)
@@ -120,8 +120,8 @@
         struct links_entry      *next;
         struct links_entry      *previous;
         int                      links;
-        dev_t                    dev;
-        int64_t                  ino;
+        __LA_DEV_T                    dev;
+        __LA_INT64_T                  ino;
         char                    *name;
 };
 
@@ -133,18 +133,18 @@
 	struct links_entry	 *links_head;
 	struct archive_string	  entry_name;
 	struct archive_string	  entry_linkname;
-	int64_t			  entry_bytes_remaining;
-	int64_t			  entry_bytes_unconsumed;
-	int64_t			  entry_offset;
-	int64_t			  entry_padding;
+	__LA_INT64_T			  entry_bytes_remaining;
+	__LA_INT64_T			  entry_bytes_unconsumed;
+	__LA_INT64_T			  entry_offset;
+	__LA_INT64_T			  entry_padding;
 };
 
-static int64_t	atol16(const char *, unsigned);
-static int64_t	atol8(const char *, unsigned);
+static __LA_INT64_T	atol16(const char *, unsigned);
+static __LA_INT64_T	atol8(const char *, unsigned);
 static int	archive_read_format_cpio_bid(struct archive_read *);
 static int	archive_read_format_cpio_cleanup(struct archive_read *);
 static int	archive_read_format_cpio_read_data(struct archive_read *,
-		    const void **, size_t *, int64_t *);
+		    const void **, size_t *, __LA_INT64_T *);
 static int	archive_read_format_cpio_read_header(struct archive_read *,
 		    struct archive_entry *);
 static int	archive_read_format_cpio_skip(struct archive_read *);
@@ -322,9 +322,9 @@
 
 static int
 archive_read_format_cpio_read_data(struct archive_read *a,
-    const void **buff, size_t *size, int64_t *offset)
+    const void **buff, size_t *size, __LA_INT64_T *offset)
 {
-	ssize_t bytes_read;
+	__LA_SSIZE_T bytes_read;
 	struct cpio *cpio;
 
 	cpio = (struct cpio *)(a->format->data);
@@ -363,7 +363,7 @@
 archive_read_format_cpio_skip(struct archive_read *a)
 {
 	struct cpio *cpio = (struct cpio *)(a->format->data);
-	int64_t to_skip = cpio->entry_bytes_remaining + cpio->entry_padding +
+	__LA_INT64_T to_skip = cpio->entry_bytes_remaining + cpio->entry_padding +
 		cpio->entry_bytes_unconsumed;
 
 	if (to_skip != __archive_read_consume(a, to_skip)) {
@@ -400,7 +400,7 @@
 	const void *h;
 	const char *p, *q;
 	size_t skip, skipped = 0;
-	ssize_t bytes;
+	__LA_SSIZE_T bytes;
 
 	for (;;) {
 		h = __archive_read_ahead(a, sizeof(struct cpio_newc_header), &bytes);
@@ -556,7 +556,7 @@
 	const void *h;
 	const char *p, *q;
 	size_t skip, skipped = 0;
-	ssize_t bytes;
+	__LA_SSIZE_T bytes;
 
 	for (;;) {
 		h = __archive_read_ahead(a, sizeof(struct cpio_odc_header), &bytes);
@@ -829,10 +829,10 @@
  * locale settings; you cannot simply substitute strtol here, since
  * it does obey locale.
  */
-static int64_t
+static __LA_INT64_T
 atol8(const char *p, unsigned char_cnt)
 {
-	int64_t l;
+	__LA_INT64_T l;
 	int digit;
 
 	l = 0;
@@ -848,10 +848,10 @@
 	return (l);
 }
 
-static int64_t
+static __LA_INT64_T
 atol16(const char *p, unsigned char_cnt)
 {
-	int64_t l;
+	__LA_INT64_T l;
 	int digit;
 
 	l = 0;
@@ -875,8 +875,8 @@
 record_hardlink(struct cpio *cpio, struct archive_entry *entry)
 {
 	struct links_entry      *le;
-	dev_t dev;
-	int64_t ino;
+	__LA_DEV_T dev;
+	__LA_INT64_T ino;
 
 	if (archive_entry_nlink(entry) <= 1)
 		return;
Index: libarchive/archive_read_support_format_xar.c
===================================================================
--- libarchive/archive_read_support_format_xar.c	(revision 2914)
+++ libarchive/archive_read_support_format_xar.c	(working copy)
@@ -137,10 +137,10 @@
 struct xattr {
 	struct xattr		*next;
 	struct archive_string	 name;
-	uint64_t		 id;
-	uint64_t		 length;
-	uint64_t		 offset;
-	uint64_t		 size;
+	__LA_UINT64_T		 id;
+	__LA_UINT64_T		 length;
+	__LA_UINT64_T		 offset;
+	__LA_UINT64_T		 size;
 	enum enctype		 encoding;
 	struct chksumval	 a_sum;
 	struct chksumval	 e_sum;
@@ -170,10 +170,10 @@
 #define HAS_XATTR		0x02000
 #define HAS_ACL			0x04000
 
-	uint64_t		 id;
-	uint64_t		 length;
-	uint64_t		 offset;
-	uint64_t		 size;
+	__LA_UINT64_T		 id;
+	__LA_UINT64_T		 length;
+	__LA_UINT64_T		 offset;
+	__LA_UINT64_T		 size;
 	enum enctype		 encoding;
 	struct chksumval	 a_sum;
 	struct chksumval	 e_sum;
@@ -183,14 +183,14 @@
 	time_t			 mtime;
 	time_t			 atime;
 	struct archive_string	 uname;
-	uid_t			 uid;
+	__LA_UID_T			 uid;
 	struct archive_string	 gname;
-	gid_t			 gid;
-	mode_t			 mode;
-	dev_t			 dev;
-	dev_t			 devmajor;
-	dev_t			 devminor;
-	int64_t			 ino64;
+	__LA_GID_T			 gid;
+	__LA_MODE_T			 mode;
+	__LA_DEV_T			 dev;
+	__LA_DEV_T			 devmajor;
+	__LA_DEV_T			 devminor;
+	__LA_INT64_T			 ino64;
 	struct archive_string	 fflags_text;
 	unsigned int		 link;
 	unsigned int		 nlink;
@@ -301,9 +301,9 @@
 };
 
 struct xar {
-	uint64_t		 offset; /* Current position in the file. */
-	int64_t			 total;
-	uint64_t		 h_base;
+	__LA_UINT64_T		 offset; /* Current position in the file. */
+	__LA_INT64_T			 total;
+	__LA_UINT64_T		 h_base;
 	int			 end_of_file;
 	unsigned char		 buff[1024*32];
 
@@ -315,10 +315,10 @@
 	/*
 	 * TOC
 	 */
-	uint64_t		 toc_remaining;
-	uint64_t		 toc_total;
-	uint64_t		 toc_chksum_offset;
-	uint64_t		 toc_chksum_size;
+	__LA_UINT64_T		 toc_remaining;
+	__LA_UINT64_T		 toc_total;
+	__LA_UINT64_T		 toc_chksum_offset;
+	__LA_UINT64_T		 toc_chksum_size;
 
 	/*
 	 * For Decoding data.
@@ -350,10 +350,10 @@
 	struct hdlink		*hdlink_list;
 
 	int	 		 entry_init;
-	uint64_t		 entry_total;
-	uint64_t		 entry_remaining;
+	__LA_UINT64_T		 entry_total;
+	__LA_UINT64_T		 entry_remaining;
 	size_t			 entry_unconsumed;
-	uint64_t		 entry_size;
+	__LA_UINT64_T		 entry_size;
 	enum enctype 		 entry_encoding;
 	struct chksumval	 entry_a_sum;
 	struct chksumval	 entry_e_sum;
@@ -374,16 +374,16 @@
 static int	xar_read_header(struct archive_read *,
 		    struct archive_entry *);
 static int	xar_read_data(struct archive_read *,
-		    const void **, size_t *, int64_t *);
+		    const void **, size_t *, __LA_INT64_T *);
 static int	xar_read_data_skip(struct archive_read *);
 static int	xar_cleanup(struct archive_read *);
-static int	move_reading_point(struct archive_read *, uint64_t);
+static int	move_reading_point(struct archive_read *, __LA_UINT64_T);
 static int	rd_contents_init(struct archive_read *,
 		    enum enctype, int, int);
 static int	rd_contents(struct archive_read *, const void **,
-		    size_t *, size_t *, uint64_t);
-static uint64_t	atol10(const char *, size_t);
-static int64_t	atol8(const char *, size_t);
+		    size_t *, size_t *, __LA_UINT64_T);
+static __LA_UINT64_T	atol10(const char *, size_t);
+static __LA_INT64_T	atol8(const char *, size_t);
 static size_t	atohex(unsigned char *, size_t, const char *, size_t);
 static time_t	parse_time(const char *p, size_t n);
 static void	heap_add_entry(struct heap_queue *, struct xar_file *);
@@ -509,10 +509,10 @@
 	struct xar *xar;
 	struct xar_file *file;
 	const unsigned char *b;
-	uint64_t toc_compressed_size;
-	uint64_t toc_uncompressed_size;
-	uint32_t toc_chksum_alg;
-	ssize_t bytes;
+	__LA_UINT64_T toc_compressed_size;
+	__LA_UINT64_T toc_uncompressed_size;
+	__LA_UINT32_T toc_chksum_alg;
+	__LA_SSIZE_T bytes;
 	int r;
 
 	xar = (struct xar *)(a->format->data);
@@ -588,7 +588,7 @@
 		b = __archive_read_ahead(a, xar->toc_chksum_size, &bytes);
 		if (bytes < 0)
 			return ((int)bytes);
-		if ((uint64_t)bytes < xar->toc_chksum_size) {
+		if ((__LA_UINT64_T)bytes < xar->toc_chksum_size) {
 			archive_set_error(&a->archive,
 			    ARCHIVE_ERRNO_FILE_FORMAT,
 			    "Truncated archive file");
@@ -760,7 +760,7 @@
 
 static int
 xar_read_data(struct archive_read *a,
-    const void **buff, size_t *size, int64_t *offset)
+    const void **buff, size_t *size, __LA_INT64_T *offset)
 {
 	struct xar *xar;
 	size_t used;
@@ -826,7 +826,7 @@
 xar_read_data_skip(struct archive_read *a)
 {
 	struct xar *xar;
-	int64_t bytes_skipped;
+	__LA_INT64_T bytes_skipped;
 
 	xar = (struct xar *)(a->format->data);
 	if (xar->end_of_file)
@@ -873,14 +873,14 @@
 }
 
 static int
-move_reading_point(struct archive_read *a, uint64_t offset)
+move_reading_point(struct archive_read *a, __LA_UINT64_T offset)
 {
 	struct xar *xar;
 
 	xar = (struct xar *)(a->format->data);
 	if (xar->offset - xar->h_base != offset) {
 		/* Seek forward to the start of file contents. */
-		int64_t step;
+		__LA_INT64_T step;
 
 		step = offset - (xar->offset - xar->h_base);
 		if (step > 0) {
@@ -914,10 +914,10 @@
 
 static int
 rd_contents(struct archive_read *a, const void **buff, size_t *size,
-    size_t *used, uint64_t remaining)
+    size_t *used, __LA_UINT64_T remaining)
 {
 	const unsigned char *b;
-	ssize_t bytes;
+	__LA_SSIZE_T bytes;
 
 	/* Get whatever bytes are immediately available. */
 	b = __archive_read_ahead(a, 1, &bytes);
@@ -928,8 +928,8 @@
 		    "Truncated archive file");
 		return (ARCHIVE_FATAL);
 	}
-	if ((uint64_t)bytes > remaining)
-		bytes = (ssize_t)remaining;
+	if ((__LA_UINT64_T)bytes > remaining)
+		bytes = (__LA_SSIZE_T)remaining;
 
 	/*
 	 * Decompress contents of file.
@@ -952,10 +952,10 @@
  * it does obey locale.
  */
 
-static uint64_t
+static __LA_UINT64_T
 atol10(const char *p, size_t char_cnt)
 {
-	uint64_t l;
+	__LA_UINT64_T l;
 	int digit;
 
 	l = 0;
@@ -967,10 +967,10 @@
 	return (l);
 }
 
-static int64_t
+static __LA_INT64_T
 atol8(const char *p, size_t char_cnt)
 {
-	int64_t l;
+	__LA_INT64_T l;
 	int digit;
         
 	l = 0;
@@ -1045,7 +1045,7 @@
 {
 	struct tm tm;
 	time_t t = 0;
-	int64_t data;
+	__LA_INT64_T data;
 
 	memset(&tm, 0, sizeof(tm));
 	if (n != 20)
@@ -1103,7 +1103,7 @@
 static void
 heap_add_entry(struct heap_queue *heap, struct xar_file *file)
 {
-	uint64_t file_id, parent_id;
+	__LA_UINT64_T file_id, parent_id;
 	int hole, parent;
 
 	/* Expand our pending files list as necessary. */
@@ -1151,7 +1151,7 @@
 static struct xar_file *
 heap_get_entry(struct heap_queue *heap)
 {
-	uint64_t a_id, b_id, c_id;
+	__LA_UINT64_T a_id, b_id, c_id;
 	int a, b, c;
 	struct xar_file *r, *tmp;
 
@@ -2621,15 +2621,15 @@
 		break;
 	case FILE_DEVICE_MAJOR:
 		xar->file->has |= HAS_DEVMAJOR;
-		xar->file->devmajor = (dev_t)atol10(s, len);
+		xar->file->devmajor = (__LA_DEV_T)atol10(s, len);
 		break;
 	case FILE_DEVICE_MINOR:
 		xar->file->has |= HAS_DEVMINOR;
-		xar->file->devminor = (dev_t)atol10(s, len);
+		xar->file->devminor = (__LA_DEV_T)atol10(s, len);
 		break;
 	case FILE_DEVICENO:
 		xar->file->has |= HAS_DEV;
-		xar->file->dev = (dev_t)atol10(s, len);
+		xar->file->dev = (__LA_DEV_T)atol10(s, len);
 		break;
 	case FILE_MODE:
 		xar->file->has |= HAS_MODE;
Index: libarchive/archive_write.c
===================================================================
--- libarchive/archive_write.c	(revision 2914)
+++ libarchive/archive_write.c	(working copy)
@@ -64,13 +64,13 @@
 
 static int	_archive_filter_code(struct archive *, int);
 static const char *_archive_filter_name(struct archive *, int);
-static int64_t	_archive_filter_bytes(struct archive *, int);
+static __LA_INT64_T	_archive_filter_bytes(struct archive *, int);
 static int  _archive_write_filter_count(struct archive *);
 static int	_archive_write_close(struct archive *);
 static int	_archive_write_free(struct archive *);
 static int	_archive_write_header(struct archive *, struct archive_entry *);
 static int	_archive_write_finish_entry(struct archive *);
-static ssize_t	_archive_write_data(struct archive *, const void *, size_t);
+static __LA_SSIZE_T	_archive_write_data(struct archive *, const void *, size_t);
 
 struct archive_none {
 	size_t buffer_size;
@@ -193,10 +193,10 @@
  */
 #if ARCHIVE_VERSION_NUMBER < 3000000
 int
-archive_write_set_skip_file(struct archive *_a, dev_t d, ino_t i)
+archive_write_set_skip_file(struct archive *_a, __LA_DEV_T d, ino_t i)
 #else
 int
-archive_write_set_skip_file(struct archive *_a, int64_t d, int64_t i)
+archive_write_set_skip_file(struct archive *_a, __LA_INT64_T d, __LA_INT64_T i)
 #endif
 {
 	struct archive_write *a = (struct archive_write *)_a;
@@ -328,8 +328,8 @@
 	struct archive_write *a = (struct archive_write *)f->archive;
         struct archive_none *state = (struct archive_none *)f->data;
         const char *buff = (const char *)_buff;
-        ssize_t remaining, to_copy;
-        ssize_t bytes_written;
+        __LA_SSIZE_T remaining, to_copy;
+        __LA_SSIZE_T bytes_written;
 
         remaining = length;
 
@@ -408,9 +408,9 @@
 {
 	struct archive_write *a = (struct archive_write *)f->archive;
         struct archive_none *state = (struct archive_none *)f->data;
-        ssize_t block_length;
-        ssize_t target_block_length;
-        ssize_t bytes_written;
+        __LA_SSIZE_T block_length;
+        __LA_SSIZE_T target_block_length;
+        __LA_SSIZE_T bytes_written;
         int ret = ARCHIVE_OK;
 
         /* If there's pending data, pad and write the last block */
@@ -656,7 +656,7 @@
 /*
  * Note that the compressor is responsible for blocking.
  */
-static ssize_t
+static __LA_SSIZE_T
 _archive_write_data(struct archive *_a, const void *buff, size_t s)
 {
 	struct archive_write *a = (struct archive_write *)_a;
@@ -696,7 +696,7 @@
 	return f == NULL ? NULL : f->name;
 }
 
-static int64_t
+static __LA_INT64_T
 _archive_filter_bytes(struct archive *_a, int n)
 {
 	struct archive_write_filter *f = filter_lookup(_a, n);
Index: libarchive/archive_write_set_format_shar.c
===================================================================
--- libarchive/archive_write_set_format_shar.c	(revision 2914)
+++ libarchive/archive_write_set_format_shar.c	(working copy)
@@ -63,9 +63,9 @@
 static int	archive_write_shar_free(struct archive_write *);
 static int	archive_write_shar_header(struct archive_write *,
 		    struct archive_entry *);
-static ssize_t	archive_write_shar_data_sed(struct archive_write *,
+static __LA_SSIZE_T	archive_write_shar_data_sed(struct archive_write *,
 		    const void * buff, size_t);
-static ssize_t	archive_write_shar_data_uuencode(struct archive_write *,
+static __LA_SSIZE_T	archive_write_shar_data_uuencode(struct archive_write *,
 		    const void * buff, size_t);
 static int	archive_write_shar_finish_entry(struct archive_write *);
 
@@ -327,7 +327,7 @@
 	return (ARCHIVE_OK);
 }
 
-static ssize_t
+static __LA_SSIZE_T
 archive_write_shar_data_sed(struct archive_write *a, const void *buff, size_t n)
 {
 	static const size_t ensured = 65533;
@@ -442,7 +442,7 @@
 	shar->work.length = buf - shar->work.s;
 }
 
-static ssize_t
+static __LA_SSIZE_T
 archive_write_shar_data_uuencode(struct archive_write *a, const void *buff,
     size_t length)
 {
Index: libarchive/archive_write_set_format_ustar.c
===================================================================
--- libarchive/archive_write_set_format_ustar.c	(revision 2914)
+++ libarchive/archive_write_set_format_ustar.c	(working copy)
@@ -44,8 +44,8 @@
 #include "archive_write_private.h"
 
 struct ustar {
-	uint64_t	entry_bytes_remaining;
-	uint64_t	entry_padding;
+	__LA_UINT64_T	entry_bytes_remaining;
+	__LA_UINT64_T	entry_padding;
 };
 
 /*
@@ -141,16 +141,16 @@
 	0,0,0,0,0,0,0,0, 0,0,0,0
 };
 
-static ssize_t	archive_write_ustar_data(struct archive_write *a, const void *buff,
+static __LA_SSIZE_T	archive_write_ustar_data(struct archive_write *a, const void *buff,
 		    size_t s);
 static int	archive_write_ustar_free(struct archive_write *);
 static int	archive_write_ustar_close(struct archive_write *);
 static int	archive_write_ustar_finish_entry(struct archive_write *);
 static int	archive_write_ustar_header(struct archive_write *,
 		    struct archive_entry *entry);
-static int	format_256(int64_t, char *, int);
-static int	format_number(int64_t, char *, int size, int max, int strict);
-static int	format_octal(int64_t, char *, int);
+static int	format_256(__LA_INT64_T, char *, int);
+static int	format_number(__LA_INT64_T, char *, int size, int max, int strict);
+static int	format_octal(__LA_INT64_T, char *, int);
 
 /*
  * Set output format to 'ustar' format.
@@ -239,7 +239,7 @@
 		ret = ret2;
 
 	ustar->entry_bytes_remaining = archive_entry_size(entry);
-	ustar->entry_padding = 0x1ff & (-(int64_t)ustar->entry_bytes_remaining);
+	ustar->entry_padding = 0x1ff & (-(__LA_INT64_T)ustar->entry_bytes_remaining);
 	return (ret);
 }
 
@@ -441,11 +441,11 @@
  * Format a number into a field, with some intelligence.
  */
 static int
-format_number(int64_t v, char *p, int s, int maxsize, int strict)
+format_number(__LA_INT64_T v, char *p, int s, int maxsize, int strict)
 {
-	int64_t limit;
+	__LA_INT64_T limit;
 
-	limit = ((int64_t)1 << (s*3));
+	limit = ((__LA_INT64_T)1 << (s*3));
 
 	/* "Strict" only permits octal values with proper termination. */
 	if (strict)
@@ -474,7 +474,7 @@
  * Format a number into the specified field using base-256.
  */
 static int
-format_256(int64_t v, char *p, int s)
+format_256(__LA_INT64_T v, char *p, int s)
 {
 	p += s;
 	while (s-- > 0) {
@@ -489,7 +489,7 @@
  * Format a number into the specified field.
  */
 static int
-format_octal(int64_t v, char *p, int s)
+format_octal(__LA_INT64_T v, char *p, int s)
 {
 	int len;
 
@@ -548,7 +548,7 @@
 	return (ret);
 }
 
-static ssize_t
+static __LA_SSIZE_T
 archive_write_ustar_data(struct archive_write *a, const void *buff, size_t s)
 {
 	struct ustar *ustar;
Index: libarchive/archive_read.3
===================================================================
--- libarchive/archive_read.3	(revision 2914)
+++ libarchive/archive_read.3	(working copy)
@@ -158,7 +158,7 @@
 .Fn archive_read_next_header "struct archive *" "struct archive_entry **"
 .Ft int
 .Fn archive_read_next_header2 "struct archive *" "struct archive_entry *"
-.Ft ssize_t
+.Ft __LA_SSIZE_T
 .Fn archive_read_data "struct archive *" "void *buff" "size_t len"
 .Ft int
 .Fo archive_read_data_block
@@ -171,7 +171,7 @@
 .Fn archive_read_data_skip "struct archive *"
 .\" #if ARCHIVE_API_VERSION < 3
 .Ft int
-.Fn archive_read_data_into_buffer "struct archive *" "void *" "ssize_t len"
+.Fn archive_read_data_into_buffer "struct archive *" "void *" "__LA_SSIZE_T len"
 .\" #endif
 .Ft int
 .Fn archive_read_data_into_fd "struct archive *" "int fd"
@@ -488,7 +488,7 @@
 The callback functions must match the following prototypes:
 .Bl -item -offset indent
 .It
-.Ft typedef ssize_t
+.Ft typedef __LA_SSIZE_T
 .Fo archive_read_callback
 .Fa "struct archive *"
 .Fa "void *client_data"
@@ -595,7 +595,7 @@
   free(mydata);
 }
 
-ssize_t
+__LA_SSIZE_T
 myread(struct archive *a, void *client_data, const void **buff)
 {
   struct mydata *mydata = client_data;
Index: libarchive/archive_util.3
===================================================================
--- libarchive/archive_util.3	(revision 2914)
+++ libarchive/archive_util.3	(working copy)
@@ -69,7 +69,7 @@
 .Fn archive_format "struct archive *"
 .Ft const char *
 .Fn archive_format_name "struct archive *"
-.Ft int64_t
+.Ft __LA_INT64_T
 .Fn archive_position "struct archive *" "int"
 .Ft void
 .Fo archive_set_error
Index: libarchive/archive_write_set_format_zip.c
===================================================================
--- libarchive/archive_write_set_format_zip.c	(revision 2914)
+++ libarchive/archive_write_set_format_zip.c	(working copy)
@@ -91,7 +91,7 @@
 #endif
 };
 
-static ssize_t archive_write_zip_data(struct archive_write *, const void *buff, size_t s);
+static __LA_SSIZE_T archive_write_zip_data(struct archive_write *, const void *buff, size_t s);
 static int archive_write_zip_close(struct archive_write *);
 static int archive_write_zip_free(struct archive_write *);
 static int archive_write_zip_finish_entry(struct archive_write *);
@@ -164,9 +164,9 @@
 struct zip_file_header_link {
 	struct zip_file_header_link *next;
 	struct archive_entry *entry;
-	int64_t offset;
+	__LA_INT64_T offset;
 	unsigned long crc32;
-	int64_t compressed_size;
+	__LA_INT64_T compressed_size;
 	enum compression compression;
 };
 
@@ -174,9 +174,9 @@
 	struct zip_data_descriptor data_descriptor;
 	struct zip_file_header_link *central_directory;
 	struct zip_file_header_link *central_directory_end;
-	int64_t offset;
-	int64_t written_bytes;
-	int64_t remaining_data_bytes;
+	__LA_INT64_T offset;
+	__LA_INT64_T written_bytes;
+	__LA_INT64_T remaining_data_bytes;
 	enum compression compression;
 
 #ifdef HAVE_ZLIB_H
@@ -283,8 +283,8 @@
 	struct zip_data_descriptor *d;
 	struct zip_file_header_link *l;
 	int ret;
-	int64_t size;
-	mode_t type;
+	__LA_INT64_T size;
+	__LA_MODE_T type;
 
 	/* Entries other than a regular file or a folder are skipped. */
 	type = archive_entry_filetype(entry);
@@ -330,7 +330,7 @@
 	archive_le16enc(&h.flags, ZIP_FLAGS);
 	archive_le16enc(&h.compression, zip->compression);
 	archive_le32enc(&h.timedate, dos_time(archive_entry_mtime(entry)));
-	archive_le16enc(&h.filename_length, (uint16_t)path_length(entry));
+	archive_le16enc(&h.filename_length, (__LA_UINT16_T)path_length(entry));
 
 	switch (zip->compression) {
 	case COMPRESSION_STORE:
@@ -393,14 +393,14 @@
 	return (ARCHIVE_OK);
 }
 
-static ssize_t
+static __LA_SSIZE_T
 archive_write_zip_data(struct archive_write *a, const void *buff, size_t s)
 {
 	int ret;
 	struct zip *zip = a->format_data;
 	struct zip_file_header_link *l = zip->central_directory_end;
 
-	if ((int64_t)s > zip->remaining_data_bytes)
+	if ((__LA_INT64_T)s > zip->remaining_data_bytes)
 		s = (size_t)zip->remaining_data_bytes;
 
 	if (s == 0) return 0;
@@ -499,7 +499,7 @@
 	struct zip_file_header h;
 	struct zip_central_directory_end end;
 	struct zip_extra_data_central e;
-	int64_t offset_start, offset_end;
+	__LA_INT64_T offset_start, offset_end;
 	int entries;
 	int ret;
 
@@ -531,7 +531,7 @@
 		archive_le32enc(&h.crc32, l->crc32);
 		archive_le32enc(&h.compressed_size, l->compressed_size);
 		archive_le32enc(&h.uncompressed_size, archive_entry_size(l->entry));
-		archive_le16enc(&h.filename_length, (uint16_t)path_length(l->entry));
+		archive_le16enc(&h.filename_length, (__LA_UINT16_T)path_length(l->entry));
 		archive_le16enc(&h.extra_length, sizeof(e));
 		archive_le16enc(&h.attributes_external[2], archive_entry_mode(l->entry));
 		archive_le32enc(&h.offset, l->offset);
@@ -635,7 +635,7 @@
 static size_t
 path_length(struct archive_entry *entry)
 {
-	mode_t type;
+	__LA_MODE_T type;
 	const char *path;
 
 	type = archive_entry_filetype(entry);
@@ -653,7 +653,7 @@
 {
 	int ret;
 	const char *path;
-	mode_t type;
+	__LA_MODE_T type;
 	size_t written_bytes;
 
 	path = archive_entry_pathname(entry);
Index: libarchive/archive_read_disk_windows.c
===================================================================
--- libarchive/archive_read_disk_windows.c	(revision 2914)
+++ libarchive/archive_read_disk_windows.c	(working copy)
@@ -115,14 +115,14 @@
 	size_t			 full_path_dir_length;
 	struct archive_wstring	 name;
 	size_t			 dirname_length;
-	int64_t			 dev;
-	int64_t			 ino;
+	__LA_INT64_T			 dev;
+	__LA_INT64_T			 ino;
 	int			 flags;
 	int			 filesystem_id;
 };
 
 struct filesystem {
-	int64_t		dev;
+	__LA_INT64_T		dev;
 	int		synthetic;
 	int		remote;
 };
@@ -175,8 +175,8 @@
 	int			 descend;
 
 	struct entry_sparse {
-		int64_t		 length;
-		int64_t		 offset;
+		__LA_INT64_T		 length;
+		__LA_INT64_T		 offset;
 	}			*sparse_list, *current_sparse;
 	int			 sparse_count;
 	int			 sparse_list_size;
@@ -194,7 +194,7 @@
 /* Treat FileIndex as i-node. We should remove a sequence number
  * which is high-16-bits of nFileIndexHigh. */
 #define bhfi_ino(bhfi)	\
-	((((int64_t)((bhfi)->nFileIndexHigh & 0x0000FFFFUL)) << 32) \
+	((((__LA_INT64_T)((bhfi)->nFileIndexHigh & 0x0000FFFFUL)) << 32) \
     + (bhfi)->nFileIndexLow)
 
 /* Definitions for tree.flags bitmap. */
@@ -217,7 +217,7 @@
 static struct tree *tree_reopen(struct tree *, const char *);
 static void tree_close(struct tree *);
 static void tree_free(struct tree *);
-static void tree_push(struct tree *, const wchar_t *, int, int64_t, int64_t);
+static void tree_push(struct tree *, const wchar_t *, int, __LA_INT64_T, __LA_INT64_T);
 
 /*
  * tree_next() returns Zero if there is no next entry, non-zero if
@@ -280,7 +280,7 @@
 /* "is_dir" is equivalent to S_ISDIR(tree_current_stat()->st_mode) */
 static int tree_current_is_dir(struct tree *);
 static int update_current_filesystem(struct archive_read_disk *a,
-		    int64_t dev);
+		    __LA_INT64_T dev);
 static int setup_current_filesystem(struct archive_read_disk *);
 static int tree_target_is_same_as_parent(struct tree *,
 		    const BY_HANDLE_FILE_INFORMATION *);
@@ -288,15 +288,15 @@
 static int	_archive_read_free(struct archive *);
 static int	_archive_read_close(struct archive *);
 static int	_archive_read_data_block(struct archive *,
-		    const void **, size_t *, int64_t *);
+		    const void **, size_t *, __LA_INT64_T *);
 static int	_archive_read_next_header2(struct archive *,
 		    struct archive_entry *);
 #if ARCHIVE_VERSION_NUMBER < 3000000
-static const char *trivial_lookup_gname(void *, gid_t gid);
-static const char *trivial_lookup_uname(void *, uid_t uid);
+static const char *trivial_lookup_gname(void *, __LA_GID_T gid);
+static const char *trivial_lookup_uname(void *, __LA_UID_T uid);
 #else
-static const char *trivial_lookup_gname(void *, int64_t gid);
-static const char *trivial_lookup_uname(void *, int64_t uid);
+static const char *trivial_lookup_gname(void *, __LA_INT64_T gid);
+static const char *trivial_lookup_uname(void *, __LA_INT64_T uid);
 #endif
 static int	setup_sparse(struct archive_read_disk *, struct archive_entry *);
 
@@ -319,10 +319,10 @@
 
 #if ARCHIVE_VERSION_NUMBER < 3000000
 const char *
-archive_read_disk_gname(struct archive *_a, gid_t gid)
+archive_read_disk_gname(struct archive *_a, __LA_GID_T gid)
 #else
 const char *
-archive_read_disk_gname(struct archive *_a, int64_t gid)
+archive_read_disk_gname(struct archive *_a, __LA_INT64_T gid)
 #endif
 {
 	struct archive_read_disk *a = (struct archive_read_disk *)_a;
@@ -336,10 +336,10 @@
 
 #if ARCHIVE_VERSION_NUMBER < 3000000
 const char *
-archive_read_disk_uname(struct archive *_a, uid_t uid)
+archive_read_disk_uname(struct archive *_a, __LA_UID_T uid)
 #else
 const char *
-archive_read_disk_uname(struct archive *_a, int64_t uid)
+archive_read_disk_uname(struct archive *_a, __LA_INT64_T uid)
 #endif
 {
 	struct archive_read_disk *a = (struct archive_read_disk *)_a;
@@ -355,13 +355,13 @@
 int
 archive_read_disk_set_gname_lookup(struct archive *_a,
     void *private_data,
-    const char * (*lookup_gname)(void *private, gid_t gid),
+    const char * (*lookup_gname)(void *private, __LA_GID_T gid),
     void (*cleanup_gname)(void *private))
 #else
 int
 archive_read_disk_set_gname_lookup(struct archive *_a,
     void *private_data,
-    const char * (*lookup_gname)(void *private, int64_t gid),
+    const char * (*lookup_gname)(void *private, __LA_INT64_T gid),
     void (*cleanup_gname)(void *private))
 #endif
 {
@@ -382,13 +382,13 @@
 int
 archive_read_disk_set_uname_lookup(struct archive *_a,
     void *private_data,
-    const char * (*lookup_uname)(void *private, uid_t uid),
+    const char * (*lookup_uname)(void *private, __LA_UID_T uid),
     void (*cleanup_uname)(void *private))
 #else
 int
 archive_read_disk_set_uname_lookup(struct archive *_a,
     void *private_data,
-    const char * (*lookup_uname)(void *private, int64_t uid),
+    const char * (*lookup_uname)(void *private, __LA_INT64_T uid),
     void (*cleanup_uname)(void *private))
 #endif
 {
@@ -524,10 +524,10 @@
  */
 #if ARCHIVE_VERSION_NUMBER < 3000000
 static const char *
-trivial_lookup_gname(void *private_data, gid_t gid)
+trivial_lookup_gname(void *private_data, __LA_GID_T gid)
 #else
 static const char *
-trivial_lookup_gname(void *private_data, int64_t gid)
+trivial_lookup_gname(void *private_data, __LA_INT64_T gid)
 #endif
 {
 	(void)private_data; /* UNUSED */
@@ -537,10 +537,10 @@
 
 #if ARCHIVE_VERSION_NUMBER < 3000000
 static const char *
-trivial_lookup_uname(void *private_data, uid_t uid)
+trivial_lookup_uname(void *private_data, __LA_UID_T uid)
 #else
 static const char *
-trivial_lookup_uname(void *private_data, int64_t uid)
+trivial_lookup_uname(void *private_data, __LA_INT64_T uid)
 #endif
 {
 	(void)private_data; /* UNUSED */
@@ -550,12 +550,12 @@
 
 static int
 _archive_read_data_block(struct archive *_a, const void **buff,
-    size_t *size, int64_t *offset)
+    size_t *size, __LA_INT64_T *offset)
 {
 	struct archive_read_disk *a = (struct archive_read_disk *)_a;
 	struct tree *t;
 	int r;
-	ssize_t bytes;
+	__LA_SSIZE_T bytes;
 	size_t buffbytes;
 
 	archive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC, ARCHIVE_STATE_DATA,
@@ -811,7 +811,7 @@
 setup_sparse(struct archive_read_disk *a, struct archive_entry *entry)
 {
 	struct tree *t = a->tree;
-	int64_t length, offset;
+	__LA_INT64_T length, offset;
 	int i;
 
 	t->sparse_count = archive_entry_sparse_reset(entry);
@@ -920,7 +920,7 @@
 }
 
 static int
-update_current_filesystem(struct archive_read_disk *a, int64_t dev)
+update_current_filesystem(struct archive_read_disk *a, __LA_INT64_T dev)
 {
 	struct tree *t = a->tree;
 	int i, fid;
@@ -1057,7 +1057,7 @@
  */
 static void
 tree_push(struct tree *t, const wchar_t *path, int filesystem_id,
-    int64_t dev, int64_t ino)
+    __LA_INT64_T dev, __LA_INT64_T ino)
 {
 	struct tree_entry *te;
 
@@ -1474,7 +1474,7 @@
 {
 	time_t secs;
 	long nsecs;
-	mode_t mode;
+	__LA_MODE_T mode;
 
 	fileTimeToUtc(&bhfi->ftLastAccessTime, &secs, &nsecs);
 	archive_entry_set_atime(entry, secs, nsecs);
@@ -1489,7 +1489,7 @@
 	else
 		archive_entry_set_nlink(entry, bhfi->nNumberOfLinks);
 	archive_entry_set_size(entry,
-	    (((int64_t)bhfi->nFileSizeHigh) << 32)
+	    (((__LA_INT64_T)bhfi->nFileSizeHigh) << 32)
 	    + bhfi->nFileSizeLow);
 	archive_entry_set_uid(entry, 0);
 	archive_entry_set_gid(entry, 0);
@@ -1629,8 +1629,8 @@
     const BY_HANDLE_FILE_INFORMATION *st)
 {
 	struct tree_entry *te;
-	int64_t dev = bhfi_dev(st);
-	int64_t ino = bhfi_ino(st);
+	__LA_INT64_T dev = bhfi_dev(st);
+	__LA_INT64_T ino = bhfi_ino(st);
 
 	for (te = t->current->parent; te != NULL; te = te->parent) {
 		if (te->dev == dev && te->ino == ino)
Index: libarchive/archive_entry_link_resolver.c
===================================================================
--- libarchive/archive_entry_link_resolver.c	(revision 2914)
+++ libarchive/archive_entry_link_resolver.c	(working copy)
@@ -259,8 +259,8 @@
 {
 	struct links_entry	*le;
 	size_t			 hash, bucket;
-	dev_t			 dev;
-	int64_t			 ino;
+	__LA_DEV_T			 dev;
+	__LA_INT64_T			 ino;
 
 	/* Free a held entry. */
 	if (res->spare != NULL) {
Index: libarchive/archive_entry_private.h
===================================================================
--- libarchive/archive_entry_private.h	(revision 2914)
+++ libarchive/archive_entry_private.h	(working copy)
@@ -46,8 +46,8 @@
 struct ae_sparse {
 	struct ae_sparse *next;
 
-	int64_t	 offset;
-	int64_t	 length;
+	__LA_INT64_T	 offset;
+	__LA_INT64_T	 length;
 };
 
 /*
@@ -90,19 +90,19 @@
 	int  stat_valid; /* Set to 0 whenever a field in aest changes. */
 
 	struct aest {
-		int64_t		aest_atime;
-		uint32_t	aest_atime_nsec;
-		int64_t		aest_ctime;
-		uint32_t	aest_ctime_nsec;
-		int64_t		aest_mtime;
-		uint32_t	aest_mtime_nsec;
-		int64_t		aest_birthtime;
-		uint32_t	aest_birthtime_nsec;
-		int64_t		aest_gid;
-		int64_t		aest_ino;
-		uint32_t	aest_nlink;
-		uint64_t	aest_size;
-		int64_t		aest_uid;
+		__LA_INT64_T		aest_atime;
+		__LA_UINT32_T	aest_atime_nsec;
+		__LA_INT64_T		aest_ctime;
+		__LA_UINT32_T	aest_ctime_nsec;
+		__LA_INT64_T		aest_mtime;
+		__LA_UINT32_T	aest_mtime_nsec;
+		__LA_INT64_T		aest_birthtime;
+		__LA_UINT32_T	aest_birthtime_nsec;
+		__LA_INT64_T		aest_gid;
+		__LA_INT64_T		aest_ino;
+		__LA_UINT32_T	aest_nlink;
+		__LA_UINT64_T	aest_size;
+		__LA_INT64_T		aest_uid;
 		/*
 		 * Because converting between device codes and
 		 * major/minor values is platform-specific and
@@ -112,13 +112,13 @@
 		 * conversion is actually required.
 		 */
 		int		aest_dev_is_broken_down;
-		dev_t		aest_dev;
-		dev_t		aest_devmajor;
-		dev_t		aest_devminor;
+		__LA_DEV_T		aest_dev;
+		__LA_DEV_T		aest_devmajor;
+		__LA_DEV_T		aest_devminor;
 		int		aest_rdev_is_broken_down;
-		dev_t		aest_rdev;
-		dev_t		aest_rdevmajor;
-		dev_t		aest_rdevminor;
+		__LA_DEV_T		aest_rdev;
+		__LA_DEV_T		aest_rdevmajor;
+		__LA_DEV_T		aest_rdevminor;
 	} ae_stat;
 
 	int ae_set; /* bitmap of fields that are currently set */
Index: libarchive/archive_read_support_format_ar.c
===================================================================
--- libarchive/archive_read_support_format_ar.c	(revision 2914)
+++ libarchive/archive_read_support_format_ar.c	(working copy)
@@ -50,14 +50,14 @@
 #include "archive_read_private.h"
 
 struct ar {
-	int64_t	 entry_bytes_remaining;
+	__LA_INT64_T	 entry_bytes_remaining;
 	/* unconsumed is purely to track data we've gotten from readahead,
 	 * but haven't yet marked as consumed.  Must be paired with
 	 * entry_bytes_remaining usage/modification.
 	 */
 	size_t   entry_bytes_unconsumed;
-	int64_t	 entry_offset;
-	int64_t	 entry_padding;
+	__LA_INT64_T	 entry_offset;
+	__LA_INT64_T	 entry_padding;
 	char	*strtab;
 	size_t	 strtab_size;
 	char	 read_global_header;
@@ -84,12 +84,12 @@
 static int	archive_read_format_ar_bid(struct archive_read *a);
 static int	archive_read_format_ar_cleanup(struct archive_read *a);
 static int	archive_read_format_ar_read_data(struct archive_read *a,
-		    const void **buff, size_t *size, int64_t *offset);
+		    const void **buff, size_t *size, __LA_INT64_T *offset);
 static int	archive_read_format_ar_skip(struct archive_read *a);
 static int	archive_read_format_ar_read_header(struct archive_read *a,
 		    struct archive_entry *e);
-static uint64_t	ar_atol8(const char *p, unsigned char_cnt);
-static uint64_t	ar_atol10(const char *p, unsigned char_cnt);
+static __LA_UINT64_T	ar_atol8(const char *p, unsigned char_cnt);
+static __LA_UINT64_T	ar_atol10(const char *p, unsigned char_cnt);
 static int	ar_parse_gnu_filename_table(struct archive_read *a);
 static int	ar_parse_common_header(struct ar *ar, struct archive_entry *,
 		    const char *h);
@@ -170,7 +170,7 @@
 	struct ar *ar, const char *h, size_t *unconsumed)
 {
 	char filename[AR_name_size + 1];
-	uint64_t number; /* Used to hold parsed numbers before validation. */
+	__LA_UINT64_T number; /* Used to hold parsed numbers before validation. */
 	size_t bsd_name_length, entry_size;
 	char *p, *st;
 	const void *b;
@@ -339,8 +339,8 @@
 		/* Guard against the filename + trailing NUL
 		 * overflowing a size_t and against the filename size
 		 * being larger than the entire entry. */
-		if (number > (uint64_t)(bsd_name_length + 1)
-		    || (int64_t)bsd_name_length > ar->entry_bytes_remaining) {
+		if (number > (__LA_UINT64_T)(bsd_name_length + 1)
+		    || (__LA_INT64_T)bsd_name_length > ar->entry_bytes_remaining) {
 			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
 			    "Bad input file size");
 			return (ARCHIVE_FATAL);
@@ -447,17 +447,17 @@
 ar_parse_common_header(struct ar *ar, struct archive_entry *entry,
     const char *h)
 {
-	uint64_t n;
+	__LA_UINT64_T n;
 
 	/* Copy remaining header */
 	archive_entry_set_mtime(entry,
 	    (time_t)ar_atol10(h + AR_date_offset, AR_date_size), 0L);
 	archive_entry_set_uid(entry,
-	    (uid_t)ar_atol10(h + AR_uid_offset, AR_uid_size));
+	    (__LA_UID_T)ar_atol10(h + AR_uid_offset, AR_uid_size));
 	archive_entry_set_gid(entry,
-	    (gid_t)ar_atol10(h + AR_gid_offset, AR_gid_size));
+	    (__LA_GID_T)ar_atol10(h + AR_gid_offset, AR_gid_size));
 	archive_entry_set_mode(entry,
-	    (mode_t)ar_atol8(h + AR_mode_offset, AR_mode_size));
+	    (__LA_MODE_T)ar_atol8(h + AR_mode_offset, AR_mode_size));
 	n = ar_atol10(h + AR_size_offset, AR_size_size);
 
 	ar->entry_offset = 0;
@@ -469,9 +469,9 @@
 
 static int
 archive_read_format_ar_read_data(struct archive_read *a,
-    const void **buff, size_t *size, int64_t *offset)
+    const void **buff, size_t *size, __LA_INT64_T *offset)
 {
-	ssize_t bytes_read;
+	__LA_SSIZE_T bytes_read;
 	struct ar *ar;
 
 	ar = (struct ar *)(a->format->data);
@@ -491,7 +491,7 @@
 		if (bytes_read < 0)
 			return (ARCHIVE_FATAL);
 		if (bytes_read > ar->entry_bytes_remaining)
-			bytes_read = (ssize_t)ar->entry_bytes_remaining;
+			bytes_read = (__LA_SSIZE_T)ar->entry_bytes_remaining;
 		*size = bytes_read;
 		ar->entry_bytes_unconsumed = bytes_read;
 		*offset = ar->entry_offset;
@@ -499,7 +499,7 @@
 		ar->entry_bytes_remaining -= bytes_read;
 		return (ARCHIVE_OK);
 	} else {
-		int64_t skipped = __archive_read_consume(a, ar->entry_padding);
+		__LA_INT64_T skipped = __archive_read_consume(a, ar->entry_padding);
 		if (skipped >= 0) {
 			ar->entry_padding -= skipped;
 		}
@@ -520,7 +520,7 @@
 static int
 archive_read_format_ar_skip(struct archive_read *a)
 {
-	int64_t bytes_skipped;
+	__LA_INT64_T bytes_skipped;
 	struct ar* ar;
 
 	ar = (struct ar *)(a->format->data);
@@ -576,10 +576,10 @@
 	return (ARCHIVE_WARN);
 }
 
-static uint64_t
+static __LA_UINT64_T
 ar_atol8(const char *p, unsigned char_cnt)
 {
-	uint64_t l, limit, last_digit_limit;
+	__LA_UINT64_T l, limit, last_digit_limit;
 	unsigned int digit, base;
 
 	base = 8;
@@ -602,10 +602,10 @@
 	return (l);
 }
 
-static uint64_t
+static __LA_UINT64_T
 ar_atol10(const char *p, unsigned char_cnt)
 {
-	uint64_t l, limit, last_digit_limit;
+	__LA_UINT64_T l, limit, last_digit_limit;
 	unsigned int base, digit;
 
 	base = 10;
Index: libarchive/archive_read_support_format_zip.c
===================================================================
--- libarchive/archive_read_support_format_zip.c	(revision 2914)
+++ libarchive/archive_read_support_format_zip.c	(working copy)
@@ -50,13 +50,13 @@
 
 struct zip {
 	/* entry_bytes_remaining is the number of bytes we expect. */
-	int64_t			entry_bytes_remaining;
-	int64_t			entry_offset;
+	__LA_INT64_T			entry_bytes_remaining;
+	__LA_INT64_T			entry_offset;
 	size_t			entry_bytes_unconsumed;
 
 	/* These count the number of bytes actually read for the entry. */
-	int64_t			entry_compressed_bytes_read;
-	int64_t			entry_uncompressed_bytes_read;
+	__LA_INT64_T			entry_compressed_bytes_read;
+	__LA_INT64_T			entry_uncompressed_bytes_read;
 
 	/* Running CRC32 of the decompressed data */
 	unsigned long		entry_crc32;
@@ -69,19 +69,19 @@
 	time_t			mtime;
 	time_t			ctime;
 	time_t			atime;
-	mode_t			mode;
-	uid_t			uid;
-	gid_t			gid;
+	__LA_MODE_T			mode;
+	__LA_UID_T			uid;
+	__LA_GID_T			gid;
 
 	/* Flags to mark progress of decompression. */
 	char			decompress_init;
 	char			end_of_entry;
 
 	unsigned long		crc32;
-	ssize_t			filename_length;
-	ssize_t			extra_length;
-	int64_t			uncompressed_size;
-	int64_t			compressed_size;
+	__LA_SSIZE_T			filename_length;
+	__LA_SSIZE_T			extra_length;
+	__LA_INT64_T			uncompressed_size;
+	__LA_INT64_T			compressed_size;
 
 	unsigned char 		*uncompressed_buffer;
 	size_t 			uncompressed_buffer_size;
@@ -125,15 +125,15 @@
 static int	archive_read_format_zip_bid(struct archive_read *);
 static int	archive_read_format_zip_cleanup(struct archive_read *);
 static int	archive_read_format_zip_read_data(struct archive_read *,
-		    const void **, size_t *, int64_t *);
+		    const void **, size_t *, __LA_INT64_T *);
 static int	archive_read_format_zip_read_data_skip(struct archive_read *a);
 static int	archive_read_format_zip_read_header(struct archive_read *,
 		    struct archive_entry *);
 static int	search_next_signature(struct archive_read *);
 static int	zip_read_data_deflate(struct archive_read *a, const void **buff,
-		    size_t *size, int64_t *offset);
+		    size_t *size, __LA_INT64_T *offset);
 static int	zip_read_data_none(struct archive_read *a, const void **buff,
-		    size_t *size, int64_t *offset);
+		    size_t *size, __LA_INT64_T *offset);
 static int	zip_read_file_header(struct archive_read *a,
 		    struct archive_entry *entry, struct zip *zip);
 static time_t	zip_time(const char *);
@@ -177,7 +177,7 @@
 {
 	const char *p;
 	const void *buff;
-	ssize_t bytes_avail, offset;
+	__LA_SSIZE_T bytes_avail, offset;
 
 	if ((p = __archive_read_ahead(a, 4, NULL)) == NULL)
 		return (-1);
@@ -247,7 +247,7 @@
 	const void *h;
 	const char *p, *q;
 	size_t skip;
-	ssize_t bytes;
+	__LA_SSIZE_T bytes;
 
 	/*
 	 * TODO: We should be able to skip forward by a bunch
@@ -392,8 +392,8 @@
 	const void *h;
 	const char *p, *q;
 	size_t skip;
-	ssize_t bytes;
-	int64_t skipped = 0;
+	__LA_SSIZE_T bytes;
+	__LA_INT64_T skipped = 0;
 
 	for (;;) {
 		h = __archive_read_ahead(a, 4, &bytes);
@@ -536,7 +536,7 @@
 
 static int
 archive_read_format_zip_read_data(struct archive_read *a,
-    const void **buff, size_t *size, int64_t *offset)
+    const void **buff, size_t *size, __LA_INT64_T *offset)
 {
 	int r, reset_buff = 0;
 	struct zip *zip;
@@ -668,10 +668,10 @@
  */
 static int
 zip_read_data_none(struct archive_read *a, const void **buff,
-    size_t *size, int64_t *offset)
+    size_t *size, __LA_INT64_T *offset)
 {
 	struct zip *zip;
-	ssize_t bytes_avail;
+	__LA_SSIZE_T bytes_avail;
 
 	zip = (struct zip *)(a->format->data);
 
@@ -710,10 +710,10 @@
 #ifdef HAVE_ZLIB_H
 static int
 zip_read_data_deflate(struct archive_read *a, const void **buff,
-    size_t *size, int64_t *offset)
+    size_t *size, __LA_INT64_T *offset)
 {
 	struct zip *zip;
-	ssize_t bytes_avail;
+	__LA_SSIZE_T bytes_avail;
 	const void *compressed_buff;
 	int r;
 
@@ -808,7 +808,7 @@
 #else
 static int
 zip_read_data_deflate(struct archive_read *a, const void **buff,
-    size_t *size, int64_t *offset)
+    size_t *size, __LA_INT64_T *offset)
 {
 	*buff = NULL;
 	*size = 0;
@@ -824,7 +824,7 @@
 {
 	struct zip *zip;
 	const void *buff = NULL;
-	int64_t bytes_skipped;
+	__LA_INT64_T bytes_skipped;
 
 	zip = (struct zip *)(a->format->data);
 
@@ -846,7 +846,7 @@
 	 */
 	if (zip->flags & ZIP_LENGTH_AT_END) {
 		size_t size;
-		int64_t offset;
+		__LA_INT64_T offset;
 		int r;
 		do {
 			r = archive_read_format_zip_read_data(a, &buff,
Index: libarchive/archive_read_open_fd.c
===================================================================
--- libarchive/archive_read_open_fd.c	(revision 2914)
+++ libarchive/archive_read_open_fd.c	(working copy)
@@ -58,11 +58,11 @@
 };
 
 static int	file_close(struct archive *, void *);
-static ssize_t	file_read(struct archive *, void *, const void **buff);
+static __LA_SSIZE_T	file_read(struct archive *, void *, const void **buff);
 #if ARCHIVE_VERSION_NUMBER < 3000000
 static off_t	file_skip(struct archive *, void *, off_t request);
 #else
-static int64_t	file_skip(struct archive *, void *, int64_t request);
+static __LA_INT64_T	file_skip(struct archive *, void *, __LA_INT64_T request);
 #endif
 
 int
@@ -108,11 +108,11 @@
 		NULL, file_read, file_skip, file_close));
 }
 
-static ssize_t
+static __LA_SSIZE_T
 file_read(struct archive *a, void *client_data, const void **buff)
 {
 	struct read_fd_data *mine = (struct read_fd_data *)client_data;
-	ssize_t bytes_read;
+	__LA_SSIZE_T bytes_read;
 
 	*buff = mine->buffer;
 	for (;;) {
@@ -130,8 +130,8 @@
 static off_t
 file_skip(struct archive *a, void *client_data, off_t request)
 #else
-static int64_t
-file_skip(struct archive *a, void *client_data, int64_t request)
+static __LA_INT64_T
+file_skip(struct archive *a, void *client_data, __LA_INT64_T request)
 #endif
 {
 	struct read_fd_data *mine = (struct read_fd_data *)client_data;
Index: libarchive/archive_string_sprintf.c
===================================================================
--- libarchive/archive_string_sprintf.c	(revision 2914)
+++ libarchive/archive_string_sprintf.c	(working copy)
@@ -132,7 +132,7 @@
 			switch(long_flag) {
 			case 'j': s = va_arg(ap, intmax_t); break;
 			case 'l': s = va_arg(ap, long); break;
-			case 'z': s = va_arg(ap, ssize_t); break;
+			case 'z': s = va_arg(ap, __LA_SSIZE_T); break;
 			default:  s = va_arg(ap, int); break;
 			}
 		        append_int(as, s, 10);
Index: libarchive/archive_entry_stat.3
===================================================================
--- libarchive/archive_entry_stat.3	(revision 2914)
+++ libarchive/archive_entry_stat.3	(working copy)
@@ -60,58 +60,58 @@
 .Fn archive_entry_stat "struct archive_entry *a"
 .Ft void
 .Fn archive_entry_copy_stat "struct archive_entry *a" "const struct stat *sb"
-.Ft mode_t
+.Ft __LA_MODE_T
 .Fn archive_entry_filetype "struct archive_entry *a"
 .Ft void
 .Fn archive_entry_set_filetype "struct archive_entry *a" "unsigned int type"
-.Ft mode_t
+.Ft __LA_MODE_T
 .Fn archive_entry_mode "struct archive_entry *a"
 .Ft void
-.Fn archive_entry_set_mode "struct archive_entry *a" "mode_t mode"
-.Ft int64_t
+.Fn archive_entry_set_mode "struct archive_entry *a" "__LA_MODE_T mode"
+.Ft __LA_INT64_T
 .Fn archive_entry_size "struct archive_entry *a"
 .Ft int
 .Fn archive_entry_size_is_set "struct archive_entry *a"
 .Ft void
-.Fn archive_entry_set_size "struct archive_entry *a" "int64_t size"
+.Fn archive_entry_set_size "struct archive_entry *a" "__LA_INT64_T size"
 .Ft void
 .Fn archive_entry_unset_size "struct archive_entry *a"
-.Ft dev_t
+.Ft __LA_DEV_T
 .Fn archive_entry_dev "struct archive_entry *a"
 .Ft void
-.Fn archive_entry_set_dev "struct archive_entry *a" "dev_t dev"
-.Ft dev_t
+.Fn archive_entry_set_dev "struct archive_entry *a" "__LA_DEV_T dev"
+.Ft __LA_DEV_T
 .Fn archive_entry_devmajor "struct archive_entry *a"
 .Ft void
-.Fn archive_entry_set_devmajor "struct archive_entry *a" "dev_t major"
-.Ft dev_t
+.Fn archive_entry_set_devmajor "struct archive_entry *a" "__LA_DEV_T major"
+.Ft __LA_DEV_T
 .Fn archive_entry_devminor "struct archive_entry *a"
 .Ft void
-.Fn archive_entry_set_devminor "struct archive_entry *a" "dev_t minor"
+.Fn archive_entry_set_devminor "struct archive_entry *a" "__LA_DEV_T minor"
 .Ft ino_t
 .Fn archive_entry_ino "struct archive_entry *a"
 .Ft void
 .Fn archive_entry_set_ino "struct archive_entry *a" "unsigned long ino"
-.Ft int64_t
+.Ft __LA_INT64_T
 .Fn archive_entry_ino64 "struct archive_entry *a"
 .Ft void
-.Fn archive_entry_set_ino64 "struct archive_entry *a" "int64_t ino"
+.Fn archive_entry_set_ino64 "struct archive_entry *a" "__LA_INT64_T ino"
 .Ft unsigned int
 .Fn archive_entry_nlink "struct archive_entry *a"
 .Ft void
 .Fn archive_entry_set_nlink "struct archive_entry *a" "unsigned int count"
-.Ft dev_t
+.Ft __LA_DEV_T
 .Fn archive_entry_rdev "struct archive_entry *a"
-.Ft dev_t
+.Ft __LA_DEV_T
 .Fn archive_entry_rdevmajor "struct archive_entry *a"
-.Ft dev_t
+.Ft __LA_DEV_T
 .Fn archive_entry_rdevminor "struct archive_entry *a"
 .Ft void
-.Fn archive_entry_set_rdev "struct archive_entry *a" "dev_t dev"
+.Fn archive_entry_set_rdev "struct archive_entry *a" "__LA_DEV_T dev"
 .Ft void
-.Fn archive_entry_set_rdevmajor "struct archive_entry *a" "dev_t major"
+.Fn archive_entry_set_rdevmajor "struct archive_entry *a" "__LA_DEV_T major"
 .Ft void
-.Fn archive_entry_set_rdevminor "struct archive_entry *a" "dev_t minor"
+.Fn archive_entry_set_rdevminor "struct archive_entry *a" "__LA_DEV_T minor"
 .Sh DESCRIPTION
 .Ss Copying to and from Vt struct stat
 The function
Index: libarchive/archive_write_add_filter_bzip2.c
===================================================================
--- libarchive/archive_write_add_filter_bzip2.c	(revision 2914)
+++ libarchive/archive_write_add_filter_bzip2.c	(working copy)
@@ -68,7 +68,7 @@
 struct private_data {
 	int		 compression_level;
 	bz_stream	 stream;
-	int64_t		 total_in;
+	__LA_INT64_T		 total_in;
 	char		*compressed;
 	size_t		 compressed_buffer_size;
 };
Index: libarchive/archive.h
===================================================================
--- libarchive/archive.h	(revision 2914)
+++ libarchive/archive.h	(working copy)
@@ -37,7 +37,7 @@
  */
 #if defined(__BORLANDC__) && __BORLANDC__ >= 0x560
 # define __LA_STDINT_H <stdint.h>
-#elif !defined(__WATCOMC__) && !defined(_MSC_VER) && !defined(__INTERIX) && !defined(__BORLANDC__)
+#elif !defined(__WATCOMC__) && !defined(_MSC_VER) && !defined(__INTERIX) && !defined(__BORLANDC__) && !defined(_SCO_DS)
 # define __LA_STDINT_H <inttypes.h>
 #endif
 
@@ -53,7 +53,11 @@
 /* Get appropriate definitions of standard POSIX-style types. */
 /* These should match the types used in 'struct stat' */
 #if defined(_WIN32) && !defined(__CYGWIN__)
-#define	__LA_INT64_T	__int64
+# define       __LA_INT64_T    __int64
+# define       __LA_UINT64_T   unsigned __int64
+# define       __LA_INT32_T    int
+# define       __LA_UINT32_T   unsigned int
+# define       __LA_UINT16_T   unsigned short
 # if defined(_SSIZE_T_DEFINED)
 #  define	__LA_SSIZE_T	ssize_t
 # elif defined(_WIN64)
@@ -64,16 +68,34 @@
 # if defined(__BORLANDC__)
 #  define	__LA_UID_T	uid_t
 #  define	__LA_GID_T	gid_t
+#  define __LA_MODE_T mode_t
+#  define __LA_DEV_T  dev_t
 # else
 #  define	__LA_UID_T	short
 #  define	__LA_GID_T	short
+#  define __LA_MODE_T unsigned short
+#  define __LA_DEV_T  unsigned int
 # endif
 #else
-#include <unistd.h>  /* ssize_t, uid_t, and gid_t */
-#define	__LA_INT64_T	int64_t
-#define	__LA_SSIZE_T	ssize_t
-#define	__LA_UID_T	uid_t
-#define	__LA_GID_T	gid_t
+# include <unistd.h>  /* ssize_t, uid_t, and gid_t */
+# if defined(_SCO_DS)
+#  define __LA_INT64_T  long long
+#  define __LA_UINT64_T unsigned long long
+#  define __LA_INT32_T  int
+#  define __LA_UINT32_T unsigned int
+#  define __LA_UINT16_T unsigned short
+# else
+#  define __LA_INT64_T  int64_t
+#  define __LA_UINT64_T uint64_t
+#  define __LA_INT32_T  int32_t
+#  define __LA_UINT32_T uint32_t
+#  define __LA_UINT16_T uint16_t
+# endif
+# define __LA_SSIZE_T ssize_t
+# define __LA_UID_T   uid_t
+# define __LA_GID_T   gid_t
+# define __LA_MODE_T  mode_t
+# define __LA_DEV_T   dev_t
 #endif
 
 /*
@@ -220,7 +242,7 @@
 typedef off_t		archive_skip_callback(struct archive *,
 			    void *_client_data, off_t request);
 #else
-/* Libarchive 3.0 uses int64_t here, which is actually guaranteed to be
+/* Libarchive 3.0 uses __LA_INT64_T here, which is actually guaranteed to be
  * 64 bits on every platform. */
 typedef __LA_INT64_T	archive_skip_callback(struct archive *,
 			    void *_client_data, __LA_INT64_T request);
@@ -629,7 +651,7 @@
 __LA_DECL __LA_SSIZE_T	 archive_write_data_block(struct archive *,
 				    const void *, size_t, off_t);
 #else
-/* Libarchive 3.0 uses explicit int64_t to ensure consistent 64-bit support. */
+/* Libarchive 3.0 uses explicit __LA_INT64_T to ensure consistent 64-bit support. */
 __LA_DECL __LA_SSIZE_T	 archive_write_data_block(struct archive *,
 				    const void *, size_t, __LA_INT64_T);
 #endif
@@ -840,14 +862,4 @@
 }
 #endif
 
-/* These are meaningless outside of this header. */
-#undef __LA_DECL
-#undef __LA_GID_T
-#undef __LA_UID_T
-
-/* These need to remain defined because they're used in the
- * callback type definitions.  XXX Fix this.  This is ugly. XXX */
-/* #undef __LA_INT64_T */
-/* #undef __LA_SSIZE_T */
-
 #endif /* !ARCHIVE_H_INCLUDED */
Index: libarchive/archive_virtual.c
===================================================================
--- libarchive/archive_virtual.c	(revision 2914)
+++ libarchive/archive_virtual.c	(working copy)
@@ -48,7 +48,7 @@
 	return ((a->vtable->archive_filter_name)(a, n));
 }
 
-int64_t
+__LA_INT64_T
 archive_filter_bytes(struct archive *a, int n)
 {
 	return ((a->vtable->archive_filter_bytes)(a, n));
@@ -109,18 +109,18 @@
 	return ((a->vtable->archive_write_finish_entry)(a));
 }
 
-ssize_t
+__LA_SSIZE_T
 archive_write_data(struct archive *a, const void *buff, size_t s)
 {
 	return ((a->vtable->archive_write_data)(a, buff, s));
 }
 
 #if ARCHIVE_VERSION_NUMBER < 3000000
-ssize_t
+__LA_SSIZE_T
 archive_write_data_block(struct archive *a, const void *buff, size_t s, off_t o)
 #else
-ssize_t
-archive_write_data_block(struct archive *a, const void *buff, size_t s, int64_t o)
+__LA_SSIZE_T
+archive_write_data_block(struct archive *a, const void *buff, size_t s, __LA_INT64_T o)
 #endif
 {
 	return ((a->vtable->archive_write_data_block)(a, buff, s, o));
@@ -144,7 +144,7 @@
     const void **buff, size_t *s, off_t *o)
 {
 	int r;
-	int64_t o64;
+	__LA_INT64_T o64;
 
 	r = ((a->vtable->archive_read_data_block)(a, buff, s, &o64));
 	*o = (off_t)o64;
@@ -153,7 +153,7 @@
 #else
 int
 archive_read_data_block(struct archive *a,
-    const void **buff, size_t *s, int64_t *o)
+    const void **buff, size_t *s, __LA_INT64_T *o)
 {
 	return ((a->vtable->archive_read_data_block)(a, buff, s, o));
 }
Index: libarchive/archive_windows.c
===================================================================
--- libarchive/archive_windows.c	(revision 2914)
+++ libarchive/archive_windows.c	(working copy)
@@ -83,21 +83,21 @@
 #endif
 
 struct ustat {
-	int64_t		st_atime;
-	uint32_t	st_atime_nsec;
-	int64_t		st_ctime;
-	uint32_t	st_ctime_nsec;
-	int64_t		st_mtime;
-	uint32_t	st_mtime_nsec;
-	gid_t		st_gid;
+	__LA_INT64_T		st_atime;
+	__LA_UINT32_T	st_atime_nsec;
+	__LA_INT64_T		st_ctime;
+	__LA_UINT32_T	st_ctime_nsec;
+	__LA_INT64_T		st_mtime;
+	__LA_UINT32_T	st_mtime_nsec;
+	__LA_GID_T		st_gid;
 	/* 64bits ino */
-	int64_t		st_ino;
-	mode_t		st_mode;
-	uint32_t	st_nlink;
-	uint64_t	st_size;
-	uid_t		st_uid;
-	dev_t		st_dev;
-	dev_t		st_rdev;
+	__LA_INT64_T		st_ino;
+	__LA_MODE_T		st_mode;
+	__LA_UINT32_T	st_nlink;
+	__LA_UINT64_T	st_size;
+	__LA_UID_T		st_uid;
+	__LA_DEV_T		st_dev;
+	__LA_DEV_T		st_rdev;
 };
 
 /* Local replacement for undocumented Windows CRT function. */
@@ -370,7 +370,7 @@
 }
 
 int
-__la_ftruncate(int fd, int64_t length)
+__la_ftruncate(int fd, __LA_INT64_T length)
 {
 	LARGE_INTEGER distance;
 	HANDLE handle;
@@ -470,7 +470,7 @@
 }
 
 int
-__la_chmod(const char *path, mode_t mode)
+__la_chmod(const char *path, __LA_MODE_T mode)
 {
 	wchar_t *ws;
 	DWORD attr;
@@ -566,7 +566,7 @@
 }
 
 int
-__la_mkdir(const char *path, mode_t mode)
+__la_mkdir(const char *path, __LA_MODE_T mode)
 {
 	wchar_t *ws;
 	int r;
@@ -707,7 +707,7 @@
 	return (r);
 }
 
-ssize_t
+__LA_SSIZE_T
 __la_read(int fd, void *buf, size_t nbytes)
 {
 	HANDLE handle;
@@ -739,7 +739,7 @@
 				return (0);
 		}
 	}
-	r = ReadFile(handle, buf, (uint32_t)nbytes,
+	r = ReadFile(handle, buf, (__LA_UINT32_T)nbytes,
 	    &bytes_read, NULL);
 	if (r == 0) {
 		lasterr = GetLastError();
@@ -755,7 +755,7 @@
 			la_dosmaperr(lasterr);
 		return (-1);
 	}
-	return ((ssize_t)bytes_read);
+	return ((__LA_SSIZE_T)bytes_read);
 }
 
 /* Remove directory */
@@ -813,7 +813,7 @@
 	BY_HANDLE_FILE_INFORMATION info;
 	ULARGE_INTEGER ino64;
 	DWORD ftype;
-	mode_t mode;
+	__LA_MODE_T mode;
 	time_t time;
 	long ns;
 
@@ -881,8 +881,8 @@
 	st->st_ctime = time;
 	st->st_ctime_nsec = ns;
 	st->st_size = 
-	    ((int64_t)(info.nFileSizeHigh) * ((int64_t)MAXDWORD + 1))
-		+ (int64_t)(info.nFileSizeLow);
+	    ((__LA_INT64_T)(info.nFileSizeHigh) * ((__LA_INT64_T)MAXDWORD + 1))
+		+ (__LA_INT64_T)(info.nFileSizeLow);
 #ifdef SIMULATE_WIN_STAT
 	st->st_ino = 0;
 	st->st_nlink = 1;
@@ -1031,7 +1031,7 @@
 	return (wpid);
 }
 
-ssize_t
+__LA_SSIZE_T
 __la_write(int fd, const void *buf, size_t nbytes)
 {
 	DWORD bytes_written;
@@ -1044,7 +1044,7 @@
 		errno = EBADF;
 		return (-1);
 	}
-	if (!WriteFile((HANDLE)_get_osfhandle(fd), buf, (uint32_t)nbytes,
+	if (!WriteFile((HANDLE)_get_osfhandle(fd), buf, (__LA_UINT32_T)nbytes,
 	    &bytes_written, NULL)) {
 		DWORD lasterr;
 
Index: libarchive/archive_read_support_format_empty.c
===================================================================
--- libarchive/archive_read_support_format_empty.c	(revision 2914)
+++ libarchive/archive_read_support_format_empty.c	(working copy)
@@ -33,7 +33,7 @@
 
 static int	archive_read_format_empty_bid(struct archive_read *);
 static int	archive_read_format_empty_read_data(struct archive_read *,
-		    const void **, size_t *, int64_t *);
+		    const void **, size_t *, __LA_INT64_T *);
 static int	archive_read_format_empty_read_header(struct archive_read *,
 		    struct archive_entry *);
 int
@@ -62,7 +62,7 @@
 static int
 archive_read_format_empty_bid(struct archive_read *a)
 {
-	ssize_t avail;
+	__LA_SSIZE_T avail;
 
 	(void)__archive_read_ahead(a, 1, &avail);
 	if (avail != 0)
@@ -85,7 +85,7 @@
 
 static int
 archive_read_format_empty_read_data(struct archive_read *a,
-    const void **buff, size_t *size, int64_t *offset)
+    const void **buff, size_t *size, __LA_INT64_T *offset)
 {
 	(void)a; /* UNUSED */
 	(void)buff; /* UNUSED */
Index: libarchive/archive_windows.h
===================================================================
--- libarchive/archive_windows.h	(revision 2914)
+++ libarchive/archive_windows.h	(working copy)
@@ -309,25 +309,25 @@
 
 /* Replacement POSIX function */
 extern int	 __la_chdir(const char *path);
-extern int	 __la_chmod(const char *path, mode_t mode);
+extern int	 __la_chmod(const char *path, __LA_MODE_T mode);
 extern int	 __la_fcntl(int fd, int cmd, int val);
 extern int	 __la_fstat(int fd, struct stat *st);
-extern int	 __la_ftruncate(int fd, int64_t length);
+extern int	 __la_ftruncate(int fd, __LA_INT64_T length);
 extern int	 __la_futimes(int fd, const struct __timeval *times);
 extern int	 __la_link(const char *src, const char *dst);
 extern __int64	 __la_lseek(int fd, __int64 offset, int whence);
 extern int	 __la_lstat(const char *path, struct stat *st);
 extern size_t	 __la_mbstowcs(wchar_t *wcstr, const char *mbstr, size_t nwchars);
-extern int	 __la_mkdir(const char *path, mode_t mode);
+extern int	 __la_mkdir(const char *path, __LA_MODE_T mode);
 extern int	 __la_mkstemp(char *template);
 extern int	 __la_open(const char *path, int flags, ...);
-extern ssize_t	 __la_read(int fd, void *buf, size_t nbytes);
+extern __LA_SSIZE_T	 __la_read(int fd, void *buf, size_t nbytes);
 extern int	 __la_rmdir(const char *path);
 extern int	 __la_stat(const char *path, struct stat *st);
 extern int	 __la_unlink(const char *path);
 extern int	 __la_utimes(const char *name, const struct __timeval *times);
 extern pid_t	 __la_waitpid(pid_t wpid, int *status, int option);
-extern ssize_t	 __la_write(int fd, const void *buf, size_t nbytes);
+extern __LA_SSIZE_T	 __la_write(int fd, const void *buf, size_t nbytes);
 
 #define _stat64i32(path, st)	__la_stat(path, st)
 #define _stat64(path, st)	__la_stat(path, st)
Index: libarchive/archive_acl.c
===================================================================
--- libarchive/archive_acl.c	(revision 2914)
+++ libarchive/archive_acl.c	(working copy)
@@ -404,11 +404,11 @@
 			if (wname != NULL)
 				length += wcslen(wname);
 			else
-				length += sizeof(uid_t) * 3 + 1;
+				length += sizeof(__LA_UID_T) * 3 + 1;
 			length ++; /* colon */
 			length += 3; /* rwx */
 			length += 1; /* colon */
-			length += max(sizeof(uid_t), sizeof(gid_t)) * 3 + 1;
+			length += max(sizeof(__LA_UID_T), sizeof(__LA_GID_T)) * 3 + 1;
 			length ++; /* newline */
 		}
 		ap = ap->next;
Index: libarchive/archive_write_open_memory.c
===================================================================
--- libarchive/archive_write_open_memory.c	(revision 2914)
+++ libarchive/archive_write_open_memory.c	(working copy)
@@ -53,7 +53,7 @@
 
 static int	memory_write_close(struct archive *, void *);
 static int	memory_write_open(struct archive *, void *);
-static ssize_t	memory_write(struct archive *, void *, const void *buff, size_t);
+static __LA_SSIZE_T	memory_write(struct archive *, void *, const void *buff, size_t);
 
 /*
  * Client provides a pointer to a block of memory to receive
@@ -98,7 +98,7 @@
  * In particular, this means the client can follow exactly
  * how much has been written into their buffer at any time.
  */
-static ssize_t
+static __LA_SSIZE_T
 memory_write(struct archive *a, void *client_data, const void *buff, size_t length)
 {
 	struct write_memory_data *mine;
Index: libarchive/archive_write_disk.c
===================================================================
--- libarchive/archive_write_disk.c	(revision 2914)
+++ libarchive/archive_write_disk.c	(working copy)
@@ -129,10 +129,10 @@
 struct fixup_entry {
 	struct fixup_entry	*next;
 	struct archive_acl	 acl;
-	mode_t			 mode;
-	int64_t			 atime;
-	int64_t                  birthtime;
-	int64_t			 mtime;
+	__LA_MODE_T			 mode;
+	__LA_INT64_T			 atime;
+	__LA_INT64_T                  birthtime;
+	__LA_INT64_T			 mtime;
 	unsigned long		 atime_nanos;
 	unsigned long            birthtime_nanos;
 	unsigned long		 mtime_nanos;
@@ -173,25 +173,25 @@
 struct archive_write_disk {
 	struct archive	archive;
 
-	mode_t			 user_umask;
+	__LA_MODE_T			 user_umask;
 	struct fixup_entry	*fixup_list;
 	struct fixup_entry	*current_fixup;
-	int64_t			 user_uid;
-	dev_t			 skip_file_dev;
+	__LA_INT64_T			 user_uid;
+	__LA_DEV_T			 skip_file_dev;
 	ino_t			 skip_file_ino;
 	time_t			 start_time;
 
 #if ARCHIVE_VERSION_NUMBER < 3000000
-	gid_t (*lookup_gid)(void *private, const char *gname, gid_t gid);
+	__LA_GID_T (*lookup_gid)(void *private, const char *gname, __LA_GID_T gid);
 #else
-	int64_t (*lookup_gid)(void *private, const char *gname, int64_t gid);
+	__LA_INT64_T (*lookup_gid)(void *private, const char *gname, __LA_INT64_T gid);
 #endif
 	void  (*cleanup_gid)(void *private);
 	void			*lookup_gid_data;
 #if ARCHIVE_VERSION_NUMBER < 3000000
-	uid_t (*lookup_uid)(void *private, const char *uname, uid_t uid);
+	__LA_UID_T (*lookup_uid)(void *private, const char *uname, __LA_UID_T uid);
 #else
-	int64_t (*lookup_uid)(void *private, const char *uname, int64_t uid);
+	__LA_INT64_T (*lookup_uid)(void *private, const char *uname, __LA_INT64_T uid);
 #endif
 	void  (*cleanup_uid)(void *private);
 	void			*lookup_uid_data;
@@ -222,20 +222,20 @@
 	/* Handle for the file we're restoring. */
 	int			 fd;
 	/* Current offset for writing data to the file. */
-	int64_t			 offset;
+	__LA_INT64_T			 offset;
 	/* Last offset actually written to disk. */
-	int64_t			 fd_offset;
+	__LA_INT64_T			 fd_offset;
 	/* Total bytes actually written to files. */
-	int64_t			 total_bytes_written;
+	__LA_INT64_T			 total_bytes_written;
 	/* Maximum size of file, -1 if unknown. */
-	int64_t			 filesize;
+	__LA_INT64_T			 filesize;
 	/* Dir we were in before this restore; only for deep paths. */
 	int			 restore_pwd;
 	/* Mode we should use for this entry; affected by _PERM and umask. */
-	mode_t			 mode;
+	__LA_MODE_T			 mode;
 	/* UID/GID to use in restoring this entry. */
-	int64_t			 uid;
-	int64_t			 gid;
+	__LA_INT64_T			 uid;
+	__LA_INT64_T			 gid;
 };
 
 /*
@@ -274,7 +274,7 @@
 static int	set_xattrs(struct archive_write_disk *);
 static int	set_fflags(struct archive_write_disk *);
 static int	set_fflags_platform(struct archive_write_disk *, int fd,
-		    const char *name, mode_t mode,
+		    const char *name, __LA_MODE_T mode,
 		    unsigned long fflags_set, unsigned long fflags_clear);
 static int	set_ownership(struct archive_write_disk *);
 static int	set_mode(struct archive_write_disk *, int mode);
@@ -284,13 +284,13 @@
 static int	set_times_from_entry(struct archive_write_disk *);
 static struct fixup_entry *sort_dir_list(struct fixup_entry *p);
 #if ARCHIVE_VERSION_NUMBER < 3000000
-static gid_t	trivial_lookup_gid(void *, const char *, gid_t);
-static uid_t	trivial_lookup_uid(void *, const char *, uid_t);
+static __LA_GID_T	trivial_lookup_gid(void *, const char *, __LA_GID_T);
+static __LA_UID_T	trivial_lookup_uid(void *, const char *, __LA_UID_T);
 #else
-static int64_t	trivial_lookup_gid(void *, const char *, int64_t);
-static int64_t	trivial_lookup_uid(void *, const char *, int64_t);
+static __LA_INT64_T	trivial_lookup_gid(void *, const char *, __LA_INT64_T);
+static __LA_INT64_T	trivial_lookup_uid(void *, const char *, __LA_INT64_T);
 #endif
-static ssize_t	write_data_block(struct archive_write_disk *,
+static __LA_SSIZE_T	write_data_block(struct archive_write_disk *,
 		    const char *, size_t);
 
 static struct archive_vtable *archive_write_disk_vtable(void);
@@ -298,10 +298,10 @@
 static int	_archive_write_disk_close(struct archive *);
 static int	_archive_write_disk_free(struct archive *);
 static int	_archive_write_disk_header(struct archive *, struct archive_entry *);
-static int64_t	_archive_write_disk_filter_bytes(struct archive *, int);
+static __LA_INT64_T	_archive_write_disk_filter_bytes(struct archive *, int);
 static int	_archive_write_disk_finish_entry(struct archive *);
-static ssize_t	_archive_write_disk_data(struct archive *, const void *, size_t);
-static ssize_t	_archive_write_disk_data_block(struct archive *, const void *, size_t, int64_t);
+static __LA_SSIZE_T	_archive_write_disk_data(struct archive *, const void *, size_t);
+static __LA_SSIZE_T	_archive_write_disk_data_block(struct archive *, const void *, size_t, __LA_INT64_T);
 
 static int
 lazy_stat(struct archive_write_disk *a)
@@ -348,7 +348,7 @@
 	return (&av);
 }
 
-static int64_t
+static __LA_INT64_T
 _archive_write_disk_filter_bytes(struct archive *_a, int n)
 {
 	struct archive_write_disk *a = (struct archive_write_disk *)_a;
@@ -605,7 +605,7 @@
 	 * On Windows, A creating sparse file requires a special mark.
 	 */
 	if (a->fd >= 0 && archive_entry_sparse_count(entry) > 0) {
-		int64_t base = 0, offset, length;
+		__LA_INT64_T base = 0, offset, length;
 		int i, cnt = archive_entry_sparse_reset(entry);
 		int sparse = 0;
 
@@ -644,10 +644,10 @@
 
 #if ARCHIVE_VERSION_NUMBER < 3000000
 int
-archive_write_disk_set_skip_file(struct archive *_a, dev_t d, ino_t i)
+archive_write_disk_set_skip_file(struct archive *_a, __LA_DEV_T d, ino_t i)
 #else
 int
-archive_write_disk_set_skip_file(struct archive *_a, int64_t d, int64_t i)
+archive_write_disk_set_skip_file(struct archive *_a, __LA_INT64_T d, __LA_INT64_T i)
 #endif
 {
 	struct archive_write_disk *a = (struct archive_write_disk *)_a;
@@ -658,12 +658,12 @@
 	return (ARCHIVE_OK);
 }
 
-static ssize_t
+static __LA_SSIZE_T
 write_data_block(struct archive_write_disk *a, const char *buff, size_t size)
 {
-	uint64_t start_size = size;
-	ssize_t bytes_written = 0;
-	ssize_t block_size = 0, bytes_to_write;
+	__LA_UINT64_T start_size = size;
+	__LA_SSIZE_T bytes_written = 0;
+	__LA_SSIZE_T block_size = 0, bytes_to_write;
 
 	if (size == 0)
 		return (ARCHIVE_OK);
@@ -688,7 +688,7 @@
 	}
 
 	/* If this write would run beyond the file size, truncate it. */
-	if (a->filesize >= 0 && (int64_t)(a->offset + size) > a->filesize)
+	if (a->filesize >= 0 && (__LA_INT64_T)(a->offset + size) > a->filesize)
 		start_size = size = (size_t)(a->filesize - a->offset);
 
 	/* Write the data. */
@@ -698,7 +698,7 @@
 		} else {
 			/* We're sparsifying the file. */
 			const char *p, *end;
-			int64_t block_end;
+			__LA_INT64_T block_end;
 
 			/* Skip leading zero bytes. */
 			for (p = buff, end = buff + size; p < end; ++p) {
@@ -744,12 +744,12 @@
 	return (start_size - size);
 }
 
-static ssize_t
+static __LA_SSIZE_T
 _archive_write_disk_data_block(struct archive *_a,
-    const void *buff, size_t size, int64_t offset)
+    const void *buff, size_t size, __LA_INT64_T offset)
 {
 	struct archive_write_disk *a = (struct archive_write_disk *)_a;
-	ssize_t r;
+	__LA_SSIZE_T r;
 
 	archive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,
 	    ARCHIVE_STATE_DATA, "archive_write_data_block");
@@ -766,7 +766,7 @@
 	return (ARCHIVE_OK);
 }
 
-static ssize_t
+static __LA_SSIZE_T
 _archive_write_disk_data(struct archive *_a, const void *buff, size_t size)
 {
 	struct archive_write_disk *a = (struct archive_write_disk *)_a;
@@ -939,13 +939,13 @@
 int
 archive_write_disk_set_group_lookup(struct archive *_a,
     void *private_data,
-    gid_t (*lookup_gid)(void *private, const char *gname, gid_t gid),
+    __LA_GID_T (*lookup_gid)(void *private, const char *gname, __LA_GID_T gid),
     void (*cleanup_gid)(void *private))
 #else
 int
 archive_write_disk_set_group_lookup(struct archive *_a,
     void *private_data,
-    int64_t (*lookup_gid)(void *private, const char *gname, int64_t gid),
+    __LA_INT64_T (*lookup_gid)(void *private, const char *gname, __LA_INT64_T gid),
     void (*cleanup_gid)(void *private))
 #endif
 {
@@ -963,13 +963,13 @@
 int
 archive_write_disk_set_user_lookup(struct archive *_a,
     void *private_data,
-    uid_t (*lookup_uid)(void *private, const char *uname, uid_t uid),
+    __LA_UID_T (*lookup_uid)(void *private, const char *uname, __LA_UID_T uid),
     void (*cleanup_uid)(void *private))
 #else
 int
 archive_write_disk_set_user_lookup(struct archive *_a,
     void *private_data,
-    int64_t (*lookup_uid)(void *private, const char *uname, int64_t uid),
+    __LA_INT64_T (*lookup_uid)(void *private, const char *uname, __LA_INT64_T uid),
     void (*cleanup_uid)(void *private))
 #endif
 {
@@ -1234,7 +1234,7 @@
 {
 	/* Create the entry. */
 	const char *linkname;
-	mode_t final_mode, mode;
+	__LA_MODE_T final_mode, mode;
 	int r;
 
 	/* We identify hard/symlinks according to the link names. */
@@ -1829,7 +1829,7 @@
 	struct stat st;
 	struct fixup_entry *le;
 	char *slash, *base;
-	mode_t mode_final, mode;
+	__LA_MODE_T mode_final, mode;
 	int r;
 
 	/* Check for special names and just skip them. */
@@ -2246,7 +2246,7 @@
 	unsigned long	set, clear;
 	int		r;
 	int		critical_flags;
-	mode_t		mode = archive_entry_mode(a->entry);
+	__LA_MODE_T		mode = archive_entry_mode(a->entry);
 
 	/*
 	 * Make 'critical_flags' hold all file flags that can't be
@@ -2315,7 +2315,7 @@
  */
 static int
 set_fflags_platform(struct archive_write_disk *a, int fd, const char *name,
-    mode_t mode, unsigned long set, unsigned long clear)
+    __LA_MODE_T mode, unsigned long set, unsigned long clear)
 {
 	int r;
 
@@ -2367,7 +2367,7 @@
  */
 static int
 set_fflags_platform(struct archive_write_disk *a, int fd, const char *name,
-    mode_t mode, unsigned long set, unsigned long clear)
+    __LA_MODE_T mode, unsigned long set, unsigned long clear)
 {
 	int		 ret;
 	int		 myfd = fd;
@@ -2439,7 +2439,7 @@
  */
 static int
 set_fflags_platform(struct archive_write_disk *a, int fd, const char *name,
-    mode_t mode, unsigned long set, unsigned long clear)
+    __LA_MODE_T mode, unsigned long set, unsigned long clear)
 {
 	(void)a; /* UNUSED */
 	(void)fd; /* UNUSED */
@@ -2475,7 +2475,7 @@
 		 const void *metadata, size_t metadata_size)
 {
 	struct archive_string tmp;
-	ssize_t written;
+	__LA_SSIZE_T written;
 	int fd;
 	int ret = ARCHIVE_OK;
 
@@ -2552,8 +2552,8 @@
 	acl_permset_t	 acl_permset;
 	int		 ret;
 	int		 ae_type, ae_permset, ae_tag, ae_id;
-	uid_t		 ae_uid;
-	gid_t		 ae_gid;
+	__LA_UID_T		 ae_uid;
+	__LA_GID_T		 ae_gid;
 	const char	*ae_name;
 	int		 entries;
 
@@ -2773,11 +2773,11 @@
  * versions ensure that we always have something that works.
  */
 #if ARCHIVE_VERSION_NUMBER < 3000000
-static gid_t
-trivial_lookup_gid(void *private_data, const char *gname, gid_t gid)
+static __LA_GID_T
+trivial_lookup_gid(void *private_data, const char *gname, __LA_GID_T gid)
 #else
-static int64_t
-trivial_lookup_gid(void *private_data, const char *gname, int64_t gid)
+static __LA_INT64_T
+trivial_lookup_gid(void *private_data, const char *gname, __LA_INT64_T gid)
 #endif
 {
 	(void)private_data; /* UNUSED */
@@ -2786,11 +2786,11 @@
 }
 
 #if ARCHIVE_VERSION_NUMBER < 3000000
-static uid_t
-trivial_lookup_uid(void *private_data, const char *uname, uid_t uid)
+static __LA_UID_T
+trivial_lookup_uid(void *private_data, const char *uname, __LA_UID_T uid)
 #else
-static int64_t
-trivial_lookup_uid(void *private_data, const char *uname, int64_t uid)
+static __LA_INT64_T
+trivial_lookup_uid(void *private_data, const char *uname, __LA_INT64_T uid)
 #endif
 {
 	(void)private_data; /* UNUSED */
Index: libarchive/archive_read_disk_posix.c
===================================================================
--- libarchive/archive_read_disk_posix.c	(revision 2914)
+++ libarchive/archive_read_disk_posix.c	(working copy)
@@ -118,8 +118,8 @@
 	struct tree_entry	*parent;
 	struct archive_string	 name;
 	size_t			 dirname_length;
-	int64_t			 dev;
-	int64_t			 ino;
+	__LA_INT64_T			 dev;
+	__LA_INT64_T			 ino;
 	int			 flags;
 	int			 filesystem_id;
 	/* How to return back to the parent of a symlink. */
@@ -127,7 +127,7 @@
 };
 
 struct filesystem {
-	int64_t		dev;
+	__LA_INT64_T		dev;
 	int		synthetic;
 	int		remote;
 #if defined(HAVE_READDIR_R)
@@ -193,8 +193,8 @@
 	int			 descend;
 
 	struct entry_sparse {
-		int64_t		 length;
-		int64_t		 offset;
+		__LA_INT64_T		 length;
+		__LA_INT64_T		 offset;
 	}			*sparse_list, *current_sparse;
 	int			 sparse_count;
 	int			 sparse_list_size;
@@ -228,7 +228,7 @@
 static struct tree *tree_reopen(struct tree *, const char *);
 static void tree_close(struct tree *);
 static void tree_free(struct tree *);
-static void tree_push(struct tree *, const char *, int, int64_t, int64_t);
+static void tree_push(struct tree *, const char *, int, __LA_INT64_T, __LA_INT64_T);
 static int tree_enter_initial_dir(struct tree *);
 static int tree_enter_working_dir(struct tree *);
 static int tree_current_dir_fd(struct tree *);
@@ -297,22 +297,22 @@
 /* "is_dir" is equivalent to S_ISDIR(tree_current_stat()->st_mode) */
 static int tree_current_is_dir(struct tree *);
 static int update_current_filesystem(struct archive_read_disk *a,
-		    int64_t dev);
+		    __LA_INT64_T dev);
 static int setup_current_filesystem(struct archive_read_disk *);
 static int tree_target_is_same_as_parent(struct tree *, const struct stat *);
 
 static int	_archive_read_free(struct archive *);
 static int	_archive_read_close(struct archive *);
 static int	_archive_read_data_block(struct archive *,
-		    const void **, size_t *, int64_t *);
+		    const void **, size_t *, __LA_INT64_T *);
 static int	_archive_read_next_header2(struct archive *,
 		    struct archive_entry *);
 #if ARCHIVE_VERSION_NUMBER < 3000000
-static const char *trivial_lookup_gname(void *, gid_t gid);
-static const char *trivial_lookup_uname(void *, uid_t uid);
+static const char *trivial_lookup_gname(void *, __LA_GID_T gid);
+static const char *trivial_lookup_uname(void *, __LA_UID_T uid);
 #else
-static const char *trivial_lookup_gname(void *, int64_t gid);
-static const char *trivial_lookup_uname(void *, int64_t uid);
+static const char *trivial_lookup_gname(void *, __LA_INT64_T gid);
+static const char *trivial_lookup_uname(void *, __LA_INT64_T uid);
 #endif
 static int	setup_sparse(struct archive_read_disk *, struct archive_entry *);
 
@@ -335,10 +335,10 @@
 
 #if ARCHIVE_VERSION_NUMBER < 3000000
 const char *
-archive_read_disk_gname(struct archive *_a, gid_t gid)
+archive_read_disk_gname(struct archive *_a, __LA_GID_T gid)
 #else
 const char *
-archive_read_disk_gname(struct archive *_a, int64_t gid)
+archive_read_disk_gname(struct archive *_a, __LA_INT64_T gid)
 #endif
 {
 	struct archive_read_disk *a = (struct archive_read_disk *)_a;
@@ -352,10 +352,10 @@
 
 #if ARCHIVE_VERSION_NUMBER < 3000000
 const char *
-archive_read_disk_uname(struct archive *_a, uid_t uid)
+archive_read_disk_uname(struct archive *_a, __LA_UID_T uid)
 #else
 const char *
-archive_read_disk_uname(struct archive *_a, int64_t uid)
+archive_read_disk_uname(struct archive *_a, __LA_INT64_T uid)
 #endif
 {
 	struct archive_read_disk *a = (struct archive_read_disk *)_a;
@@ -371,13 +371,13 @@
 int
 archive_read_disk_set_gname_lookup(struct archive *_a,
     void *private_data,
-    const char * (*lookup_gname)(void *private, gid_t gid),
+    const char * (*lookup_gname)(void *private, __LA_GID_T gid),
     void (*cleanup_gname)(void *private))
 #else
 int
 archive_read_disk_set_gname_lookup(struct archive *_a,
     void *private_data,
-    const char * (*lookup_gname)(void *private, int64_t gid),
+    const char * (*lookup_gname)(void *private, __LA_INT64_T gid),
     void (*cleanup_gname)(void *private))
 #endif
 {
@@ -398,13 +398,13 @@
 int
 archive_read_disk_set_uname_lookup(struct archive *_a,
     void *private_data,
-    const char * (*lookup_uname)(void *private, uid_t uid),
+    const char * (*lookup_uname)(void *private, __LA_UID_T uid),
     void (*cleanup_uname)(void *private))
 #else
 int
 archive_read_disk_set_uname_lookup(struct archive *_a,
     void *private_data,
-    const char * (*lookup_uname)(void *private, int64_t uid),
+    const char * (*lookup_uname)(void *private, __LA_INT64_T uid),
     void (*cleanup_uname)(void *private))
 #endif
 {
@@ -539,10 +539,10 @@
  */
 #if ARCHIVE_VERSION_NUMBER < 3000000
 static const char *
-trivial_lookup_gname(void *private_data, gid_t gid)
+trivial_lookup_gname(void *private_data, __LA_GID_T gid)
 #else
 static const char *
-trivial_lookup_gname(void *private_data, int64_t gid)
+trivial_lookup_gname(void *private_data, __LA_INT64_T gid)
 #endif
 {
 	(void)private_data; /* UNUSED */
@@ -552,10 +552,10 @@
 
 #if ARCHIVE_VERSION_NUMBER < 3000000
 static const char *
-trivial_lookup_uname(void *private_data, uid_t uid)
+trivial_lookup_uname(void *private_data, __LA_UID_T uid)
 #else
 static const char *
-trivial_lookup_uname(void *private_data, int64_t uid)
+trivial_lookup_uname(void *private_data, __LA_INT64_T uid)
 #endif
 {
 	(void)private_data; /* UNUSED */
@@ -612,12 +612,12 @@
 
 static int
 _archive_read_data_block(struct archive *_a, const void **buff,
-    size_t *size, int64_t *offset)
+    size_t *size, __LA_INT64_T *offset)
 {
 	struct archive_read_disk *a = (struct archive_read_disk *)_a;
 	struct tree *t;
 	int r;
-	ssize_t bytes;
+	__LA_SSIZE_T bytes;
 	size_t buffbytes;
 
 	archive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC, ARCHIVE_STATE_DATA,
@@ -896,7 +896,7 @@
 setup_sparse(struct archive_read_disk *a, struct archive_entry *entry)
 {
 	struct tree *t = a->tree;
-	int64_t length, offset;
+	__LA_INT64_T length, offset;
 	int i;
 
 	t->sparse_count = archive_entry_sparse_reset(entry);
@@ -1006,7 +1006,7 @@
 }
 
 static int
-update_current_filesystem(struct archive_read_disk *a, int64_t dev)
+update_current_filesystem(struct archive_read_disk *a, __LA_INT64_T dev)
 {
 	struct tree *t = a->tree;
 	int i, fid;
@@ -1489,7 +1489,7 @@
  */
 static void
 tree_push(struct tree *t, const char *path, int filesystem_id,
-    int64_t dev, int64_t ino)
+    __LA_INT64_T dev, __LA_INT64_T ino)
 {
 	struct tree_entry *te;
 
Index: libarchive/archive_read_support_compression_xz.c
===================================================================
--- libarchive/archive_read_support_compression_xz.c	(revision 2914)
+++ libarchive/archive_read_support_compression_xz.c	(working copy)
@@ -58,15 +58,15 @@
 	lzma_stream	 stream;
 	unsigned char	*out_block;
 	size_t		 out_block_size;
-	int64_t		 total_out;
+	__LA_INT64_T		 total_out;
 	char		 eof; /* True = found end of compressed data. */
 	char		 in_stream;
 
 	/* Following variables are used for lzip only. */
 	char		 lzip_ver;
-	uint32_t	 crc32;
-	int64_t		 member_in;
-	int64_t		 member_out;
+	__LA_UINT32_T	 crc32;
+	__LA_INT64_T		 member_in;
+	__LA_INT64_T		 member_out;
 };
 
 #if LZMA_VERSION_MAJOR >= 5
@@ -78,7 +78,7 @@
 #endif
 
 /* Combined lzip/lzma/xz filter */
-static ssize_t	xz_filter_read(struct archive_read_filter *, const void **);
+static __LA_SSIZE_T	xz_filter_read(struct archive_read_filter *, const void **);
 static int	xz_filter_close(struct archive_read_filter *);
 static int	xz_lzma_bidder_init(struct archive_read_filter *);
 
@@ -88,12 +88,12 @@
 	lzmadec_stream	 stream;
 	unsigned char	*out_block;
 	size_t		 out_block_size;
-	int64_t		 total_out;
+	__LA_INT64_T		 total_out;
 	char		 eof; /* True = found end of compressed data. */
 };
 
 /* Lzma-only filter */
-static ssize_t	lzma_filter_read(struct archive_read_filter *, const void **);
+static __LA_SSIZE_T	lzma_filter_read(struct archive_read_filter *, const void **);
 static int	lzma_filter_close(struct archive_read_filter *);
 #endif
 
@@ -196,7 +196,7 @@
     struct archive_read_filter *filter)
 {
 	const unsigned char *buffer;
-	ssize_t avail;
+	__LA_SSIZE_T avail;
 	int bits_checked;
 
 	(void)self; /* UNUSED */
@@ -248,9 +248,9 @@
     struct archive_read_filter *filter)
 {
 	const unsigned char *buffer;
-	ssize_t avail;
-	uint32_t dicsize;
-	uint64_t uncompressed_size;
+	__LA_SSIZE_T avail;
+	__LA_UINT32_T dicsize;
+	__LA_UINT64_T uncompressed_size;
 	int bits_checked;
 
 	(void)self; /* UNUSED */
@@ -287,7 +287,7 @@
 	 * size is unknown and lzma of XZ Utils always records `-1'
 	 * in this field. */
 	uncompressed_size = archive_le64dec(buffer+5);
-	if (uncompressed_size == (uint64_t)ARCHIVE_LITERAL_LL(-1))
+	if (uncompressed_size == (__LA_UINT64_T)ARCHIVE_LITERAL_LL(-1))
 		bits_checked += 64;
 
 	/* Second through fifth bytes are dictionary size, stored in
@@ -354,7 +354,7 @@
 lzip_has_member(struct archive_read_filter *filter)
 {
 	const unsigned char *buffer;
-	ssize_t avail;
+	__LA_SSIZE_T avail;
 	int bits_checked;
 	int log2dic;
 
@@ -552,8 +552,8 @@
 	const unsigned char *h;
 	lzma_filter filters[2];
 	unsigned char props[5];
-	ssize_t avail_in;
-	uint32_t dicsize;
+	__LA_SSIZE_T avail_in;
+	__LA_UINT32_T dicsize;
 	int log2dic, ret;
 
 	state = (struct private_data *)self->data;
@@ -605,7 +605,7 @@
 {
 	struct private_data *state;
 	const unsigned char *f;
-	ssize_t avail_in;
+	__LA_SSIZE_T avail_in;
 	int tail;
 
 	state = (struct private_data *)self->data;
@@ -631,7 +631,7 @@
 	}
 
 	/* Check the uncompressed size of the current member */
-	if ((uint64_t)state->member_out != archive_le64dec(f + 4)) {
+	if ((__LA_UINT64_T)state->member_out != archive_le64dec(f + 4)) {
 		archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
 		    "Lzip: Uncompressed size error");
 		return (ARCHIVE_FAILED);
@@ -639,7 +639,7 @@
 
 	/* Check the total size of the current member */
 	if (state->lzip_ver == 1 &&
-	    (uint64_t)state->member_in + tail != archive_le64dec(f + 12)) {
+	    (__LA_UINT64_T)state->member_in + tail != archive_le64dec(f + 12)) {
 		archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
 		    "Lzip: Member size error");
 		return (ARCHIVE_FAILED);
@@ -661,12 +661,12 @@
 /*
  * Return the next block of decompressed data.
  */
-static ssize_t
+static __LA_SSIZE_T
 xz_filter_read(struct archive_read_filter *self, const void **p)
 {
 	struct private_data *state;
 	size_t decompressed;
-	ssize_t avail_in;
+	__LA_SSIZE_T avail_in;
 	int ret;
 
 	state = (struct private_data *)self->data;
@@ -768,7 +768,7 @@
 	static const size_t out_block_size = 64 * 1024;
 	void *out_block;
 	struct private_data *state;
-	ssize_t ret, avail_in;
+	__LA_SSIZE_T ret, avail_in;
 
 	self->code = ARCHIVE_COMPRESSION_LZMA;
 	self->name = "lzma";
@@ -834,12 +834,12 @@
 /*
  * Return the next block of decompressed data.
  */
-static ssize_t
+static __LA_SSIZE_T
 lzma_filter_read(struct archive_read_filter *self, const void **p)
 {
 	struct private_data *state;
 	size_t decompressed;
-	ssize_t avail_in, ret;
+	__LA_SSIZE_T avail_in, ret;
 
 	state = (struct private_data *)self->data;
 
Index: libarchive/archive_read.c
===================================================================
--- libarchive/archive_read.c	(revision 2914)
+++ libarchive/archive_read.c	(working copy)
@@ -60,19 +60,19 @@
 static void	free_filters(struct archive_read *);
 static int	close_filters(struct archive_read *);
 static struct archive_vtable *archive_read_vtable(void);
-static int64_t	_archive_filter_bytes(struct archive *, int);
+static __LA_INT64_T	_archive_filter_bytes(struct archive *, int);
 static int	_archive_filter_code(struct archive *, int);
 static const char *_archive_filter_name(struct archive *, int);
 static int  _archive_filter_count(struct archive *);
 static int	_archive_read_close(struct archive *);
 static int	_archive_read_data_block(struct archive *,
-		    const void **, size_t *, int64_t *);
+		    const void **, size_t *, __LA_INT64_T *);
 static int	_archive_read_free(struct archive *);
 static int	_archive_read_next_header(struct archive *,
 		    struct archive_entry **);
 static int	_archive_read_next_header2(struct archive *,
 		    struct archive_entry *);
-static int64_t  advance_file_pointer(struct archive_read_filter *, int64_t);
+static __LA_INT64_T  advance_file_pointer(struct archive_read_filter *, __LA_INT64_T);
 
 static struct archive_vtable *
 archive_read_vtable(void)
@@ -121,10 +121,10 @@
  */
 #if ARCHIVE_VERSION_NUMBER < 3000000
 void
-archive_read_extract_set_skip_file(struct archive *_a, dev_t d, ino_t i)
+archive_read_extract_set_skip_file(struct archive *_a, __LA_DEV_T d, ino_t i)
 #else
 void
-archive_read_extract_set_skip_file(struct archive *_a, int64_t d, int64_t i)
+archive_read_extract_set_skip_file(struct archive *_a, __LA_INT64_T d, __LA_INT64_T i)
 #endif
 {
 	struct archive_read *a = (struct archive_read *)_a;
@@ -263,22 +263,22 @@
 	    client_reader, NULL, client_closer);
 }
 
-static ssize_t
+static __LA_SSIZE_T
 client_read_proxy(struct archive_read_filter *self, const void **buff)
 {
-	ssize_t r;
+	__LA_SSIZE_T r;
 	r = (self->archive->client.reader)(&self->archive->archive,
 	    self->data, buff);
 	return (r);
 }
 
-static int64_t
-client_skip_proxy(struct archive_read_filter *self, int64_t request)
+static __LA_INT64_T
+client_skip_proxy(struct archive_read_filter *self, __LA_INT64_T request)
 {
-	int64_t ask, get, total;
+	__LA_INT64_T ask, get, total;
 	/* Limit our maximum seek request to 1GB on platforms
 	* with 32-bit off_t (such as Windows). */
-	int64_t skip_limit = ((int64_t)1) << (sizeof(off_t) * 8 - 2);
+	__LA_INT64_T skip_limit = ((__LA_INT64_T)1) << (sizeof(off_t) * 8 - 2);
 
 	if (self->archive->client.skipper == NULL)
 		return (0);
@@ -377,7 +377,7 @@
 	int number_bidders, i, bid, best_bid;
 	struct archive_read_filter_bidder *bidder, *best_bidder;
 	struct archive_read_filter *filter;
-	ssize_t avail;
+	__LA_SSIZE_T avail;
 	int r;
 
 	for (;;) {
@@ -572,7 +572,7 @@
  * Return the file offset (within the uncompressed data stream) where
  * the last header started.
  */
-int64_t
+__LA_INT64_T
 archive_read_header_position(struct archive *_a)
 {
 	struct archive_read *a = (struct archive_read *)_a;
@@ -592,7 +592,7 @@
  * DO NOT intermingle calls to this function and archive_read_data_block
  * to read a single entry body.
  */
-ssize_t
+__LA_SSIZE_T
 archive_read_data(struct archive *_a, void *buff, size_t s)
 {
 	struct archive_read *a = (struct archive_read *)_a;
@@ -672,7 +672,7 @@
  * even if an error occurred while reading data.
  */
 int
-archive_read_data_into_buffer(struct archive *a, void *d, ssize_t len)
+archive_read_data_into_buffer(struct archive *a, void *d, __LA_SSIZE_T len)
 {
 
 	archive_read_data(a, d, len);
@@ -693,7 +693,7 @@
 #if ARCHIVE_VERSION_NUMBER < 3000000
 	off_t offset;
 #else
-	int64_t offset;
+	__LA_INT64_T offset;
 #endif
 
 	archive_check_magic(_a, ARCHIVE_READ_MAGIC, ARCHIVE_STATE_DATA,
@@ -725,7 +725,7 @@
  */
 static int
 _archive_read_data_block(struct archive *_a,
-    const void **buff, size_t *size, int64_t *offset)
+    const void **buff, size_t *size, __LA_INT64_T *offset)
 {
 	struct archive_read *a = (struct archive_read *)_a;
 	archive_check_magic(_a, ARCHIVE_READ_MAGIC, ARCHIVE_STATE_DATA,
@@ -902,7 +902,7 @@
 	return f == NULL ? NULL : f->name;
 }
 
-static int64_t
+static __LA_INT64_T
 _archive_filter_bytes(struct archive *_a, int n)
 {
 	struct archive_read_filter *f = get_filter(_a, n);
@@ -920,7 +920,7 @@
     int (*bid)(struct archive_read *),
     int (*options)(struct archive_read *, const char *, const char *),
     int (*read_header)(struct archive_read *, struct archive_entry *),
-    int (*read_data)(struct archive_read *, const void **, size_t *, int64_t *),
+    int (*read_data)(struct archive_read *, const void **, size_t *, __LA_INT64_T *),
     int (*read_data_skip)(struct archive_read *),
     int (*cleanup)(struct archive_read *))
 {
@@ -1034,16 +1034,16 @@
  * __archive_read_consume() below.
  */
 const void *
-__archive_read_ahead(struct archive_read *a, size_t min, ssize_t *avail)
+__archive_read_ahead(struct archive_read *a, size_t min, __LA_SSIZE_T *avail)
 {
 	return (__archive_read_filter_ahead(a->filter, min, avail));
 }
 
 const void *
 __archive_read_filter_ahead(struct archive_read_filter *filter,
-    size_t min, ssize_t *avail)
+    size_t min, __LA_SSIZE_T *avail)
 {
-	ssize_t bytes_read;
+	__LA_SSIZE_T bytes_read;
 	size_t tocopy;
 
 	if (filter->fatal) {
@@ -1202,17 +1202,17 @@
 /*
  * Move the file pointer forward.
  */
-int64_t
-__archive_read_consume(struct archive_read *a, int64_t request)
+__LA_INT64_T
+__archive_read_consume(struct archive_read *a, __LA_INT64_T request)
 {
 	return (__archive_read_filter_consume(a->filter, request));
 }
 
-int64_t
+__LA_INT64_T
 __archive_read_filter_consume(struct archive_read_filter * filter,
-    int64_t request)
+    __LA_INT64_T request)
 {
-	int64_t skipped;
+	__LA_INT64_T skipped;
 
 	if (request == 0)
 		return 0;
@@ -1236,11 +1236,11 @@
  * request if EOF is encountered first.
  * Returns a negative value if there's an I/O error.
  */
-static int64_t
-advance_file_pointer(struct archive_read_filter *filter, int64_t request)
+static __LA_INT64_T
+advance_file_pointer(struct archive_read_filter *filter, __LA_INT64_T request)
 {
-	int64_t bytes_skipped, total_bytes_skipped = 0;
-	ssize_t bytes_read;
+	__LA_INT64_T bytes_skipped, total_bytes_skipped = 0;
+	__LA_SSIZE_T bytes_read;
 	size_t min;
 
 	if (filter->fatal)
@@ -1248,7 +1248,7 @@
 
 	/* Use up the copy buffer first. */
 	if (filter->avail > 0) {
-		min = minimum(request, (int64_t)filter->avail);
+		min = minimum(request, (__LA_INT64_T)filter->avail);
 		filter->next += min;
 		filter->avail -= min;
 		request -= min;
@@ -1258,7 +1258,7 @@
 
 	/* Then use up the client buffer. */
 	if (filter->client_avail > 0) {
-		min = minimum(request, (int64_t)filter->client_avail);
+		min = minimum(request, (__LA_INT64_T)filter->client_avail);
 		filter->client_next += min;
 		filter->client_avail -= min;
 		request -= min;
Index: libarchive/archive_write_set_format_iso9660.c
===================================================================
--- libarchive/archive_write_set_format_iso9660.c	(revision 2914)
+++ libarchive/archive_write_set_format_iso9660.c	(working copy)
@@ -182,9 +182,9 @@
 	 * Used for a Directory Record.
 	 */
 	struct content {
-		int64_t		 offset_of_temp;
-		uint32_t 	 location;
-		int64_t		 size;
+		__LA_INT64_T		 offset_of_temp;
+		__LA_UINT32_T 	 location;
+		__LA_INT64_T		 size;
 		/*
 		 * One extent equals one content.
 		 * If this entry has multi extent, `next' variable points
@@ -205,9 +205,9 @@
 	struct {
 		unsigned char	 header_size;
 		unsigned char	 log2_bs;
-		uint32_t	 uncompressed_size;
+		__LA_UINT32_T	 uncompressed_size;
 		int		 keep_original;
-		int64_t		 original_offset_of_temp;
+		__LA_INT64_T		 original_offset_of_temp;
 	} zisofs;
 };
 
@@ -249,7 +249,7 @@
 		int		 parent;
 		int		 normal;
 	}			 dr_len;
-	uint32_t 		 dir_location;
+	__LA_UINT32_T 		 dir_location;
 	int			 dir_block;
 
 	/*
@@ -692,7 +692,7 @@
 	struct isofile		*cur_file;
 	struct isoent		*cur_dirent;
 	struct archive_string	 cur_dirstr;
-	uint64_t		 bytes_remaining;
+	__LA_UINT64_T		 bytes_remaining;
 	int			 need_multi_extent;
 
 	/* A list of all of struct isofile entries. */
@@ -765,17 +765,17 @@
 		 * the copy of the compressed file.
 		 */
 		int		 temp_fd;
-		int64_t		 offset_of_temp;
-		uint32_t	*block_pointers;
+		__LA_INT64_T		 offset_of_temp;
+		__LA_UINT32_T	*block_pointers;
 		size_t		 block_pointers_allocated;
 		int		 block_pointers_cnt;
 		int		 block_pointers_idx;
-		uint64_t	 total_size;
-		uint64_t	 offset_of_block;
+		__LA_UINT64_T	 total_size;
+		__LA_UINT64_T	 offset_of_block;
 
 		z_stream	 stream;
 		int		 stream_valid;
-		int64_t		 remaining;
+		__LA_INT64_T		 remaining;
 		int		 compression_level;
 #endif
 	} zisofs;
@@ -808,8 +808,8 @@
 #define BOOT_MEDIA_2_88M_DISKETTE	3
 #define BOOT_MEDIA_HARD_DISK		4
 		unsigned char		 system_type;
-		uint16_t		 boot_load_seg;
-		uint16_t		 boot_load_size;
+		__LA_UINT16_T		 boot_load_seg;
+		__LA_UINT16_T		 boot_load_size;
 #define BOOT_LOAD_SIZE		4
 	} el_torito;
 
@@ -888,7 +888,7 @@
 		    const char *, const char *);
 static int	iso9660_write_header(struct archive_write *,
 		    struct archive_entry *);
-static ssize_t	iso9660_write_data(struct archive_write *,
+static __LA_SSIZE_T	iso9660_write_data(struct archive_write *,
 		    const void *, size_t);
 static int	iso9660_finish_entry(struct archive_write *);
 static int	iso9660_close(struct archive_write *);
@@ -899,7 +899,7 @@
 		    const char *);
 static inline int joliet_allowed_char(unsigned char, unsigned char);
 static void	set_str_beutf16(unsigned char *, const char *, size_t,
-		    uint16_t, enum vdc);
+		    __LA_UINT16_T, enum vdc);
 static void	set_str_a_characters_bp(unsigned char *, int, int,
 		    const char *, enum vdc);
 static void	set_str_d_characters_bp(unsigned char *, int, int,
@@ -1282,7 +1282,7 @@
 			return (ARCHIVE_OK);
 		}
 		if (strcmp(key, "boot-load-seg") == 0) {
-			uint32_t seg;
+			__LA_UINT32_T seg;
 
 			iso9660->opt.boot_load_seg = 0;
 			if (value == NULL)
@@ -1309,7 +1309,7 @@
 				}
 				p++;
 			}
-			iso9660->el_torito.boot_load_seg = (uint16_t)seg;
+			iso9660->el_torito.boot_load_seg = (__LA_UINT16_T)seg;
 			iso9660->opt.boot_load_seg = 1;
 			return (ARCHIVE_OK);
 		}
@@ -1319,7 +1319,7 @@
 			iso9660->opt.boot_load_size = r == ARCHIVE_OK;
 			if (r != ARCHIVE_OK)
 				return (ARCHIVE_FATAL);
-			iso9660->el_torito.boot_load_size = (uint16_t)num;
+			iso9660->el_torito.boot_load_size = (__LA_UINT16_T)num;
 			return (ARCHIVE_OK);
 		}
 		if (strcmp(key, "boot-type") == 0) {
@@ -1591,7 +1591,7 @@
 static int
 write_to_temp(struct archive_write *a, int fd, const void *buff, size_t s)
 {
-	ssize_t written;
+	__LA_SSIZE_T written;
 	const unsigned char *b;
 
 	b = (const unsigned char *)buff;
@@ -1608,7 +1608,7 @@
 	return (ARCHIVE_OK);
 }
 
-static ssize_t
+static __LA_SSIZE_T
 write_iso9660_data(struct archive_write *a, const void *buff, size_t s)
 {
 	struct iso9660 *iso9660 = a->format_data;
@@ -1673,11 +1673,11 @@
 	return (s);
 }
 
-static ssize_t
+static __LA_SSIZE_T
 iso9660_write_data(struct archive_write *a, const void *buff, size_t s)
 {
 	struct iso9660 *iso9660 = a->format_data;
-	ssize_t r;
+	__LA_SSIZE_T r;
 
 	if (iso9660->cur_file == NULL)
 		return (0);
@@ -2068,7 +2068,7 @@
 }
 
 static void
-set_str_beutf16(unsigned char *p, const char *s, size_t l, uint16_t uf,
+set_str_beutf16(unsigned char *p, const char *s, size_t l, __LA_UINT16_T uf,
     enum vdc vdc)
 {
 	size_t size, i;
@@ -2084,7 +2084,7 @@
 	if (vdc == VDC_UCS2) {
 		size = mbstobeutf16s(p, l, s, strlen(s));
 	} else {
-		const uint16_t *u16 = (const uint16_t *)s;
+		const __LA_UINT16_T *u16 = (const __LA_UINT16_T *)s;
 
 		size = 0;
 		while (*u16++)
@@ -2242,7 +2242,7 @@
  * ISO9660 Standard 7.2.1
  */
 static inline void
-set_num_721(unsigned char *p, uint16_t value)
+set_num_721(unsigned char *p, __LA_UINT16_T value)
 {
 	archive_le16enc(p, value);
 }
@@ -2252,7 +2252,7 @@
  * ISO9660 Standard 7.2.2
  */
 static inline void
-set_num_722(unsigned char *p, uint16_t value)
+set_num_722(unsigned char *p, __LA_UINT16_T value)
 {
 	archive_be16enc(p, value);
 }
@@ -2262,7 +2262,7 @@
  * ISO9660 Standard 7.2.3
  */
 static void
-set_num_723(unsigned char *p, uint16_t value)
+set_num_723(unsigned char *p, __LA_UINT16_T value)
 {
 	archive_le16enc(p, value);
 	archive_be16enc(p+2, value);
@@ -2273,7 +2273,7 @@
  * ISO9660 Standard 7.3.1
  */
 static inline void
-set_num_731(unsigned char *p, uint32_t value)
+set_num_731(unsigned char *p, __LA_UINT32_T value)
 {
 	archive_le32enc(p, value);
 }
@@ -2283,7 +2283,7 @@
  * ISO9660 Standard 7.3.2
  */
 static inline void
-set_num_732(unsigned char *p, uint32_t value)
+set_num_732(unsigned char *p, __LA_UINT32_T value)
 {
 	archive_be32enc(p, value);
 }
@@ -2293,7 +2293,7 @@
  * ISO9660 Standard 7.3.3
  */
 static inline void
-set_num_733(unsigned char *p, uint32_t value)
+set_num_733(unsigned char *p, __LA_UINT32_T value)
 {
 	archive_le32enc(p, value);
 	archive_be32enc(p+4, value);
@@ -2756,9 +2756,9 @@
 		if (extra_space(&ctl) < length)
 			bp = extra_next_record(&ctl, length);
 		if (bp != NULL) {
-			mode_t mode;
-			uid_t uid;
-			gid_t gid;
+			__LA_MODE_T mode;
+			__LA_UID_T uid;
+			__LA_GID_T gid;
 
 			mode = archive_entry_mode(file->entry);
 			uid = archive_entry_uid(file->entry);
@@ -3158,7 +3158,7 @@
 		 *   "PN" Format:
 		 *               len  ver
 		 *    +----+----+----+----+------------+------------+
-		 *    | 'P'| 'N'| 14 | 01 | dev_t high | dev_t low  |
+		 *    | 'P'| 'N'| 14 | 01 | __LA_DEV_T high | __LA_DEV_T low  |
 		 *    +----+----+----+----+------------+------------+
 		 *    0    1    2    3    4           12           20
 		 */
@@ -3166,13 +3166,13 @@
 		if (extra_space(&ctl) < length)
 			bp = extra_next_record(&ctl, length);
 		if (bp != NULL) {
-			uint64_t dev;
+			__LA_UINT64_T dev;
 
 			bp[1] = 'P';
 			bp[2] = 'N';
 			bp[3] = length;
 			bp[4] = 1;	/* version	*/
-			dev = (uint64_t)archive_entry_rdev(file->entry);
+			dev = (__LA_UINT64_T)archive_entry_rdev(file->entry);
 			set_num_733(bp + 5, dev >> 32);
 			set_num_733(bp + 13, dev & 0xFFFFFFFF);
 			bp += length;
@@ -3574,7 +3574,7 @@
 {
 	struct iso9660 *iso9660;
 	unsigned char *bp;
-	uint16_t volume_set_size = 1;
+	__LA_UINT16_T volume_set_size = 1;
 	char identifier[256];
 	enum VD_type vdt;
 	enum vdc vdc;
@@ -4227,8 +4227,8 @@
 
 		file->cur_content = &(file->content);
 		do {
-			int64_t size;
-			int64_t pad_size;
+			__LA_INT64_T size;
+			__LA_INT64_T pad_size;
 
 			lseek(file->temp_fd,
 			    file->cur_content->offset_of_temp,
@@ -4239,7 +4239,7 @@
 				pad_size = LOGICAL_BLOCK_SIZE - pad_size;
 			while (size) {
 				size_t rsize;
-				ssize_t rs;
+				__LA_SSIZE_T rs;
 				unsigned char *wb;
 
 				wb = wb_buffptr(a);
@@ -4288,7 +4288,7 @@
 			return (r);
 	}
 	if (iso9660->el_torito.boot != NULL) {
-		int64_t size, padsize;
+		__LA_INT64_T size, padsize;
 
 		np = iso9660->el_torito.boot;
 		size = archive_entry_size(np->file->entry);
@@ -4296,7 +4296,7 @@
 		    np->file->content.offset_of_temp, SEEK_SET);
 		while (size) {
 			size_t rsize;
-			ssize_t rs;
+			__LA_SSIZE_T rs;
 			unsigned char *wb;
 
 			wb = wb_buffptr(a);
@@ -5631,7 +5631,7 @@
 static void
 idr_set_num_beutf16(unsigned char *p, int num)
 {
-	static const uint16_t xdig[] = {
+	static const __LA_UINT16_T xdig[] = {
 		0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035,
 		0x0036, 0x0037, 0x0038, 0x0039,
 		0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046,
@@ -6897,7 +6897,7 @@
 make_boot_catalog(struct iso9660 *iso9660, unsigned char *block)
 {
 	unsigned char *p;
-	uint16_t sum, *wp;
+	__LA_UINT16_T sum, *wp;
 
 	memset(block, 0, LOGICAL_BLOCK_SIZE);
 	p = block;
@@ -6921,8 +6921,8 @@
 	p[31] = 0xAA;
 
 	sum = 0;
-	wp = (uint16_t *)block;
-	while (wp < (uint16_t *)&block[32])
+	wp = (__LA_UINT16_T *)block;
+	while (wp < (__LA_UINT16_T *)&block[32])
 		sum += archive_le16dec(wp++);
 	set_num_721(&block[28], (~sum) + 1);
 
@@ -6960,8 +6960,8 @@
 {
 	struct iso9660 *iso9660 = a->format_data;
 	struct isoent *np;
-	int64_t size;
-	uint32_t sum;
+	__LA_INT64_T size;
+	__LA_UINT32_T sum;
 
 	if (iso9660->wbuff_remaining != 0) {
 		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
@@ -6981,7 +6981,7 @@
 	sum = 0;
 	while (size > 0) {
 		size_t rsize;
-		ssize_t i, rs;
+		__LA_SSIZE_T i, rs;
 
 		if (size > sizeof(iso9660->wbuff))
 			rsize = sizeof(iso9660->wbuff);
@@ -7007,7 +7007,7 @@
 	size = fd_boot_image_size(iso9660->el_torito.media_type);
 	if (size == 0)
 		size = archive_entry_size(np->file->entry);
-	set_num_731(iso9660->wbuff+8, (uint32_t)size);
+	set_num_731(iso9660->wbuff+8, (__LA_UINT32_T)size);
 	/* Set the sum of the boot file. */
 	set_num_731(iso9660->wbuff+12, sum);
 	/* Clear reserved bytes. */
@@ -7045,7 +7045,7 @@
 					    MB_PRECOMPOSED | MB_ERR_INVALID_CHARS,
 					    s, len, (LPWSTR)tp, (int)tl);
 					if (count) {
-						uint16_t val = 1;
+						__LA_UINT16_T val = 1;
 
 						count = utf16_size / 2;
 						if (archive_be16dec(&val) != 1) {
@@ -7053,7 +7053,7 @@
 							while (utf16_size > 0) {
 								archive_be16enc(
 								    utf16,
-								    *(uint16_t *)xp);
+								    *(__LA_UINT16_T *)xp);
 								utf16 += 2;
 								xp += 2;
 								utf16_size -= 2;
@@ -7065,10 +7065,10 @@
 				}
 			}
 		} else if (count > 0) {
-			uint16_t val = 1;
+			__LA_UINT16_T val = 1;
 			if (archive_be16dec(&val) != 1) {
 				while (utf16_size > 0) {
-					archive_be16enc(utf16, *(uint16_t *)utf16);
+					archive_be16enc(utf16, *(__LA_UINT16_T *)utf16);
 						utf16 += 2;
 						utf16_size -= 2;
 					}
@@ -7161,7 +7161,7 @@
 		int len;
 		wchar_t wc;
 
-		wc = *(const uint16_t *)utf16;
+		wc = *(const __LA_UINT16_T *)utf16;
 #if HAVE_WCRTOMB
 		len = wcrtomb(mbchars, wc, &ps);
 #else
@@ -7439,13 +7439,13 @@
 	struct isofile *file = iso9660->cur_file;
 	const unsigned char *p, *endp;
 	const unsigned char *magic_buff;
-	uint32_t uncompressed_size;
+	__LA_UINT32_T uncompressed_size;
 	unsigned char header_size;
 	unsigned char log2_bs;
 	size_t ceil, doff;
-	uint32_t bst, bed;
+	__LA_UINT32_T bst, bed;
 	int magic_max;
-	int64_t entry_size;
+	__LA_INT64_T entry_size;
 
 	entry_size = archive_entry_size(file->entry);
 	if (sizeof(iso9660->zisofs.magic_buffer) > entry_size)
@@ -7661,7 +7661,7 @@
 	struct isofile *file = iso9660->cur_file;
 	unsigned char buff[16];
 	size_t s;
-	int64_t tail;
+	__LA_INT64_T tail;
 	int bk1, bk2;
 
 	bk1 = (file->zisofs.uncompressed_size +
Index: libarchive/archive_util.c
===================================================================
--- libarchive/archive_util.c	(revision 2914)
+++ libarchive/archive_util.c	(working copy)
@@ -141,7 +141,7 @@
 /*
  * Return a count of the number of compressed bytes processed.
  */
-int64_t
+__LA_INT64_T
 archive_position_compressed(struct archive *a)
 {
 	return archive_filter_bytes(a, -1);
@@ -150,7 +150,7 @@
 /*
  * Return a count of the number of uncompressed bytes processed.
  */
-int64_t
+__LA_INT64_T
 archive_position_uncompressed(struct archive *a)
 {
 	return archive_filter_bytes(a, 0);
Index: libarchive/archive_read_support_format_iso9660.c
===================================================================
--- libarchive/archive_read_support_format_iso9660.c	(revision 2914)
+++ libarchive/archive_read_support_format_iso9660.c	(working copy)
@@ -223,13 +223,13 @@
 	/* Set 1 if this file compressed by paged zlib */
 	int		 pz;
 	int		 pz_log2_bs; /* Log2 of block size */
-	uint64_t	 pz_uncompressed_size;
+	__LA_UINT64_T	 pz_uncompressed_size;
 
 	int		 initialized;
 	unsigned char	*uncompressed_buffer;
 	size_t		 uncompressed_buffer_size;
 
-	uint32_t	 pz_offset;
+	__LA_UINT32_T	 pz_offset;
 	unsigned char	 header[16];
 	size_t		 header_avail;
 	int		 header_passed;
@@ -238,7 +238,7 @@
 	size_t		 block_pointers_size;
 	size_t		 block_pointers_avail;
 	size_t		 block_off;
-	uint32_t	 block_avail;
+	__LA_UINT32_T	 block_avail;
 
 	z_stream	 stream;
 	int		 stream_valid;
@@ -251,8 +251,8 @@
 #endif
 
 struct content {
-	uint64_t	 offset;/* Offset on disk.		*/
-	uint64_t	 size;	/* File size in bytes.		*/
+	__LA_UINT64_T	 offset;/* Offset on disk.		*/
+	__LA_UINT64_T	 size;	/* File size in bytes.		*/
 	struct content	*next;
 };
 
@@ -262,23 +262,23 @@
 	struct file_info	*parent;
 	struct file_info	*next;
 	int		 subdirs;
-	uint64_t	 key;		/* Heap Key.			*/
-	uint64_t	 offset;	/* Offset on disk.		*/
-	uint64_t	 size;		/* File size in bytes.		*/
-	uint32_t	 ce_offset;	/* Offset of CE.		*/
-	uint32_t	 ce_size;	/* Size of CE.			*/
+	__LA_UINT64_T	 key;		/* Heap Key.			*/
+	__LA_UINT64_T	 offset;	/* Offset on disk.		*/
+	__LA_UINT64_T	 size;		/* File size in bytes.		*/
+	__LA_UINT32_T	 ce_offset;	/* Offset of CE.		*/
+	__LA_UINT32_T	 ce_size;	/* Size of CE.			*/
 	char		 re;		/* Having RRIP "RE" extension.	*/
-	uint64_t	 cl_offset;	/* Having RRIP "CL" extension.	*/
+	__LA_UINT64_T	 cl_offset;	/* Having RRIP "CL" extension.	*/
 	int		 birthtime_is_set;
 	time_t		 birthtime;	/* File created time.		*/
 	time_t		 mtime;		/* File last modified time.	*/
 	time_t		 atime;		/* File last accessed time.	*/
 	time_t		 ctime;		/* File attribute change time.	*/
-	uint64_t	 rdev;		/* Device number.		*/
-	mode_t		 mode;
-	uid_t		 uid;
-	gid_t		 gid;
-	int64_t		 number;
+	__LA_UINT64_T	 rdev;		/* Device number.		*/
+	__LA_MODE_T		 mode;
+	__LA_UID_T		 uid;
+	__LA_GID_T		 gid;
+	__LA_INT64_T		 number;
 	int		 nlinks;
 	struct archive_string name; /* Pathname */
 	char		 name_continues; /* Non-zero if name continues */
@@ -287,7 +287,7 @@
 	/* Set 1 if this file compressed by paged zlib(zisofs) */
 	int		 pz;
 	int		 pz_log2_bs; /* Log2 of block size */
-	uint64_t	 pz_uncompressed_size;
+	__LA_UINT64_T	 pz_uncompressed_size;
 	/* Set 1 if this file is multi extent. */
 	int		 multi_extent;
 	struct {
@@ -321,14 +321,14 @@
 	struct heap_queue		 cl_files;
 	struct read_ce_queue {
 		struct read_ce_req {
-			uint64_t	 offset;/* Offset of CE on disk. */
+			__LA_UINT64_T	 offset;/* Offset of CE on disk. */
 			struct file_info *file;
 		}		*reqs;
 		int		 cnt;
 		int		 allocated;
 	}	read_ce_req;
 
-	int64_t		previous_number;
+	__LA_INT64_T		previous_number;
 	struct archive_string previous_pathname;
 
 	struct file_info		*use_files;
@@ -339,18 +339,18 @@
 		int			 count;
 	}	cache_files;
 
-	uint64_t current_position;
-	ssize_t	logical_block_size;
-	uint64_t volume_size; /* Total size of volume in bytes. */
-	int32_t  volume_block;/* Total size of volume in logical blocks. */
+	__LA_UINT64_T current_position;
+	__LA_SSIZE_T	logical_block_size;
+	__LA_UINT64_T volume_size; /* Total size of volume in bytes. */
+	__LA_INT32_T  volume_block;/* Total size of volume in logical blocks. */
 
 	struct vd {
 		int		location;	/* Location of Extent.	*/
-		uint32_t	size;
+		__LA_UINT32_T	size;
 	} primary, joliet;
 
-	int64_t	entry_sparse_offset;
-	int64_t	entry_bytes_remaining;
+	__LA_INT64_T	entry_sparse_offset;
+	__LA_INT64_T	entry_bytes_remaining;
 	size_t  entry_bytes_unconsumed;
 	struct zisofs	 entry_zisofs;
 	struct content	*entry_content;
@@ -361,7 +361,7 @@
 		    const char *, const char *);
 static int	archive_read_format_iso9660_cleanup(struct archive_read *);
 static int	archive_read_format_iso9660_read_data(struct archive_read *,
-		    const void **, size_t *, int64_t *);
+		    const void **, size_t *, __LA_INT64_T *);
 static int	archive_read_format_iso9660_read_data_skip(struct archive_read *);
 static int	archive_read_format_iso9660_read_header(struct archive_read *,
 		    struct archive_entry *);
@@ -389,7 +389,7 @@
 static int	parse_rockridge(struct archive_read *a,
 		    struct file_info *file, const unsigned char *start,
 		    const unsigned char *end);
-static int	register_CE(struct archive_read *a, int32_t location,
+static int	register_CE(struct archive_read *a, __LA_INT32_T location,
 		    struct file_info *file);
 static int	read_CE(struct archive_read *a, struct iso9660 *iso9660);
 static void	parse_rockridge_NM1(struct file_info *,
@@ -409,7 +409,7 @@
 		    struct file_info *file);
 static inline struct file_info *cache_get_entry(struct iso9660 *iso9660);
 static void	heap_add_entry(struct heap_queue *heap,
-		    struct file_info *file, uint64_t key);
+		    struct file_info *file, __LA_UINT64_T key);
 static struct file_info *heap_get_entry(struct heap_queue *heap);
 
 #define add_entry(iso9660, file)	\
@@ -464,7 +464,7 @@
 archive_read_format_iso9660_bid(struct archive_read *a)
 {
 	struct iso9660 *iso9660;
-	ssize_t bytes_read;
+	__LA_SSIZE_T bytes_read;
 	const void *h;
 	const unsigned char *p;
 	int seenTerminator;
@@ -578,7 +578,7 @@
 static int
 isVolumePartition(struct iso9660 *iso9660, const unsigned char *h)
 {
-	int32_t location;
+	__LA_INT32_T location;
 
 	/* Type of the Volume Partition Descriptor must be 3. */
 	if (h[0] != 3)
@@ -595,7 +595,7 @@
 	if (location <= SYSTEM_AREA_BLOCK ||
 	    location >= iso9660->volume_block)
 		return (0);
-	if ((uint32_t)location != archive_be32dec(h + 76))
+	if ((__LA_UINT32_T)location != archive_be32dec(h + 76))
 		return (0);
 
 	return (1);
@@ -628,8 +628,8 @@
 isJolietSVD(struct iso9660 *iso9660, const unsigned char *h)
 {
 	const unsigned char *p;
-	ssize_t logical_block_size;
-	int32_t volume_block;
+	__LA_SSIZE_T logical_block_size;
+	__LA_INT32_T volume_block;
 
 	/* Check if current sector is a kind of Supplementary Volume
 	 * Descriptor. */
@@ -664,7 +664,7 @@
 
 	iso9660->logical_block_size = logical_block_size;
 	iso9660->volume_block = volume_block;
-	iso9660->volume_size = logical_block_size * (uint64_t)volume_block;
+	iso9660->volume_size = logical_block_size * (__LA_UINT64_T)volume_block;
 	/* Read Root Directory Record in Volume Descriptor. */
 	p = h + SVD_root_directory_record_offset;
 	iso9660->joliet.location = archive_le32dec(p + DR_extent_offset);
@@ -677,9 +677,9 @@
 isSVD(struct iso9660 *iso9660, const unsigned char *h)
 {
 	const unsigned char *p;
-	ssize_t logical_block_size;
-	int32_t volume_block;
-	int32_t location;
+	__LA_SSIZE_T logical_block_size;
+	__LA_INT32_T volume_block;
+	__LA_INT32_T location;
 	int i;
 
 	(void)iso9660; /* UNUSED */
@@ -740,9 +740,9 @@
 isEVD(struct iso9660 *iso9660, const unsigned char *h)
 {
 	const unsigned char *p;
-	ssize_t logical_block_size;
-	int32_t volume_block;
-	int32_t location;
+	__LA_SSIZE_T logical_block_size;
+	__LA_INT32_T volume_block;
+	__LA_INT32_T location;
 	int i;
 
 	(void)iso9660; /* UNUSED */
@@ -823,9 +823,9 @@
 isPVD(struct iso9660 *iso9660, const unsigned char *h)
 {
 	const unsigned char *p;
-	ssize_t logical_block_size;
-	int32_t volume_block;
-	int32_t location;
+	__LA_SSIZE_T logical_block_size;
+	__LA_INT32_T volume_block;
+	__LA_INT32_T location;
 	int i;
 
 	/* Type of the Primary Volume Descriptor must be 1. */
@@ -904,7 +904,7 @@
 	if (!iso9660->primary.location) {
 		iso9660->logical_block_size = logical_block_size;
 		iso9660->volume_block = volume_block;
-		iso9660->volume_size = logical_block_size * (uint64_t)volume_block;
+		iso9660->volume_size = logical_block_size * (__LA_UINT64_T)volume_block;
 		iso9660->primary.location = archive_le32dec(p + DR_extent_offset);
 		iso9660->primary.size = archive_le32dec(p + DR_size_offset);
 	}
@@ -936,7 +936,7 @@
 		return (ARCHIVE_WARN);
 	}
 	if (iso9660->current_position < parent->offset) {
-		int64_t skipsize;
+		__LA_INT64_T skipsize;
 
 		skipsize = parent->offset - iso9660->current_position;
 		skipsize = __archive_read_consume(a, skipsize);
@@ -1137,7 +1137,7 @@
 	}
 
 	if (iso9660->current_position == 0) {
-		int64_t skipsize;
+		__LA_INT64_T skipsize;
 		struct vd *vd;
 		const void *block;
 		char seenJoliet;
@@ -1252,7 +1252,7 @@
 	archive_entry_set_ctime(entry, file->ctime, 0);
 	archive_entry_set_atime(entry, file->atime, 0);
 	/* N.B.: Rock Ridge supports 64-bit device numbers. */
-	archive_entry_set_rdev(entry, (dev_t)file->rdev);
+	archive_entry_set_rdev(entry, (__LA_DEV_T)file->rdev);
 	archive_entry_set_size(entry, iso9660->entry_bytes_remaining);
 	archive_string_empty(&iso9660->pathname);
 	archive_entry_set_pathname(entry,
@@ -1356,13 +1356,13 @@
 
 static int
 zisofs_read_data(struct archive_read *a,
-    const void **buff, size_t *size, int64_t *offset)
+    const void **buff, size_t *size, __LA_INT64_T *offset)
 {
 	struct iso9660 *iso9660;
 	struct zisofs  *zisofs;
 	const unsigned char *p;
 	size_t avail;
-	ssize_t bytes_read;
+	__LA_SSIZE_T bytes_read;
 	size_t uncompressed_size;
 	int r;
 
@@ -1485,7 +1485,7 @@
 	 * Get block offsets from block pointers.
 	 */
 	if (zisofs->block_avail == 0) {
-		uint32_t bst, bed;
+		__LA_UINT32_T bst, bed;
 
 		if (zisofs->block_off + 4 >= zisofs->block_pointers_size) {
 			/* There isn't a pair of offsets. */
@@ -1574,7 +1574,7 @@
 
 static int
 zisofs_read_data(struct archive_read *a,
-    const void **buff, size_t *size, int64_t *offset)
+    const void **buff, size_t *size, __LA_INT64_T *offset)
 {
 
 	(void)buff;/* UNUSED */
@@ -1589,9 +1589,9 @@
 
 static int
 archive_read_format_iso9660_read_data(struct archive_read *a,
-    const void **buff, size_t *size, int64_t *offset)
+    const void **buff, size_t *size, __LA_INT64_T *offset)
 {
-	ssize_t bytes_read;
+	__LA_SSIZE_T bytes_read;
 	struct iso9660 *iso9660;
 
 	iso9660 = (struct iso9660 *)(a->format->data);
@@ -1612,7 +1612,7 @@
 		}
 		/* Seek forward to the start of the entry. */
 		if (iso9660->current_position < iso9660->entry_content->offset) {
-			int64_t step;
+			__LA_INT64_T step;
 
 			step = iso9660->entry_content->offset -
 			    iso9660->current_position;
@@ -1702,8 +1702,8 @@
 	const unsigned char *rr_start, *rr_end;
 	const unsigned char *p;
 	size_t dr_len;
-	uint64_t fsize;
-	int32_t location;
+	__LA_UINT64_T fsize;
+	__LA_INT32_T location;
 	int flags;
 
 	iso9660 = (struct iso9660 *)(a->format->data);
@@ -1747,7 +1747,7 @@
 	}
 	memset(file, 0, sizeof(*file));
 	file->parent = parent;
-	file->offset = iso9660->logical_block_size * (uint64_t)location;
+	file->offset = iso9660->logical_block_size * (__LA_UINT64_T)location;
 	file->size = fsize;
 	file->mtime = isodate7(isodirrec + DR_date_offset);
 	file->ctime = file->atime = file->mtime;
@@ -1840,7 +1840,7 @@
 		 */
 		file->number = -1;
 	else
-		file->number = (int64_t)(uint32_t)location;
+		file->number = (__LA_INT64_T)(__LA_UINT32_T)location;
 
 	/* Rockridge extensions overwrite information from above. */
 	if (iso9660->opt_support_rockridge) {
@@ -1952,7 +1952,7 @@
 					 *   8 byte offset w/in above sector
 					 *   8 byte length of continuation
 					 */
-					int32_t location =
+					__LA_INT32_T location =
 					    archive_le32dec(data);
 					file->ce_offset =
 					    archive_le32dec(data+8);
@@ -1966,9 +1966,9 @@
 			}
 			if (p[0] == 'C' && p[1] == 'L') {
 				if (version == 1 && data_length == 8) {
-					file->cl_offset = (uint64_t)
+					file->cl_offset = (__LA_UINT64_T)
 					    iso9660->logical_block_size *
-					    (uint64_t)archive_le32dec(data);
+					    (__LA_UINT64_T)archive_le32dec(data);
 					iso9660->seenRockridge = 1;
 				}
 				break;
@@ -2103,21 +2103,21 @@
 }
 
 static int
-register_CE(struct archive_read *a, int32_t location,
+register_CE(struct archive_read *a, __LA_INT32_T location,
     struct file_info *file)
 {
 	struct iso9660 *iso9660;
 	struct read_ce_queue *heap;
 	struct read_ce_req *p;
-	uint64_t offset, parent_offset;
+	__LA_UINT64_T offset, parent_offset;
 	int hole, parent;
 
 	iso9660 = (struct iso9660 *)(a->format->data);
-	offset = ((uint64_t)location) * (uint64_t)iso9660->logical_block_size;
+	offset = ((__LA_UINT64_T)location) * (__LA_UINT64_T)iso9660->logical_block_size;
 	if (((file->mode & AE_IFMT) == AE_IFREG &&
 	    offset >= file->offset) ||
 	    offset < iso9660->current_position ||
-	    (((uint64_t)file->ce_offset) + file->ce_size)
+	    (((__LA_UINT64_T)file->ce_offset) + file->ce_size)
 	      > iso9660->logical_block_size ||
 	    offset + file->ce_offset + file->ce_size
 		  > iso9660->volume_size) {
@@ -2173,7 +2173,7 @@
 static void
 next_CE(struct read_ce_queue *heap)
 {
-	uint64_t a_offset, b_offset, c_offset;
+	__LA_UINT64_T a_offset, b_offset, c_offset;
 	int a, b, c;
 	struct read_ce_req tmp;
 
@@ -2528,7 +2528,7 @@
 
 	/* Seek forward to the start of the entry. */
 	if (iso9660->current_position < file->offset) {
-		int64_t step;
+		__LA_INT64_T step;
 
 		step = file->offset - iso9660->current_position;
 		step = __archive_read_consume(a, step);
@@ -2550,7 +2550,7 @@
 		struct file_info	*first;
 		struct file_info	**last;
 	}	empty_files;
-	int64_t number;
+	__LA_INT64_T number;
 	int count;
 
 	file = cache_get_entry(iso9660);
@@ -2685,9 +2685,9 @@
 }
 
 static void
-heap_add_entry(struct heap_queue *heap, struct file_info *file, uint64_t key)
+heap_add_entry(struct heap_queue *heap, struct file_info *file, __LA_UINT64_T key)
 {
-	uint64_t file_key, parent_key;
+	__LA_UINT64_T file_key, parent_key;
 	int hole, parent;
 
 	/* Expand our pending files list as necessary. */
@@ -2735,7 +2735,7 @@
 static struct file_info *
 heap_get_entry(struct heap_queue *heap)
 {
-	uint64_t a_key, b_key, c_key;
+	__LA_UINT64_T a_key, b_key, c_key;
 	int a, b, c;
 	struct file_info *r, *tmp;
 
Index: libarchive/archive_write_add_filter_compress.c
===================================================================
--- libarchive/archive_write_add_filter_compress.c	(revision 2914)
+++ libarchive/archive_write_add_filter_compress.c	(working copy)
@@ -88,7 +88,7 @@
 #define	CLEAR	256		/* Table clear output code. */
 
 struct private_data {
-	int64_t in_count, out_count, checkpoint;
+	__LA_INT64_T in_count, out_count, checkpoint;
 
 	int code_len;			/* Number of bits/code. */
 	int cur_maxcode;		/* Maximum code, given n_bits. */
Index: libarchive/archive_entry_copy_bhfi.c
===================================================================
--- libarchive/archive_entry_copy_bhfi.c	(revision 2914)
+++ libarchive/archive_entry_copy_bhfi.c	(working copy)
@@ -64,10 +64,10 @@
 	fileTimeToUtc(&bhfi->ftCreationTime, &secs, &nsecs);
 	archive_entry_set_birthtime(entry, secs, nsecs);
 	archive_entry_set_dev(entry, bhfi->dwVolumeSerialNumber);
-	archive_entry_set_ino64(entry, (((int64_t)bhfi->nFileIndexHigh) << 32)
+	archive_entry_set_ino64(entry, (((__LA_INT64_T)bhfi->nFileIndexHigh) << 32)
 		+ bhfi->nFileIndexLow);
 	archive_entry_set_nlink(entry, bhfi->nNumberOfLinks);
-	archive_entry_set_size(entry, (((int64_t)bhfi->nFileSizeHigh) << 32)
+	archive_entry_set_size(entry, (((__LA_INT64_T)bhfi->nFileSizeHigh) << 32)
 		+ bhfi->nFileSizeLow);
 //	archive_entry_set_mode(entry, st->st_mode);
 }
Index: libarchive/archive_read_disk_private.h
===================================================================
--- libarchive/archive_read_disk_private.h	(revision 2914)
+++ libarchive/archive_read_disk_private.h	(working copy)
@@ -57,22 +57,22 @@
 
 	int		 entry_fd;
 	int		 entry_eof;
-	int64_t		 entry_remaining_bytes;
-	int64_t		 entry_total;
+	__LA_INT64_T		 entry_remaining_bytes;
+	__LA_INT64_T		 entry_total;
 	unsigned char	*entry_buff;
 	size_t		 entry_buff_size;
 
 #if ARCHIVE_VERSION_NUMBER < 3000000
-	const char * (*lookup_gname)(void *private, gid_t gid);
+	const char * (*lookup_gname)(void *private, __LA_GID_T gid);
 #else
-	const char * (*lookup_gname)(void *private, int64_t gid);
+	const char * (*lookup_gname)(void *private, __LA_INT64_T gid);
 #endif
 	void	(*cleanup_gname)(void *private);
 	void	 *lookup_gname_data;
 #if ARCHIVE_VERSION_NUMBER < 3000000
-	const char * (*lookup_uname)(void *private, uid_t uid);
+	const char * (*lookup_uname)(void *private, __LA_UID_T uid);
 #else
-	const char * (*lookup_uname)(void *private, int64_t uid);
+	const char * (*lookup_uname)(void *private, __LA_INT64_T uid);
 #endif
 	void	(*cleanup_uname)(void *private);
 	void	 *lookup_uname_data;
Index: libarchive/archive_entry_perms.3
===================================================================
--- libarchive/archive_entry_perms.3	(revision 2914)
+++ libarchive/archive_entry_perms.3	(working copy)
@@ -54,18 +54,18 @@
 .Nd functions for manipulating ownership and permissions in archive entry descriptions
 .Sh SYNOPSIS
 .In archive_entry.h
-.Ft gid_t
+.Ft __LA_GID_T
 .Fn archive_entry_gid "struct archive_entry *a"
 .Ft void
-.Fn archive_entry_set_gid "struct archive_entry *a" "gid_t gid"
-.Ft uid_t
+.Fn archive_entry_set_gid "struct archive_entry *a" "__LA_GID_T gid"
+.Ft __LA_UID_T
 .Fn archive_entry_uid "struct archive_entry *a"
 .Ft void
-.Fn archive_entry_set_uid "struct archive_entry *a" "uid_t uid"
-.Ft mode_t
+.Fn archive_entry_set_uid "struct archive_entry *a" "__LA_UID_T uid"
+.Ft __LA_MODE_T
 .Fn archive_entry_perm "struct archive_entry *a"
 .Ft void
-.Fn archive_entry_set_perm "struct archive_entry *a" "mode_t mode"
+.Fn archive_entry_set_perm "struct archive_entry *a" "__LA_MODE_T mode"
 .Ft const char *
 .Fn archive_entry_strmode "struct archive_entry *a"
 .Ft const char *
@@ -199,9 +199,9 @@
 .Xr archive_write_disk 3
 .Sh BUGS
 The platform types
-.Vt uid_t
+.Vt __LA_UID_T
 and
-.Vt gid_t
+.Vt __LA_GID_T
 are often 16 or 32 bit wide.
 In this case it is possible that the ids can not be correctly restored
 from archives and get truncated.
Index: libarchive/archive_write_set_format_cpio.c
===================================================================
--- libarchive/archive_write_set_format_cpio.c	(revision 2914)
+++ libarchive/archive_write_set_format_cpio.c	(working copy)
@@ -42,23 +42,23 @@
 #include "archive_private.h"
 #include "archive_write_private.h"
 
-static ssize_t	archive_write_cpio_data(struct archive_write *,
+static __LA_SSIZE_T	archive_write_cpio_data(struct archive_write *,
 		    const void *buff, size_t s);
 static int	archive_write_cpio_close(struct archive_write *);
 static int	archive_write_cpio_free(struct archive_write *);
 static int	archive_write_cpio_finish_entry(struct archive_write *);
 static int	archive_write_cpio_header(struct archive_write *,
 		    struct archive_entry *);
-static int	format_octal(int64_t, void *, int);
-static int64_t	format_octal_recursive(int64_t, char *, int);
+static int	format_octal(__LA_INT64_T, void *, int);
+static __LA_INT64_T	format_octal_recursive(__LA_INT64_T, char *, int);
 static int	write_header(struct archive_write *, struct archive_entry *);
 
 struct cpio {
-	uint64_t	  entry_bytes_remaining;
+	__LA_UINT64_T	  entry_bytes_remaining;
 
-	int64_t		  ino_next;
+	__LA_INT64_T		  ino_next;
 
-	struct		 { int64_t old; int new;} *ino_list;
+	struct		 { __LA_INT64_T old; int new;} *ino_list;
 	size_t		  ino_list_size;
 	size_t		  ino_list_next;
 };
@@ -128,7 +128,7 @@
 static int
 synthesize_ino_value(struct cpio *cpio, struct archive_entry *entry)
 {
-	int64_t ino = archive_entry_ino64(entry);
+	__LA_INT64_T ino = archive_entry_ino64(entry);
 	int ino_new;
 	size_t i;
 
@@ -205,7 +205,7 @@
 	struct cpio *cpio;
 	const char *p, *path;
 	int pathlength, ret, ret_final;
-	int64_t	ino;
+	__LA_INT64_T	ino;
 	struct cpio_header	 h;
 
 	cpio = (struct cpio *)a->format_data;
@@ -280,7 +280,7 @@
 	return (ret_final);
 }
 
-static ssize_t
+static __LA_SSIZE_T
 archive_write_cpio_data(struct archive_write *a, const void *buff, size_t s)
 {
 	struct cpio *cpio;
@@ -302,12 +302,12 @@
  * Format a number into the specified field.
  */
 static int
-format_octal(int64_t v, void *p, int digits)
+format_octal(__LA_INT64_T v, void *p, int digits)
 {
-	int64_t	max;
+	__LA_INT64_T	max;
 	int	ret;
 
-	max = (((int64_t)1) << (digits * 3)) - 1;
+	max = (((__LA_INT64_T)1) << (digits * 3)) - 1;
 	if (v >= 0  &&  v <= max) {
 	    format_octal_recursive(v, (char *)p, digits);
 	    ret = 0;
@@ -318,8 +318,8 @@
 	return (ret);
 }
 
-static int64_t
-format_octal_recursive(int64_t v, char *p, int s)
+static __LA_INT64_T
+format_octal_recursive(__LA_INT64_T v, char *p, int s)
 {
 	if (s == 0)
 		return (v);
Index: libarchive/archive_read_support_format_raw.c
===================================================================
--- libarchive/archive_read_support_format_raw.c	(revision 2914)
+++ libarchive/archive_read_support_format_raw.c	(working copy)
@@ -39,15 +39,15 @@
 #include "archive_read_private.h"
 
 struct raw_info {
-	int64_t offset; /* Current position in the file. */
-	int64_t unconsumed;
+	__LA_INT64_T offset; /* Current position in the file. */
+	__LA_INT64_T unconsumed;
 	int     end_of_file;
 };
 
 static int	archive_read_format_raw_bid(struct archive_read *);
 static int	archive_read_format_raw_cleanup(struct archive_read *);
 static int	archive_read_format_raw_read_data(struct archive_read *,
-		    const void **, size_t *, int64_t *);
+		    const void **, size_t *, __LA_INT64_T *);
 static int	archive_read_format_raw_read_data_skip(struct archive_read *);
 static int	archive_read_format_raw_read_header(struct archive_read *,
 		    struct archive_entry *);
@@ -123,10 +123,10 @@
 
 static int
 archive_read_format_raw_read_data(struct archive_read *a,
-    const void **buff, size_t *size, int64_t *offset)
+    const void **buff, size_t *size, __LA_INT64_T *offset)
 {
 	struct raw_info *info;
-	ssize_t avail;
+	__LA_SSIZE_T avail;
 
 	info = (struct raw_info *)(a->format->data);
 
Index: libarchive/archive_write_private.h
===================================================================
--- libarchive/archive_write_private.h	(revision 2914)
+++ libarchive/archive_write_private.h	(working copy)
@@ -39,7 +39,7 @@
 struct archive_write;
 
 struct archive_write_filter {
-	int64_t bytes_written;
+	__LA_INT64_T bytes_written;
 	struct archive *archive; /* Associated archive. */
 	struct archive_write_filter *next_filter; /* Who I write to. */
 	int	(*options)(struct archive_write_filter *,
@@ -71,8 +71,8 @@
 	struct archive	archive;
 
 	/* Dev/ino of the archive being written. */
-	dev_t		  skip_file_dev;
-	int64_t		  skip_file_ino;
+	__LA_DEV_T		  skip_file_dev;
+	__LA_INT64_T		  skip_file_ino;
 
 	/* Utility:  Pointer to a block of nulls. */
 	const unsigned char	*nulls;
@@ -111,7 +111,7 @@
 	int	(*format_finish_entry)(struct archive_write *);
 	int 	(*format_write_header)(struct archive_write *,
 		    struct archive_entry *);
-	ssize_t	(*format_write_data)(struct archive_write *,
+	__LA_SSIZE_T	(*format_write_data)(struct archive_write *,
 		    const void *buff, size_t);
 	int	(*format_close)(struct archive_write *);
 	int	(*format_free)(struct archive_write *);
Index: libarchive/archive_write_set_format_gnutar.c
===================================================================
--- libarchive/archive_write_set_format_gnutar.c	(revision 2914)
+++ libarchive/archive_write_set_format_gnutar.c	(working copy)
@@ -46,8 +46,8 @@
 #include "archive_write_private.h"
 
 struct gnutar {
-	uint64_t	entry_bytes_remaining;
-	uint64_t	entry_padding;
+	__LA_UINT64_T	entry_bytes_remaining;
+	__LA_UINT64_T	entry_padding;
 };
 
 /*
@@ -142,14 +142,14 @@
 		    struct archive_entry *, int tartype);
 static int      archive_write_gnutar_header(struct archive_write *,
 		    struct archive_entry *entry);
-static ssize_t	archive_write_gnutar_data(struct archive_write *a, const void *buff,
+static __LA_SSIZE_T	archive_write_gnutar_data(struct archive_write *a, const void *buff,
 		    size_t s);
 static int	archive_write_gnutar_free(struct archive_write *);
 static int	archive_write_gnutar_close(struct archive_write *);
 static int	archive_write_gnutar_finish_entry(struct archive_write *);
-static int	format_256(int64_t, char *, int);
-static int	format_number(int64_t, char *, int size, int maxsize);
-static int	format_octal(int64_t, char *, int);
+static int	format_256(__LA_INT64_T, char *, int);
+static int	format_number(__LA_INT64_T, char *, int size, int maxsize);
+static int	format_octal(__LA_INT64_T, char *, int);
 
 /*
  * Set output format to 'GNU tar' format.
@@ -207,7 +207,7 @@
 	return (ret);
 }
 
-static ssize_t
+static __LA_SSIZE_T
 archive_write_gnutar_data(struct archive_write *a, const void *buff, size_t s)
 {
 	struct gnutar *gnutar;
@@ -288,7 +288,7 @@
 		ret = __archive_write_output(a, linkname, todo);
 		if(ret < ARCHIVE_WARN)
 			return (ret);
-		ret = __archive_write_nulls(a, 0x1ff & (-(ssize_t)todo));
+		ret = __archive_write_nulls(a, 0x1ff & (-(__LA_SSIZE_T)todo));
 		if (ret < ARCHIVE_WARN)
 			return (ret);
 	}
@@ -317,7 +317,7 @@
 		ret = __archive_write_output(a, pathname, todo);
 		if(ret < ARCHIVE_WARN)
 			return (ret);
-		ret = __archive_write_nulls(a, 0x1ff & (-(ssize_t)todo));
+		ret = __archive_write_nulls(a, 0x1ff & (-(__LA_SSIZE_T)todo));
 		if (ret < ARCHIVE_WARN)
 			return (ret);
 	}
@@ -355,7 +355,7 @@
 		ret = ret2;
 
 	gnutar->entry_bytes_remaining = archive_entry_size(entry);
-	gnutar->entry_padding = 0x1ff & (-(int64_t)gnutar->entry_bytes_remaining);
+	gnutar->entry_padding = 0x1ff & (-(__LA_INT64_T)gnutar->entry_bytes_remaining);
 	return (ret);
 }
 
@@ -478,9 +478,9 @@
  * Format a number into a field, falling back to base-256 if necessary.
  */
 static int
-format_number(int64_t v, char *p, int s, int maxsize)
+format_number(__LA_INT64_T v, char *p, int s, int maxsize)
 {
-	int64_t limit = ((int64_t)1 << (s*3));
+	__LA_INT64_T limit = ((__LA_INT64_T)1 << (s*3));
 
 	if (v < limit)
 		return (format_octal(v, p, s));
@@ -491,7 +491,7 @@
  * Format a number into the specified field using base-256.
  */
 static int
-format_256(int64_t v, char *p, int s)
+format_256(__LA_INT64_T v, char *p, int s)
 {
 	p += s;
 	while (s-- > 0) {
@@ -506,7 +506,7 @@
  * Format a number into the specified field using octal.
  */
 static int
-format_octal(int64_t v, char *p, int s)
+format_octal(__LA_INT64_T v, char *p, int s)
 {
 	int len = s;
 
Index: libarchive/archive_read_support_compression_bzip2.c
===================================================================
--- libarchive/archive_read_support_compression_bzip2.c	(revision 2914)
+++ libarchive/archive_read_support_compression_bzip2.c	(working copy)
@@ -58,7 +58,7 @@
 };
 
 /* Bzip2 filter */
-static ssize_t	bzip2_filter_read(struct archive_read_filter *, const void **);
+static __LA_SSIZE_T	bzip2_filter_read(struct archive_read_filter *, const void **);
 static int	bzip2_filter_close(struct archive_read_filter *);
 #endif
 
@@ -112,7 +112,7 @@
 bzip2_reader_bid(struct archive_read_filter_bidder *self, struct archive_read_filter *filter)
 {
 	const unsigned char *buffer;
-	ssize_t avail;
+	__LA_SSIZE_T avail;
 	int bits_checked;
 
 	(void)self; /* UNUSED */
@@ -206,13 +206,13 @@
 /*
  * Return the next block of decompressed data.
  */
-static ssize_t
+static __LA_SSIZE_T
 bzip2_filter_read(struct archive_read_filter *self, const void **p)
 {
 	struct private_data *state;
 	size_t decompressed;
 	const char *read_buf;
-	ssize_t ret;
+	__LA_SSIZE_T ret;
 
 	state = (struct private_data *)self->data;
 
Index: libarchive/archive_write_set_format_ar.c
===================================================================
--- libarchive/archive_write_set_format_ar.c	(revision 2914)
+++ libarchive/archive_write_set_format_ar.c	(working copy)
@@ -44,8 +44,8 @@
 #include "archive_write_private.h"
 
 struct ar_w {
-	uint64_t	 entry_bytes_remaining;
-	uint64_t	 entry_padding;
+	__LA_UINT64_T	 entry_bytes_remaining;
+	__LA_UINT64_T	 entry_padding;
 	int		 is_strtab;
 	int		 has_strtab;
 	char		 wrote_global_header;
@@ -73,14 +73,14 @@
 static int		 archive_write_set_format_ar(struct archive_write *);
 static int		 archive_write_ar_header(struct archive_write *,
 			     struct archive_entry *);
-static ssize_t		 archive_write_ar_data(struct archive_write *,
+static __LA_SSIZE_T		 archive_write_ar_data(struct archive_write *,
 			     const void *buff, size_t s);
 static int		 archive_write_ar_free(struct archive_write *);
 static int		 archive_write_ar_close(struct archive_write *);
 static int		 archive_write_ar_finish_entry(struct archive_write *);
 static const char	*ar_basename(const char *path);
-static int		 format_octal(int64_t v, char *p, int s);
-static int		 format_decimal(int64_t v, char *p, int s);
+static int		 format_octal(__LA_INT64_T v, char *p, int s);
+static int		 format_decimal(__LA_INT64_T v, char *p, int s);
 
 int
 archive_write_set_format_ar_bsd(struct archive *_a)
@@ -152,7 +152,7 @@
 	struct ar_w *ar;
 	const char *pathname;
 	const char *filename;
-	int64_t size;
+	__LA_INT64_T size;
 
 	append_fn = 0;
 	ar = (struct ar_w *)a->format_data;
@@ -358,7 +358,7 @@
 	return (ARCHIVE_OK);
 }
 
-static ssize_t
+static __LA_SSIZE_T
 archive_write_ar_data(struct archive_write *a, const void *buff, size_t s)
 {
 	struct ar_w *ar;
@@ -468,7 +468,7 @@
  * _ustar.c
  */
 static int
-format_octal(int64_t v, char *p, int s)
+format_octal(__LA_INT64_T v, char *p, int s)
 {
 	int len;
 	char *h;
@@ -507,7 +507,7 @@
  * Format a number into the specified field using base-10.
  */
 static int
-format_decimal(int64_t v, char *p, int s)
+format_decimal(__LA_INT64_T v, char *p, int s)
 {
 	int len;
 	char *h;
Index: libarchive/archive_entry.c
===================================================================
--- libarchive/archive_entry.c	(revision 2914)
+++ libarchive/archive_entry.c	(working copy)
@@ -299,7 +299,7 @@
 	return (entry->ae_stat.aest_ctime_nsec);
 }
 
-dev_t
+__LA_DEV_T
 archive_entry_dev(struct archive_entry *entry)
 {
 	if (entry->ae_stat.aest_dev_is_broken_down)
@@ -309,7 +309,7 @@
 		return (entry->ae_stat.aest_dev);
 }
 
-dev_t
+__LA_DEV_T
 archive_entry_devmajor(struct archive_entry *entry)
 {
 	if (entry->ae_stat.aest_dev_is_broken_down)
@@ -318,7 +318,7 @@
 		return major(entry->ae_stat.aest_dev);
 }
 
-dev_t
+__LA_DEV_T
 archive_entry_devminor(struct archive_entry *entry)
 {
 	if (entry->ae_stat.aest_dev_is_broken_down)
@@ -327,7 +327,7 @@
 		return minor(entry->ae_stat.aest_dev);
 }
 
-mode_t
+__LA_MODE_T
 archive_entry_filetype(struct archive_entry *entry)
 {
 	return (AE_IFMT & entry->acl.mode);
@@ -374,10 +374,10 @@
 }
 
 #if ARCHIVE_VERSION_NUMBER < 3000000
-gid_t
+__LA_GID_T
 archive_entry_gid(struct archive_entry *entry)
 #else
-int64_t
+__LA_INT64_T
 archive_entry_gid(struct archive_entry *entry)
 #endif
 {
@@ -419,20 +419,20 @@
 	return (entry->ae_stat.aest_ino);
 }
 #else
-int64_t
+__LA_INT64_T
 archive_entry_ino(struct archive_entry *entry)
 {
 	return (entry->ae_stat.aest_ino);
 }
 #endif
 
-int64_t
+__LA_INT64_T
 archive_entry_ino64(struct archive_entry *entry)
 {
 	return (entry->ae_stat.aest_ino);
 }
 
-mode_t
+__LA_MODE_T
 archive_entry_mode(struct archive_entry *entry)
 {
 	return (entry->acl.mode);
@@ -474,13 +474,13 @@
 	return (archive_mstring_get_wcs(&entry->ae_pathname));
 }
 
-mode_t
+__LA_MODE_T
 archive_entry_perm(struct archive_entry *entry)
 {
 	return (~AE_IFMT & entry->acl.mode);
 }
 
-dev_t
+__LA_DEV_T
 archive_entry_rdev(struct archive_entry *entry)
 {
 	if (entry->ae_stat.aest_rdev_is_broken_down)
@@ -490,7 +490,7 @@
 		return (entry->ae_stat.aest_rdev);
 }
 
-dev_t
+__LA_DEV_T
 archive_entry_rdevmajor(struct archive_entry *entry)
 {
 	if (entry->ae_stat.aest_rdev_is_broken_down)
@@ -499,7 +499,7 @@
 		return major(entry->ae_stat.aest_rdev);
 }
 
-dev_t
+__LA_DEV_T
 archive_entry_rdevminor(struct archive_entry *entry)
 {
 	if (entry->ae_stat.aest_rdev_is_broken_down)
@@ -508,7 +508,7 @@
 		return minor(entry->ae_stat.aest_rdev);
 }
 
-int64_t
+__LA_INT64_T
 archive_entry_size(struct archive_entry *entry)
 {
 	return (entry->ae_stat.aest_size);
@@ -543,10 +543,10 @@
 }
 
 #if ARCHIVE_VERSION_NUMBER < 3000000
-uid_t
+__LA_UID_T
 archive_entry_uid(struct archive_entry *entry)
 #else
-int64_t
+__LA_INT64_T
 archive_entry_uid(struct archive_entry *entry)
 #endif
 {
@@ -606,10 +606,10 @@
 
 #if ARCHIVE_VERSION_NUMBER < 3000000
 void
-archive_entry_set_gid(struct archive_entry *entry, gid_t g)
+archive_entry_set_gid(struct archive_entry *entry, __LA_GID_T g)
 #else
 void
-archive_entry_set_gid(struct archive_entry *entry, int64_t g)
+archive_entry_set_gid(struct archive_entry *entry, __LA_INT64_T g)
 #endif
 {
 	entry->stat_valid = 0;
@@ -649,7 +649,7 @@
 }
 #else
 void
-archive_entry_set_ino(struct archive_entry *entry, int64_t ino)
+archive_entry_set_ino(struct archive_entry *entry, __LA_INT64_T ino)
 {
 	entry->stat_valid = 0;
 	entry->ae_stat.aest_ino = ino;
@@ -657,7 +657,7 @@
 #endif
 
 void
-archive_entry_set_ino64(struct archive_entry *entry, int64_t ino)
+archive_entry_set_ino64(struct archive_entry *entry, __LA_INT64_T ino)
 {
 	entry->stat_valid = 0;
 	entry->ae_stat.aest_ino = ino;
@@ -755,7 +755,7 @@
 }
 
 void
-archive_entry_set_dev(struct archive_entry *entry, dev_t d)
+archive_entry_set_dev(struct archive_entry *entry, __LA_DEV_T d)
 {
 	entry->stat_valid = 0;
 	entry->ae_stat.aest_dev_is_broken_down = 0;
@@ -763,7 +763,7 @@
 }
 
 void
-archive_entry_set_devmajor(struct archive_entry *entry, dev_t m)
+archive_entry_set_devmajor(struct archive_entry *entry, __LA_DEV_T m)
 {
 	entry->stat_valid = 0;
 	entry->ae_stat.aest_dev_is_broken_down = 1;
@@ -771,7 +771,7 @@
 }
 
 void
-archive_entry_set_devminor(struct archive_entry *entry, dev_t m)
+archive_entry_set_devminor(struct archive_entry *entry, __LA_DEV_T m)
 {
 	entry->stat_valid = 0;
 	entry->ae_stat.aest_dev_is_broken_down = 1;
@@ -818,7 +818,7 @@
 }
 
 void
-archive_entry_set_mode(struct archive_entry *entry, mode_t m)
+archive_entry_set_mode(struct archive_entry *entry, __LA_MODE_T m)
 {
 	entry->stat_valid = 0;
 	entry->acl.mode = m;
@@ -873,7 +873,7 @@
 }
 
 void
-archive_entry_set_perm(struct archive_entry *entry, mode_t p)
+archive_entry_set_perm(struct archive_entry *entry, __LA_MODE_T p)
 {
 	entry->stat_valid = 0;
 	entry->acl.mode &= AE_IFMT;
@@ -881,7 +881,7 @@
 }
 
 void
-archive_entry_set_rdev(struct archive_entry *entry, dev_t m)
+archive_entry_set_rdev(struct archive_entry *entry, __LA_DEV_T m)
 {
 	entry->stat_valid = 0;
 	entry->ae_stat.aest_rdev = m;
@@ -889,7 +889,7 @@
 }
 
 void
-archive_entry_set_rdevmajor(struct archive_entry *entry, dev_t m)
+archive_entry_set_rdevmajor(struct archive_entry *entry, __LA_DEV_T m)
 {
 	entry->stat_valid = 0;
 	entry->ae_stat.aest_rdev_is_broken_down = 1;
@@ -897,7 +897,7 @@
 }
 
 void
-archive_entry_set_rdevminor(struct archive_entry *entry, dev_t m)
+archive_entry_set_rdevminor(struct archive_entry *entry, __LA_DEV_T m)
 {
 	entry->stat_valid = 0;
 	entry->ae_stat.aest_rdev_is_broken_down = 1;
@@ -905,7 +905,7 @@
 }
 
 void
-archive_entry_set_size(struct archive_entry *entry, int64_t s)
+archive_entry_set_size(struct archive_entry *entry, __LA_INT64_T s)
 {
 	entry->stat_valid = 0;
 	entry->ae_stat.aest_size = s;
@@ -967,10 +967,10 @@
 
 #if ARCHIVE_VERSION_NUMBER < 3000000
 void
-archive_entry_set_uid(struct archive_entry *entry, uid_t u)
+archive_entry_set_uid(struct archive_entry *entry, __LA_UID_T u)
 #else
 void
-archive_entry_set_uid(struct archive_entry *entry, int64_t u)
+archive_entry_set_uid(struct archive_entry *entry, __LA_INT64_T u)
 #endif
 {
 	entry->stat_valid = 0;
Index: libarchive/archive_read_support_compression_uu.c
===================================================================
--- libarchive/archive_read_support_compression_uu.c	(revision 2914)
+++ libarchive/archive_read_support_compression_uu.c	(working copy)
@@ -41,7 +41,7 @@
 #include "archive_read_private.h"
 
 struct uudecode {
-	int64_t		 total;
+	__LA_INT64_T		 total;
 	unsigned char	*in_buff;
 #define IN_BUFF_SIZE	(1024)
 	int		 in_cnt;
@@ -59,7 +59,7 @@
 		    struct archive_read_filter *filter);
 static int	uudecode_bidder_init(struct archive_read_filter *);
 
-static ssize_t	uudecode_filter_read(struct archive_read_filter *,
+static __LA_SSIZE_T	uudecode_filter_read(struct archive_read_filter *,
 		    const void **);
 static int	uudecode_filter_close(struct archive_read_filter *);
 
@@ -158,10 +158,10 @@
 	49, 50, 51,  0,  0,  0,  0,  0, /* 70 - 7F */
 };
 
-static ssize_t
-get_line(const unsigned char *b, ssize_t avail, ssize_t *nlsize)
+static __LA_SSIZE_T
+get_line(const unsigned char *b, __LA_SSIZE_T avail, __LA_SSIZE_T *nlsize)
 {
-	ssize_t len;
+	__LA_SSIZE_T len;
 
 	len = 0;
 	while (len < avail) {
@@ -192,11 +192,11 @@
 	return (avail);
 }
 
-static ssize_t
+static __LA_SSIZE_T
 bid_get_line(struct archive_read_filter *filter,
-    const unsigned char **b, ssize_t *avail, ssize_t *ravail, ssize_t *nl)
+    const unsigned char **b, __LA_SSIZE_T *avail, __LA_SSIZE_T *ravail, __LA_SSIZE_T *nl)
 {
-	ssize_t len;
+	__LA_SSIZE_T len;
 	int quit;
 	
 	quit = 0;
@@ -209,7 +209,7 @@
 	 * Read bytes more while it does not reach the end of line.
 	 */
 	while (*nl == 0 && len == *avail && !quit) {
-		ssize_t diff = *ravail - *avail;
+		__LA_SSIZE_T diff = *ravail - *avail;
 
 		*b = __archive_read_filter_ahead(filter, 160 + *ravail, avail);
 		if (*b == NULL) {
@@ -234,8 +234,8 @@
     struct archive_read_filter *filter)
 {
 	const unsigned char *b;
-	ssize_t avail, ravail;
-	ssize_t len, nl;
+	__LA_SSIZE_T avail, ravail;
+	__LA_SSIZE_T len, nl;
 	int l;
 	int firstline;
 
@@ -401,16 +401,16 @@
 	return (ARCHIVE_OK);
 }
 
-static ssize_t
+static __LA_SSIZE_T
 uudecode_filter_read(struct archive_read_filter *self, const void **buff)
 {
 	struct uudecode *uudecode;
 	const unsigned char *b, *d;
 	unsigned char *out;
-	ssize_t avail_in, ravail;
-	ssize_t used;
-	ssize_t total;
-	ssize_t len, llen, nl;
+	__LA_SSIZE_T avail_in, ravail;
+	__LA_SSIZE_T used;
+	__LA_SSIZE_T total;
+	__LA_SSIZE_T len, llen, nl;
 
 	uudecode = (struct uudecode *)self->data;
 
Index: libarchive/archive_write_set_format_cpio_newc.c
===================================================================
--- libarchive/archive_write_set_format_cpio_newc.c	(revision 2914)
+++ libarchive/archive_write_set_format_cpio_newc.c	(working copy)
@@ -43,19 +43,19 @@
 #include "archive_private.h"
 #include "archive_write_private.h"
 
-static ssize_t	archive_write_newc_data(struct archive_write *,
+static __LA_SSIZE_T	archive_write_newc_data(struct archive_write *,
 		    const void *buff, size_t s);
 static int	archive_write_newc_close(struct archive_write *);
 static int	archive_write_newc_free(struct archive_write *);
 static int	archive_write_newc_finish_entry(struct archive_write *);
 static int	archive_write_newc_header(struct archive_write *,
 		    struct archive_entry *);
-static int	format_hex(int64_t, void *, int);
-static int64_t	format_hex_recursive(int64_t, char *, int);
+static int	format_hex(__LA_INT64_T, void *, int);
+static __LA_INT64_T	format_hex_recursive(__LA_INT64_T, char *, int);
 static int	write_header(struct archive_write *, struct archive_entry *);
 
 struct cpio {
-	uint64_t	  entry_bytes_remaining;
+	__LA_UINT64_T	  entry_bytes_remaining;
 	int		  padding;
 };
 
@@ -140,7 +140,7 @@
 static int
 write_header(struct archive_write *a, struct archive_entry *entry)
 {
-	int64_t ino;
+	__LA_INT64_T ino;
 	struct cpio *cpio;
 	const char *p, *path;
 	int pathlength, ret, ret_final;
@@ -234,7 +234,7 @@
 	return (ret_final);
 }
 
-static ssize_t
+static __LA_SSIZE_T
 archive_write_newc_data(struct archive_write *a, const void *buff, size_t s)
 {
 	struct cpio *cpio;
@@ -256,12 +256,12 @@
  * Format a number into the specified field.
  */
 static int
-format_hex(int64_t v, void *p, int digits)
+format_hex(__LA_INT64_T v, void *p, int digits)
 {
-	int64_t	max;
+	__LA_INT64_T	max;
 	int	ret;
 
-	max = (((int64_t)1) << (digits * 4)) - 1;
+	max = (((__LA_INT64_T)1) << (digits * 4)) - 1;
 	if (v >= 0  &&  v <= max) {
 	    format_hex_recursive(v, (char *)p, digits);
 	    ret = 0;
@@ -272,8 +272,8 @@
 	return (ret);
 }
 
-static int64_t
-format_hex_recursive(int64_t v, char *p, int s)
+static __LA_INT64_T
+format_hex_recursive(__LA_INT64_T v, char *p, int s)
 {
 	if (s == 0)
 		return (v);
Index: libarchive/config_freebsd.h
===================================================================
--- libarchive/config_freebsd.h	(revision 2914)
+++ libarchive/config_freebsd.h	(working copy)
@@ -155,6 +155,6 @@
 
 /* FreeBSD 4 and earlier lack intmax_t/uintmax_t */
 #if __FreeBSD__ < 5
-#define	intmax_t int64_t
-#define	uintmax_t uint64_t
+#define	intmax_t __LA_INT64_T
+#define	uintmax_t __LA_UINT64_T
 #endif
Index: libarchive/archive_read_support_compression_compress.c
===================================================================
--- libarchive/archive_read_support_compression_compress.c	(revision 2914)
+++ libarchive/archive_read_support_compression_compress.c	(working copy)
@@ -117,7 +117,7 @@
 	/* Dictionary. */
 	int			 free_ent;       /* Next dictionary entry. */
 	unsigned char		 suffix[65536];
-	uint16_t		 prefix[65536];
+	__LA_UINT16_T		 prefix[65536];
 
 	/*
 	 * Scratch area for expanding dictionary entries.  Note:
@@ -135,7 +135,7 @@
 static int	compress_bidder_init(struct archive_read_filter *);
 static int	compress_bidder_free(struct archive_read_filter_bidder *);
 
-static ssize_t	compress_filter_read(struct archive_read_filter *, const void **);
+static __LA_SSIZE_T	compress_filter_read(struct archive_read_filter *, const void **);
 static int	compress_filter_close(struct archive_read_filter *);
 
 static int	getbits(struct archive_read_filter *, int n);
@@ -167,7 +167,7 @@
     struct archive_read_filter *filter)
 {
 	const unsigned char *buffer;
-	ssize_t avail;
+	__LA_SSIZE_T avail;
 	int bits_checked;
 
 	(void)self; /* UNUSED */
@@ -256,7 +256,7 @@
  * Return a block of data from the decompression buffer.  Decompress more
  * as necessary.
  */
-static ssize_t
+static __LA_SSIZE_T
 compress_filter_read(struct archive_read_filter *self, const void **pblock)
 {
 	struct private_data *state;
@@ -410,7 +410,7 @@
 {
 	struct private_data *state = (struct private_data *)self->data;
 	int code;
-	ssize_t ret;
+	__LA_SSIZE_T ret;
 	static const int mask[] = {
 		0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff,
 		0x1ff, 0x3ff, 0x7ff, 0xfff, 0x1fff, 0x3fff, 0x7fff, 0xffff
Index: libarchive/archive_read_support_format_lha.c
===================================================================
--- libarchive/archive_read_support_format_lha.c	(revision 2914)
+++ libarchive/archive_read_support_format_lha.c	(working copy)
@@ -90,7 +90,7 @@
 	 * Bit stream reader.
 	 */
 	struct {
-#define CACHE_TYPE		uint64_t
+#define CACHE_TYPE		__LA_UINT64_T
 #define CACHE_BITS		(8 * sizeof(CACHE_TYPE))
 	 	/* Cache buffer. */
 		CACHE_TYPE	 cache_buffer;
@@ -116,7 +116,7 @@
 		 */
 		int		 max_bits;
 		int		 tbl_bits;
-		uint16_t	*tbl;
+		__LA_UINT16_T	*tbl;
 	}			 lt, pt;
 
 	int			 blocks_avail;
@@ -131,26 +131,26 @@
 
 struct lzh_stream {
 	const unsigned char	*next_in;
-	int64_t			 avail_in;
-	int64_t			 total_in;
+	__LA_INT64_T			 avail_in;
+	__LA_INT64_T			 total_in;
 	unsigned char		*next_out;
-	int64_t			 avail_out;
-	int64_t			 total_out;
+	__LA_INT64_T			 avail_out;
+	__LA_INT64_T			 total_out;
 	struct lzh_dec		*ds;
 };
 
 struct lha {
 	/* entry_bytes_remaining is the number of bytes we expect.	    */
-	int64_t                  entry_offset;
-	int64_t                  entry_bytes_remaining;
-	int64_t			 entry_unconsumed;
-	uint16_t		 entry_crc_calculated;
+	__LA_INT64_T                  entry_offset;
+	__LA_INT64_T                  entry_bytes_remaining;
+	__LA_INT64_T			 entry_unconsumed;
+	__LA_UINT16_T		 entry_crc_calculated;
  
 	size_t			 header_size;	/* header size		    */
 	unsigned char		 level;		/* header level		    */
 	char			 method[3];	/* compress type	    */
-	int64_t			 compsize;	/* compressed data size	    */
-	int64_t			 origsize;	/* original file size	    */
+	__LA_INT64_T			 compsize;	/* compressed data size	    */
+	__LA_INT64_T			 origsize;	/* original file size	    */
 	int			 setflag;
 #define BIRTHTIME_IS_SET	1
 #define ATIME_IS_SET		2
@@ -161,13 +161,13 @@
 	long			 mtime_tv_nsec;
 	time_t			 atime;
 	long			 atime_tv_nsec;
-	mode_t			 mode;
-	int64_t			 uid;
-	int64_t			 gid;
+	__LA_MODE_T			 mode;
+	__LA_INT64_T			 uid;
+	__LA_INT64_T			 gid;
 	struct archive_string 	 uname;
 	struct archive_string 	 gname;
-	uint16_t		 header_crc;
-	uint16_t		 crc;
+	__LA_UINT16_T		 header_crc;
+	__LA_UINT16_T		 crc;
 
 	struct archive_string 	 dirname;
 	struct archive_string 	 filename;
@@ -203,7 +203,7 @@
 #define H_LEVEL_OFFSET	20	/* Header Level.  */
 #define H_SIZE		22	/* Minimum header size. */
 
-static const uint16_t crc16tbl[256] = {
+static const __LA_UINT16_T crc16tbl[256] = {
 	0x0000,0xC0C1,0xC181,0x0140,0xC301,0x03C0,0x0280,0xC241,
 	0xC601,0x06C0,0x0780,0xC741,0x0500,0xC5C1,0xC481,0x0440,
 	0xCC01,0x0CC0,0x0D80,0xCD41,0x0F00,0xCFC1,0xCE81,0x0E40,
@@ -242,7 +242,7 @@
 static int	archive_read_format_lha_read_header(struct archive_read *,
 		    struct archive_entry *);
 static int	archive_read_format_lha_read_data(struct archive_read *,
-		    const void **, size_t *, int64_t *);
+		    const void **, size_t *, __LA_INT64_T *);
 static int	archive_read_format_lha_read_data_skip(struct archive_read *);
 static int	archive_read_format_lha_cleanup(struct archive_read *);
 
@@ -251,20 +251,20 @@
 static int	lha_read_file_header_2(struct archive_read *, struct lha *);
 static int	lha_read_file_header_3(struct archive_read *, struct lha *);
 static int	lha_read_file_extended_header(struct archive_read *,
-		    struct lha *, uint16_t *, int, size_t, size_t *);
+		    struct lha *, __LA_UINT16_T *, int, size_t, size_t *);
 static size_t	lha_check_header_format(const void *);
 static int	lha_skip_sfx(struct archive_read *);
 static time_t	lha_dos_time(const unsigned char *);
-static time_t	lha_win_time(uint64_t, long *);
+static time_t	lha_win_time(__LA_UINT64_T, long *);
 static unsigned char	lha_calcsum(unsigned char, const void *,
 		    int, int);
 static int	lha_parse_linkname(struct archive_string *,
 		    struct archive_string *);
 static int	lha_read_data_none(struct archive_read *, const void **,
-		    size_t *, int64_t *);
+		    size_t *, __LA_INT64_T *);
 static int	lha_read_data_lzh(struct archive_read *, const void **,
-		    size_t *, int64_t *);
-static uint16_t lha_crc16(uint16_t, const void *, size_t);
+		    size_t *, __LA_INT64_T *);
+static __LA_UINT16_T lha_crc16(__LA_UINT16_T, const void *, size_t);
 static int	lzh_decode_init(struct lzh_stream *, const char *);
 static void	lzh_decode_free(struct lzh_stream *);
 static int	lzh_decode(struct lzh_stream *, int);
@@ -272,7 +272,7 @@
 static int	lzh_huffman_init(struct huffman *, size_t, int, int);
 static void	lzh_huffman_free(struct huffman *);
 static int	lzh_read_pt_bitlen(struct lzh_stream *, int start, int end);
-static int	lzh_make_fake_table(struct huffman *, uint16_t);
+static int	lzh_make_fake_table(struct huffman *, __LA_UINT16_T);
 static int	lzh_make_huffman_table(struct huffman *);
 
 
@@ -368,7 +368,7 @@
 {
 	const char *p;
 	const void *buff;
-	ssize_t bytes_avail, offset, window;
+	__LA_SSIZE_T bytes_avail, offset, window;
 	size_t next;
 
 	if ((p = __archive_read_ahead(a, H_SIZE, NULL)) == NULL)
@@ -409,7 +409,7 @@
 	const void *h;
 	const char *p, *q;
 	size_t next, skip;
-	ssize_t bytes, window;
+	__LA_SSIZE_T bytes, window;
 
 	window = 4096;
 	for (;;) {
@@ -929,7 +929,7 @@
 	const unsigned char *p;
 	size_t extdsize;
 	int err, padding;
-	uint16_t header_crc;
+	__LA_UINT16_T header_crc;
 
 	if ((p = __archive_read_ahead(a, H2_FIXED_SIZE, NULL)) == NULL)
 		return (truncated_error(a));
@@ -1007,7 +1007,7 @@
 	const unsigned char *p;
 	size_t extdsize;
 	int err;
-	uint16_t header_crc;
+	__LA_UINT16_T header_crc;
 
 	if ((p = __archive_read_ahead(a, H3_FIXED_SIZE, NULL)) == NULL)
 		return (truncated_error(a));
@@ -1059,7 +1059,7 @@
  */
 static int
 lha_read_file_extended_header(struct archive_read *a, struct lha *lha,
-    uint16_t *crc, int sizefield_length, size_t limitsize, size_t *total_size)
+    __LA_UINT16_T *crc, int sizefield_length, size_t limitsize, size_t *total_size)
 {
 	const void *h;
 	const unsigned char *extdheader;
@@ -1096,7 +1096,7 @@
 			return (truncated_error(a));
 		/* Check if the size is the zero indicates the end of the
 		 * extended header. */
-		if (sizefield_length == sizeof(uint16_t))
+		if (sizefield_length == sizeof(__LA_UINT16_T))
 			extdsize = archive_le16dec(h);
 		else
 			extdsize = archive_le32dec(h);
@@ -1109,8 +1109,8 @@
 		}
 
 		/* Sanity check to the extended header size. */
-		if (((uint64_t)*total_size + extdsize) >
-				    (uint64_t)limitsize ||
+		if (((__LA_UINT64_T)*total_size + extdsize) >
+				    (__LA_UINT64_T)limitsize ||
 		    extdsize <= (size_t)sizefield_length)
 			goto invalid;
 
@@ -1181,15 +1181,15 @@
 				    (archive_le16dec(extdheader) & 0xff);
 			break;
 		case EXT_TIMESTAMP:
-			if (datasize == (sizeof(uint64_t) * 3)) {
+			if (datasize == (sizeof(__LA_UINT64_T) * 3)) {
 				lha->birthtime = lha_win_time(
 				    archive_le64dec(extdheader),
 				    &lha->birthtime_tv_nsec);
-				extdheader += sizeof(uint64_t);
+				extdheader += sizeof(__LA_UINT64_T);
 				lha->mtime = lha_win_time(
 				    archive_le64dec(extdheader),
 				    &lha->mtime_tv_nsec);
-				extdheader += sizeof(uint64_t);
+				extdheader += sizeof(__LA_UINT64_T);
 				lha->atime = lha_win_time(
 				    archive_le64dec(extdheader),
 				    &lha->atime_tv_nsec);
@@ -1198,20 +1198,20 @@
 			}
 			break;
 		case EXT_FILESIZE:
-			if (datasize == sizeof(uint64_t) * 2) {
+			if (datasize == sizeof(__LA_UINT64_T) * 2) {
 				lha->compsize = archive_le64dec(extdheader);
-				extdheader += sizeof(uint64_t);
+				extdheader += sizeof(__LA_UINT64_T);
 				lha->origsize = archive_le64dec(extdheader);
 			}
 			break;
 		case EXT_UNIX_MODE:
-			if (datasize == sizeof(uint16_t)) {
+			if (datasize == sizeof(__LA_UINT16_T)) {
 				lha->mode = archive_le16dec(extdheader);
 				lha->setflag |= UNIX_MODE_IS_SET;
 			}
 			break;
 		case EXT_UNIX_GID_UID:
-			if (datasize == (sizeof(uint16_t) * 2)) {
+			if (datasize == (sizeof(__LA_UINT16_T) * 2)) {
 				lha->gid = archive_le16dec(extdheader);
 				lha->uid = archive_le16dec(extdheader+2);
 			}
@@ -1227,7 +1227,7 @@
 				    (const char *)extdheader, datasize);
 			break;
 		case EXT_UNIX_MTIME:
-			if (datasize == sizeof(uint32_t))
+			if (datasize == sizeof(__LA_UINT32_T))
 				lha->mtime = archive_le32dec(extdheader);
 			break;
 		case EXT_OS2_NEW_ATTR:
@@ -1246,7 +1246,7 @@
 			break;
 		case EXT_NEW_ATTR:
 			if (datasize == 20) {
-				lha->mode = (mode_t)archive_le32dec(extdheader);
+				lha->mode = (__LA_MODE_T)archive_le32dec(extdheader);
 				lha->gid = archive_le32dec(extdheader+4);
 				lha->uid = archive_le32dec(extdheader+8);
 				lha->birthtime = archive_le32dec(extdheader+12);
@@ -1273,7 +1273,7 @@
 
 static int
 archive_read_format_lha_read_data(struct archive_read *a,
-    const void **buff, size_t *size, int64_t *offset)
+    const void **buff, size_t *size, __LA_INT64_T *offset)
 {
 	struct lha *lha = (struct lha *)(a->format->data);
 	int r;
@@ -1318,10 +1318,10 @@
  */
 static int
 lha_read_data_none(struct archive_read *a, const void **buff,
-    size_t *size, int64_t *offset)
+    size_t *size, __LA_INT64_T *offset)
 {
 	struct lha *lha = (struct lha *)(a->format->data);
-	ssize_t bytes_avail;
+	__LA_SSIZE_T bytes_avail;
 
 	if (lha->entry_bytes_remaining == 0) {
 		*buff = NULL;
@@ -1365,10 +1365,10 @@
  */
 static int
 lha_read_data_lzh(struct archive_read *a, const void **buff,
-    size_t *size, int64_t *offset)
+    size_t *size, __LA_INT64_T *offset)
 {
 	struct lha *lha = (struct lha *)(a->format->data);
-	ssize_t bytes_avail;
+	__LA_SSIZE_T bytes_avail;
 	int r;
 
 	/* If the buffer hasn't been allocated, allocate it now. */
@@ -1570,7 +1570,7 @@
 
 /* Convert an MS-Windows-style date/time into Unix-style time. */
 static time_t
-lha_win_time(uint64_t wintime, long *ns)
+lha_win_time(__LA_UINT64_T wintime, long *ns)
 {
 #define EPOC_TIME ARCHIVE_LITERAL_ULL(116444736000000000)
 
@@ -1597,8 +1597,8 @@
 	return (sum);
 }
 
-static uint16_t
-lha_crc16(uint16_t crc, const void *pp, size_t len)
+static __LA_UINT16_T
+lha_crc16(__LA_UINT16_T crc, const void *pp, size_t len)
 {
 	const unsigned char *buff = (const unsigned char *)pp;
 
@@ -1699,10 +1699,10 @@
 #define lzh_br_has(strm, n)	((strm)->ds->br.cache_avail >= n)
 /* Get compressed data by bit. */
 #define lzh_br_bits(strm, n)				\
-	(((uint16_t)((strm)->ds->br.cache_buffer >>	\
+	(((__LA_UINT16_T)((strm)->ds->br.cache_buffer >>	\
 		((strm)->ds->br.cache_avail - (n)))) & cache_masks[n])
 #define lzh_br_bits_forced(strm, n)			\
-	(((uint16_t)((strm)->ds->br.cache_buffer <<	\
+	(((__LA_UINT16_T)((strm)->ds->br.cache_buffer <<	\
 		((n) - (strm)->ds->br.cache_avail))) & cache_masks[n])
 /* Read ahead to make sure the cache buffer has enough compressed data we
  * will use.
@@ -1714,7 +1714,7 @@
 /* Notify how man bits we consumed. */
 #define lzh_br_consume(strm, n)	((strm)->ds->br.cache_avail -= (n))
 
-static uint16_t cache_masks[] = {
+static __LA_UINT16_T cache_masks[] = {
 	0x0000, 0x0001, 0x0003, 0x0007,
 	0x000F, 0x001F, 0x003F, 0x007F,
 	0x00FF, 0x01FF, 0x03FF, 0x07FF,
@@ -1755,7 +1755,7 @@
 			case 6:
 				ds->br.cache_buffer =
 		 		   (ds->br.cache_buffer << 48) |
-				   (((uint64_t)archive_be32dec(
+				   (((__LA_UINT64_T)archive_be32dec(
 				       strm->next_in)) << 16) |
 				    archive_be16dec(&strm->next_in[4]);
 				break;
@@ -2262,7 +2262,7 @@
 }
 
 static int
-lzh_make_fake_table(struct huffman *hf, uint16_t c)
+lzh_make_fake_table(struct huffman *hf, __LA_UINT16_T c)
 {
 	if (c >= hf->len_size)
 		return (0);
@@ -2316,7 +2316,7 @@
 	 * Make the table.
 	 */
 	for (i = 0; i < hf->len_avail; ) {
-		uint16_t *p;
+		__LA_UINT16_T *p;
 		int len, cnt;
 
 		if ((len = hf->bitlen[i]) == 0) {
@@ -2332,7 +2332,7 @@
 		/* Update the table */
 		p = &(hf->tbl[ptn]);
 		while (--cnt >= 0)
-			*p++ = (uint16_t)i;
+			*p++ = (__LA_UINT16_T)i;
 		i++;
 	}
 	return (1);
Index: libarchive/archive_read_disk.3
===================================================================
--- libarchive/archive_read_disk.3	(revision 2914)
+++ libarchive/archive_read_disk.3	(working copy)
@@ -52,21 +52,21 @@
 .Ft int
 .Fn archive_read_disk_set_symlink_hybrid "struct archive *"
 .Ft int
-.Fn archive_read_disk_gname "struct archive *" "gid_t"
+.Fn archive_read_disk_gname "struct archive *" "__LA_GID_T"
 .Ft int
-.Fn archive_read_disk_uname "struct archive *" "uid_t"
+.Fn archive_read_disk_uname "struct archive *" "__LA_UID_T"
 .Ft int
 .Fo archive_read_disk_set_gname_lookup
 .Fa "struct archive *"
 .Fa "void *"
-.Fa "const char *(*lookup)(void *, gid_t)"
+.Fa "const char *(*lookup)(void *, __LA_GID_T)"
 .Fa "void (*cleanup)(void *)"
 .Fc
 .Ft int
 .Fo archive_read_disk_set_uname_lookup
 .Fa "struct archive *"
 .Fa "void *"
-.Fa "const char *(*lookup)(void *, uid_t)"
+.Fa "const char *(*lookup)(void *, __LA_UID_T)"
 .Fa "void (*cleanup)(void *)"
 .Fc
 .Ft int
Index: libarchive/archive_read_extract.c
===================================================================
--- libarchive/archive_read_extract.c	(revision 2914)
+++ libarchive/archive_read_extract.c	(working copy)
@@ -141,7 +141,7 @@
 #if ARCHIVE_VERSION_NUMBER < 3000000
 	off_t offset;
 #else
-	int64_t offset;
+	__LA_INT64_T offset;
 #endif
 	const void *buff;
 	struct extract *extract;
Index: libarchive/archive_entry.h
===================================================================
--- libarchive/archive_entry.h	(revision 2914)
+++ libarchive/archive_entry.h	(working copy)
@@ -43,34 +43,12 @@
 #include <stddef.h>  /* for wchar_t */
 #include <time.h>
 
-#if defined(_WIN32) && !defined(__CYGWIN__)
-#include <windows.h>
-#endif
+/*
+ * Note: Need to include archive.h for platform definitions such as
+ * __LA_INT64_T
+ */
+#include "archive.h"
 
-/* Get appropriate definitions of standard POSIX-style types. */
-/* These should match the types used in 'struct stat' */
-#if defined(_WIN32) && !defined(__CYGWIN__)
-#define	__LA_INT64_T	__int64
-# if defined(__BORLANDC__)
-#  define	__LA_UID_T	uid_t  /* Remove in libarchive 3.2 */
-#  define	__LA_GID_T	gid_t  /* Remove in libarchive 3.2 */
-#  define	__LA_DEV_T	dev_t
-#  define	__LA_MODE_T	mode_t
-# else
-#  define	__LA_UID_T	short  /* Remove in libarchive 3.2 */
-#  define	__LA_GID_T	short  /* Remove in libarchive 3.2 */
-#  define	__LA_DEV_T	unsigned int
-#  define	__LA_MODE_T	unsigned short
-# endif
-#else
-#include <unistd.h>
-#define	__LA_INT64_T	int64_t
-#define	__LA_UID_T	uid_t /* Remove in libarchive 3.2 */
-#define	__LA_GID_T	gid_t /* Remove in libarchive 3.2 */
-#define	__LA_DEV_T	dev_t
-#define	__LA_MODE_T	mode_t
-#endif
-
 /*
  * Remove this for libarchive 3.2, since ino_t is no longer used.
  */
Index: libarchive/archive_read_data_into_fd.c
===================================================================
--- libarchive/archive_read_data_into_fd.c	(revision 2914)
+++ libarchive/archive_read_data_into_fd.c	(working copy)
@@ -48,10 +48,10 @@
 int
 pad_to(struct archive *a, int fd, int can_lseek,
     size_t nulls_size, const char *nulls,
-    int64_t target_offset, int64_t actual_offset)
+    __LA_INT64_T target_offset, __LA_INT64_T actual_offset)
 {
 	size_t to_write;
-	ssize_t bytes_written;
+	__LA_SSIZE_T bytes_written;
 
 	if (can_lseek) {
 		actual_offset = lseek(fd,
@@ -84,13 +84,13 @@
 	int r, r2;
 	const void *buff;
 	size_t size, bytes_to_write;
-	ssize_t bytes_written;
+	__LA_SSIZE_T bytes_written;
 #if ARCHIVE_VERSION_NUMBER < 3000000
 	off_t target_offset;
 #else
-	int64_t target_offset;
+	__LA_INT64_T target_offset;
 #endif
-	int64_t actual_offset = 0;
+	__LA_INT64_T actual_offset = 0;
 	int can_lseek;
 	char *nulls = NULL;
 	size_t nulls_size = 16384;
Index: libarchive/archive_read_disk_set_standard_lookup.c
===================================================================
--- libarchive/archive_read_disk_set_standard_lookup.c	(revision 2914)
+++ libarchive/archive_read_disk_set_standard_lookup.c	(working copy)
@@ -73,11 +73,11 @@
 };
 
 #if ARCHIVE_VERSION_NUMBER < 3000000
-static const char *	lookup_gname(void *, gid_t);
-static const char *	lookup_uname(void *, uid_t);
+static const char *	lookup_gname(void *, __LA_GID_T);
+static const char *	lookup_uname(void *, __LA_UID_T);
 #else
-static const char *	lookup_gname(void *, int64_t);
-static const char *	lookup_uname(void *, int64_t);
+static const char *	lookup_gname(void *, __LA_INT64_T);
+static const char *	lookup_uname(void *, __LA_INT64_T);
 #endif
 static void	cleanup(void *);
 static const char *	lookup_gname_helper(struct name_cache *, id_t gid);
@@ -181,10 +181,10 @@
 
 #if ARCHIVE_VERSION_NUMBER < 3000000
 static const char *
-lookup_uname(void *data, uid_t uid)
+lookup_uname(void *data, __LA_UID_T uid)
 #else
 static const char *
-lookup_uname(void *data, int64_t uid)
+lookup_uname(void *data, __LA_INT64_T uid)
 #endif
 {
 	struct name_cache *uname_cache = (struct name_cache *)data;
@@ -207,7 +207,7 @@
 		return (NULL);
 	for (;;) {
 		result = &pwent; /* Old getpwuid_r ignores last arg. */
-		r = getpwuid_r((uid_t)id, &pwent,
+		r = getpwuid_r((__LA_UID_T)id, &pwent,
 			       cache->buff, cache->buff_size, &result);
 		if (r == 0)
 			break;
@@ -239,7 +239,7 @@
 {
 	struct passwd	*result;
 
-	result = getpwuid((uid_t)id);
+	result = getpwuid((__LA_UID_T)id);
 
 	if (result == NULL)
 		return (NULL);
@@ -250,10 +250,10 @@
 
 #if ARCHIVE_VERSION_NUMBER < 3000000
 static const char *
-lookup_gname(void *data, gid_t gid)
+lookup_gname(void *data, __LA_GID_T gid)
 #else
 static const char *
-lookup_gname(void *data, int64_t gid)
+lookup_gname(void *data, __LA_INT64_T gid)
 #endif
 {
 	struct name_cache *gname_cache = (struct name_cache *)data;
@@ -276,7 +276,7 @@
 		return (NULL);
 	for (;;) {
 		result = &grent; /* Old getgrgid_r ignores last arg. */
-		r = getgrgid_r((gid_t)id, &grent,
+		r = getgrgid_r((__LA_GID_T)id, &grent,
 			       cache->buff, cache->buff_size, &result);
 		if (r == 0)
 			break;
@@ -306,7 +306,7 @@
 {
 	struct group	*result;
 
-	result = getgrgid((gid_t)id);
+	result = getgrgid((__LA_GID_T)id);
 
 	if (result == NULL)
 		return (NULL);
Index: libarchive/archive_write_set_format_mtree.c
===================================================================
--- libarchive/archive_write_set_format_mtree.c	(revision 2914)
+++ libarchive/archive_write_set_format_mtree.c	(working copy)
@@ -49,23 +49,23 @@
 	struct archive_string ebuf;
 	struct archive_string buf;
 	int first;
-	uint64_t entry_bytes_remaining;
+	__LA_UINT64_T entry_bytes_remaining;
 	struct {
 		int		output;
 		int		processed;
 		struct archive_string parent;
-		mode_t		type;
+		__LA_MODE_T		type;
 		int		keys;
-		uid_t		uid;
-		gid_t		gid;
-		mode_t		mode;
+		__LA_UID_T		uid;
+		__LA_GID_T		gid;
+		__LA_MODE_T		mode;
 		unsigned long	fflags_set;
 		unsigned long	fflags_clear;
 	} set;
 	/* chekc sum */
 	int compute_sum;
-	uint32_t crc;
-	uint64_t crc_len;
+	__LA_UINT32_T crc;
+	__LA_UINT64_T crc_len;
 #ifdef ARCHIVE_HAS_MD5
 	archive_md5_ctx md5ctx;
 #endif
@@ -126,7 +126,7 @@
 			 | F_UNAME)
 
 #define	COMPUTE_CRC(var, ch)	(var) = (var) << 8 ^ crctab[(var) >> 24 ^ (ch)]
-static const uint32_t crctab[] = {
+static const __LA_UINT32_T crctab[] = {
 	0x0,
 	0x04c11db7, 0x09823b6e, 0x0d4326d9, 0x130476dc, 0x17c56b6b,
 	0x1a864db2, 0x1e475005, 0x2608edb8, 0x22c9f00f, 0x2f8ad6d6,
@@ -377,7 +377,7 @@
 	struct archive_string unsetstr;
 	const char *name;
 	int keys, oldkeys, effkeys;
-	mode_t set_type = 0;
+	__LA_MODE_T set_type = 0;
 
 	switch (archive_entry_filetype(entry)) {
 	case AE_IFLNK: case AE_IFSOCK: case AE_IFCHR:
@@ -752,7 +752,7 @@
 	}
 
 	if (mtree->compute_sum & F_CKSUM) {
-		uint64_t len;
+		__LA_UINT64_T len;
 		/* Include the length of the file. */
 		for (len = mtree->crc_len; len != 0; len >>= 8)
 			COMPUTE_CRC(mtree->crc, len & 0xff);
@@ -839,7 +839,7 @@
 	return __archive_write_output(a, mtree->buf.s, mtree->buf.length);
 }
 
-static ssize_t
+static __LA_SSIZE_T
 archive_write_mtree_data(struct archive_write *a, const void *buff, size_t n)
 {
 	struct mtree_writer *mtree= a->format_data;
Index: libarchive/archive_write.3
===================================================================
--- libarchive/archive_write.3	(revision 2914)
+++ libarchive/archive_write.3	(working copy)
@@ -109,7 +109,7 @@
 .Fc
 .Ft int
 .Fn archive_write_header "struct archive *" "struct archive_entry *"
-.Ft ssize_t
+.Ft __LA_SSIZE_T
 .Fn archive_write_data "struct archive *" "const void *" "size_t"
 .Ft int
 .Fn archive_write_finish_entry "struct archive *"
@@ -335,7 +335,7 @@
 .Cm ARCHIVE_FATAL .
 .Bl -item -offset indent
 .It
-.Ft typedef ssize_t
+.Ft typedef __LA_SSIZE_T
 .Fo archive_write_callback
 .Fa "struct archive *"
 .Fa "void *client_data"
@@ -409,7 +409,7 @@
     return (ARCHIVE_FATAL);
 }
 
-ssize_t
+__LA_SSIZE_T
 mywrite(struct archive *a, void *client_data, const void *buff, size_t n)
 {
   struct mydata *mydata = client_data;
Index: libarchive/archive_read_support_format_mtree.c
===================================================================
--- libarchive/archive_read_support_format_mtree.c	(revision 2914)
+++ libarchive/archive_read_support_format_mtree.c	(working copy)
@@ -86,7 +86,7 @@
 	struct archive_string	 line;
 	size_t			 buffsize;
 	char			*buff;
-	int64_t			 offset;
+	__LA_INT64_T			 offset;
 	int			 fd;
 	int			 filetype;
 	int			 archive_format;
@@ -98,7 +98,7 @@
 
 	struct archive_entry_linkresolver *resolver;
 
-	int64_t			 cur_size, cur_offset;
+	__LA_INT64_T			 cur_size, cur_offset;
 };
 
 static int	cleanup(struct archive_read *);
@@ -111,14 +111,14 @@
 static int	parse_keyword(struct archive_read *, struct mtree *,
 		    struct archive_entry *, struct mtree_option *, int *);
 static int	read_data(struct archive_read *a,
-		    const void **buff, size_t *size, int64_t *offset);
-static ssize_t	readline(struct archive_read *, struct mtree *, char **, ssize_t);
+		    const void **buff, size_t *size, __LA_INT64_T *offset);
+static __LA_SSIZE_T	readline(struct archive_read *, struct mtree *, char **, __LA_SSIZE_T);
 static int	skip(struct archive_read *a);
 static int	read_header(struct archive_read *,
 		    struct archive_entry *);
-static int64_t	mtree_atol10(char **);
-static int64_t	mtree_atol8(char **);
-static int64_t	mtree_atol(char **);
+static __LA_INT64_T	mtree_atol10(char **);
+static __LA_INT64_T	mtree_atol8(char **);
+static __LA_INT64_T	mtree_atol(char **);
 
 static void
 free_options(struct mtree_option *head)
@@ -389,7 +389,7 @@
 static int
 read_mtree(struct archive_read *a, struct mtree *mtree)
 {
-	ssize_t len;
+	__LA_SSIZE_T len;
 	uintmax_t counter;
 	char *p;
 	struct mtree_option *global;
@@ -748,7 +748,7 @@
 
 /*
  * Device entries have one of the following forms:
- * raw dev_t
+ * raw __LA_DEV_T
  * format,major,minor[,subdevice]
  *
  * Just use major and minor, no translation etc is done
@@ -977,10 +977,10 @@
 }
 
 static int
-read_data(struct archive_read *a, const void **buff, size_t *size, int64_t *offset)
+read_data(struct archive_read *a, const void **buff, size_t *size, __LA_INT64_T *offset)
 {
 	size_t bytes_to_read;
-	ssize_t bytes_read;
+	__LA_SSIZE_T bytes_read;
 	struct mtree *mtree;
 
 	mtree = (struct mtree *)(a->format->data);
@@ -1002,7 +1002,7 @@
 
 	*buff = mtree->buff;
 	*offset = mtree->offset;
-	if ((int64_t)mtree->buffsize > mtree->cur_size - mtree->offset)
+	if ((__LA_INT64_T)mtree->buffsize > mtree->cur_size - mtree->offset)
 		bytes_to_read = mtree->cur_size - mtree->offset;
 	else
 		bytes_to_read = mtree->buffsize;
@@ -1115,10 +1115,10 @@
  * locale settings; you cannot simply substitute strtol here, since
  * it does obey locale.
  */
-static int64_t
+static __LA_INT64_T
 mtree_atol8(char **p)
 {
-	int64_t	l, limit, last_digit_limit;
+	__LA_INT64_T	l, limit, last_digit_limit;
 	int digit, base;
 
 	base = 8;
@@ -1143,10 +1143,10 @@
  * locale settings; you cannot simply substitute strtol here, since
  * it does obey locale.
  */
-static int64_t
+static __LA_INT64_T
 mtree_atol10(char **p)
 {
-	int64_t l, limit, last_digit_limit;
+	__LA_INT64_T l, limit, last_digit_limit;
 	int base, digit, sign;
 
 	base = 10;
@@ -1177,10 +1177,10 @@
  * locale settings; you cannot simply substitute strtol here, since
  * it does obey locale.
  */
-static int64_t
+static __LA_INT64_T
 mtree_atol16(char **p)
 {
-	int64_t l, limit, last_digit_limit;
+	__LA_INT64_T l, limit, last_digit_limit;
 	int base, digit, sign;
 
 	base = 16;
@@ -1220,7 +1220,7 @@
 	return (sign < 0) ? -l : l;
 }
 
-static int64_t
+static __LA_INT64_T
 mtree_atol(char **p)
 {
 	if (**p != '0')
@@ -1237,12 +1237,12 @@
  * or negative on error.  'start' argument is updated to
  * point to first character of line.
  */
-static ssize_t
-readline(struct archive_read *a, struct mtree *mtree, char **start, ssize_t limit)
+static __LA_SSIZE_T
+readline(struct archive_read *a, struct mtree *mtree, char **start, __LA_SSIZE_T limit)
 {
-	ssize_t bytes_read;
-	ssize_t total_size = 0;
-	ssize_t find_off = 0;
+	__LA_SSIZE_T bytes_read;
+	__LA_SSIZE_T total_size = 0;
+	__LA_SSIZE_T find_off = 0;
 	const void *t;
 	const char *s;
 	void *p;
Index: libarchive/archive_read_support_compression_program.c
===================================================================
--- libarchive/archive_read_support_compression_program.c	(revision 2914)
+++ libarchive/archive_read_support_compression_program.c	(working copy)
@@ -130,7 +130,7 @@
 	size_t		 out_buf_len;
 };
 
-static ssize_t	program_filter_read(struct archive_read_filter *,
+static __LA_SSIZE_T	program_filter_read(struct archive_read_filter *,
 		    const void **);
 static int	program_filter_close(struct archive_read_filter *);
 
@@ -287,11 +287,11 @@
 /*
  * Use select() to decide whether the child is ready for read or write.
  */
-static ssize_t
+static __LA_SSIZE_T
 child_read(struct archive_read_filter *self, char *buf, size_t buf_len)
 {
 	struct program_filter *state = self->data;
-	ssize_t ret, requested, avail;
+	__LA_SSIZE_T ret, requested, avail;
 	const char *p;
 
 	requested = buf_len > SSIZE_MAX ? SSIZE_MAX : buf_len;
@@ -410,11 +410,11 @@
 	return (__archive_read_program(self, bidder_state->cmd));
 }
 
-static ssize_t
+static __LA_SSIZE_T
 program_filter_read(struct archive_read_filter *self, const void **buff)
 {
 	struct program_filter *state;
-	ssize_t bytes;
+	__LA_SSIZE_T bytes;
 	size_t total;
 	char *p;
 
Index: libarchive/archive_private.h
===================================================================
--- libarchive/archive_private.h	(revision 2914)
+++ libarchive/archive_private.h	(working copy)
@@ -61,20 +61,20 @@
 	int	(*archive_write_header)(struct archive *,
 	    struct archive_entry *);
 	int	(*archive_write_finish_entry)(struct archive *);
-	ssize_t	(*archive_write_data)(struct archive *,
+	__LA_SSIZE_T	(*archive_write_data)(struct archive *,
 	    const void *, size_t);
-	ssize_t	(*archive_write_data_block)(struct archive *,
-	    const void *, size_t, int64_t);
+	__LA_SSIZE_T	(*archive_write_data_block)(struct archive *,
+	    const void *, size_t, __LA_INT64_T);
 
 	int	(*archive_read_next_header)(struct archive *,
 	    struct archive_entry **);
 	int	(*archive_read_next_header2)(struct archive *,
 	    struct archive_entry *);
 	int	(*archive_read_data_block)(struct archive *,
-	    const void **, size_t *, int64_t *);
+	    const void **, size_t *, __LA_INT64_T *);
 
 	int	(*archive_filter_count)(struct archive *);
-	int64_t (*archive_filter_bytes)(struct archive *, int);
+	__LA_INT64_T (*archive_filter_bytes)(struct archive *, int);
 	int	(*archive_filter_code)(struct archive *, int);
 	const char * (*archive_filter_name)(struct archive *, int);
 };
Index: libarchive/archive_write_open_fd.c
===================================================================
--- libarchive/archive_write_open_fd.c	(revision 2914)
+++ libarchive/archive_write_open_fd.c	(working copy)
@@ -56,7 +56,7 @@
 
 static int	file_close(struct archive *, void *);
 static int	file_open(struct archive *, void *);
-static ssize_t	file_write(struct archive *, void *, const void *buff, size_t);
+static __LA_SSIZE_T	file_write(struct archive *, void *, const void *buff, size_t);
 
 int
 archive_write_open_fd(struct archive *a, int fd)
@@ -114,11 +114,11 @@
 	return (ARCHIVE_OK);
 }
 
-static ssize_t
+static __LA_SSIZE_T
 file_write(struct archive *a, void *client_data, const void *buff, size_t length)
 {
 	struct write_fd_data	*mine;
-	ssize_t	bytesWritten;
+	__LA_SSIZE_T	bytesWritten;
 
 	mine = (struct write_fd_data *)client_data;
 	for (;;) {
Index: libarchive/archive_read_support_format_cab.c
===================================================================
--- libarchive/archive_read_support_format_cab.c	(revision 2914)
+++ libarchive/archive_read_support_format_cab.c	(working copy)
@@ -72,7 +72,7 @@
 	int     		 copy_len;
 	/* Translation reversal for x86 proccessor CALL byte sequence(E8).
 	 * This is used for LZX only. */
-	uint32_t		 translation_size;
+	__LA_UINT32_T		 translation_size;
 	char			 translation;
 	char			 block_type;
 #define VERBATIM_BLOCK		1
@@ -81,7 +81,7 @@
 	size_t			 block_size;
 	size_t			 block_bytes_avail;
 	/* Repeated offset. */
-	uint32_t		 r0, r1, r2;
+	__LA_UINT32_T		 r0, r1, r2;
 	unsigned char		 rbytes[4];
 	int			 rbytes_avail;
 	int			 length_header;
@@ -96,7 +96,7 @@
 	 * Bit stream reader.
 	 */
 	struct {
-#define CACHE_TYPE		uint64_t
+#define CACHE_TYPE		__LA_UINT64_T
 #define CACHE_BITS		(8 * sizeof(CACHE_TYPE))
 	 	/* Cache buffer. */
 		CACHE_TYPE	 cache_buffer;
@@ -121,7 +121,7 @@
 		 */
 		int		 max_bits;
 		int		 tbl_bits;
-		uint16_t	*tbl;
+		__LA_UINT16_T	*tbl;
 	}			 at, lt, mt, pt;
 
 	int			 loop;
@@ -136,11 +136,11 @@
 
 struct lzx_stream {
 	const unsigned char	*next_in;
-	int64_t			 avail_in;
-	int64_t			 total_in;
+	__LA_INT64_T			 avail_in;
+	__LA_INT64_T			 total_in;
 	unsigned char		*next_out;
-	int64_t			 avail_out;
-	int64_t			 total_out;
+	__LA_INT64_T			 avail_out;
+	__LA_INT64_T			 total_out;
 	struct lzx_dec		*ds;
 };
 
@@ -189,35 +189,35 @@
 
 struct cfdata {
 	/* Sum value of this CFDATA. */
-	uint32_t		 sum;
-	uint16_t		 compressed_size;
-	uint16_t		 compressed_bytes_remaining;
-	uint16_t		 uncompressed_size;
-	uint16_t		 uncompressed_bytes_remaining;
+	__LA_UINT32_T		 sum;
+	__LA_UINT16_T		 compressed_size;
+	__LA_UINT16_T		 compressed_bytes_remaining;
+	__LA_UINT16_T		 uncompressed_size;
+	__LA_UINT16_T		 uncompressed_bytes_remaining;
 	/* To know how many bytes we have decompressed. */
-	uint16_t		 uncompressed_avail;
+	__LA_UINT16_T		 uncompressed_avail;
 	/* Offset from the beginning of compressed data of this CFDATA */
-	uint16_t		 read_offset;
-	int64_t			 unconsumed;
+	__LA_UINT16_T		 read_offset;
+	__LA_INT64_T			 unconsumed;
 	/* To keep memory image of this CFDATA to compute the sum. */
 	size_t			 memimage_size;
 	unsigned char		*memimage;
 	/* Result of calculation of sum. */
-	uint32_t		 sum_calculated;
+	__LA_UINT32_T		 sum_calculated;
 	unsigned char		 sum_extra[4];
 	int			 sum_extra_avail;
 	const void		*sum_ptr;
 };
 
 struct cffolder {
-	uint32_t		 cfdata_offset_in_cab;
-	uint16_t		 cfdata_count;
-	uint16_t		 comptype;
+	__LA_UINT32_T		 cfdata_offset_in_cab;
+	__LA_UINT16_T		 cfdata_count;
+	__LA_UINT16_T		 comptype;
 #define COMPTYPE_NONE		0x0000
 #define COMPTYPE_MSZIP		0x0001
 #define COMPTYPE_QUANTUM	0x0002
 #define COMPTYPE_LZX		0x0003
-	uint16_t		 compdata;
+	__LA_UINT16_T		 compdata;
 	const char		*compname;
 	/* At the time reading CFDATA */
 	struct cfdata		 cfdata;
@@ -227,10 +227,10 @@
 };
 
 struct cffile {
-	uint32_t		 uncompressed_size;
-	uint32_t		 offset;
+	__LA_UINT32_T		 uncompressed_size;
+	__LA_UINT32_T		 offset;
 	time_t			 mtime;
-	uint16_t	 	 folder;
+	__LA_UINT16_T	 	 folder;
 #define iFoldCONTINUED_FROM_PREV	0xFFFD
 #define iFoldCONTINUED_TO_NEXT		0xFFFE
 #define iFoldCONTINUED_PREV_AND_NEXT	0xFFFF
@@ -242,16 +242,16 @@
 
 struct cfheader {
 	/* Total bytes of all file size in a Cabinet. */
-	uint32_t		 total_bytes;
-	uint32_t		 files_offset;
-	uint16_t		 folder_count;
-	uint16_t		 file_count;
-	uint16_t		 flags;
+	__LA_UINT32_T		 total_bytes;
+	__LA_UINT32_T		 files_offset;
+	__LA_UINT16_T		 folder_count;
+	__LA_UINT16_T		 file_count;
+	__LA_UINT16_T		 flags;
 #define PREV_CABINET	0x0001
 #define NEXT_CABINET	0x0002
 #define RESERVE_PRESENT	0x0004
-	uint16_t		 setid;
-	uint16_t		 cabinet;
+	__LA_UINT16_T		 setid;
+	__LA_UINT16_T		 cabinet;
 	/* Version number. */
 	unsigned char		 major;
 	unsigned char		 minor;
@@ -266,17 +266,17 @@
 
 struct cab {
 	/* entry_bytes_remaining is the number of bytes we expect.	    */
-	int64_t			 entry_offset;
-	int64_t			 entry_bytes_remaining;
-	int64_t			 entry_unconsumed;
-	int64_t			 entry_compressed_bytes_read;
-	int64_t			 entry_uncompressed_bytes_read;
+	__LA_INT64_T			 entry_offset;
+	__LA_INT64_T			 entry_bytes_remaining;
+	__LA_INT64_T			 entry_unconsumed;
+	__LA_INT64_T			 entry_compressed_bytes_read;
+	__LA_INT64_T			 entry_uncompressed_bytes_read;
 	struct cffolder		*entry_cffolder;
 	struct cffile		*entry_cffile;
 	struct cfdata		*entry_cfdata;
 
 	/* Offset from beginning of a cabinet file. */
-	int64_t			 cab_offset;
+	__LA_INT64_T			 cab_offset;
 	struct cfheader		 cfheader;
 	struct archive_wstring	 ws;
 	struct archive_string	 mbs;
@@ -303,31 +303,31 @@
 static int	archive_read_format_cab_read_header(struct archive_read *,
 		    struct archive_entry *);
 static int	archive_read_format_cab_read_data(struct archive_read *,
-		    const void **, size_t *, int64_t *);
+		    const void **, size_t *, __LA_INT64_T *);
 static int	archive_read_format_cab_read_data_skip(struct archive_read *);
 static int	archive_read_format_cab_cleanup(struct archive_read *);
 
 static int	cab_skip_sfx(struct archive_read *);
 static time_t	cab_dos_time(const unsigned char *);
 static int	cab_read_data(struct archive_read *, const void **,
-		    size_t *, int64_t *);
+		    size_t *, __LA_INT64_T *);
 static int	cab_read_header(struct archive_read *);
-static uint32_t cab_checksum_cfdata_4(const void *, size_t bytes, uint32_t);
-static uint32_t cab_checksum_cfdata(const void *, size_t bytes, uint32_t);
+static __LA_UINT32_T cab_checksum_cfdata_4(const void *, size_t bytes, __LA_UINT32_T);
+static __LA_UINT32_T cab_checksum_cfdata(const void *, size_t bytes, __LA_UINT32_T);
 static void	cab_checksum_update(struct archive_read *, size_t);
 static int	cab_checksum_finish(struct archive_read *);
 static int	cab_next_cfdata(struct archive_read *);
-static const void *cab_read_ahead_cfdata(struct archive_read *, ssize_t *);
-static const void *cab_read_ahead_cfdata_none(struct archive_read *, ssize_t *);
+static const void *cab_read_ahead_cfdata(struct archive_read *, __LA_SSIZE_T *);
+static const void *cab_read_ahead_cfdata_none(struct archive_read *, __LA_SSIZE_T *);
 static const void *cab_read_ahead_cfdata_deflate(struct archive_read *,
-		    ssize_t *);
+		    __LA_SSIZE_T *);
 static const void *cab_read_ahead_cfdata_lzx(struct archive_read *,
-		    ssize_t *);
-static int64_t	cab_consume_cfdata(struct archive_read *, int64_t);
-static int64_t	cab_minimum_consume_cfdata(struct archive_read *, int64_t);
+		    __LA_SSIZE_T *);
+static __LA_INT64_T	cab_consume_cfdata(struct archive_read *, __LA_INT64_T);
+static __LA_INT64_T	cab_minimum_consume_cfdata(struct archive_read *, __LA_INT64_T);
 static int	lzx_decode_init(struct lzx_stream *, int);
 static void	lzx_decode_free(struct lzx_stream *);
-static void	lzx_translation(struct lzx_stream *, void *, size_t, uint32_t);
+static void	lzx_translation(struct lzx_stream *, void *, size_t, __LA_UINT32_T);
 static void	lzx_cleanup_bitstream(struct lzx_stream *);
 static int	lzx_decode(struct lzx_stream *, int);
 static int	lzx_read_pre_tree(struct lzx_stream *);
@@ -404,7 +404,7 @@
 {
 	const void *h;
 	const char *p;
-	ssize_t bytes_avail, offset, window;
+	__LA_SSIZE_T bytes_avail, offset, window;
 
 	if ((p = __archive_read_ahead(a, 4, NULL)) == NULL)
 		return (-1);
@@ -449,7 +449,7 @@
 	const void *h;
 	const char *p, *q;
 	size_t skip;
-	ssize_t bytes, window;
+	__LA_SSIZE_T bytes, window;
 
 	window = 4096;
 	for (;;) {
@@ -510,7 +510,7 @@
 
 /* Read bytes as much as remaining. */
 static const void *
-cab_read_ahead_remaining(struct archive_read *a, size_t min, ssize_t *avail)
+cab_read_ahead_remaining(struct archive_read *a, size_t min, __LA_SSIZE_T *avail)
 {
 	const void *p;
 
@@ -569,10 +569,10 @@
 	struct cab *cab;
 	struct cfheader *hd;
 	size_t bytes, used;
-	int64_t skip;
+	__LA_INT64_T skip;
 	int err, i, len;
 	int cur_folder, prev_folder;
-	uint32_t offset32;
+	__LA_UINT32_T offset32;
 	
 	a->archive.archive_format = ARCHIVE_FORMAT_CAB;
 	if (a->archive.archive_format_name == NULL)
@@ -619,7 +619,7 @@
 	hd->cabinet = archive_le16dec(p + CFHEADER_iCabinet);
 	used = CFHEADER_iCabinet + 2;
 	if (hd->flags & RESERVE_PRESENT) {
-		uint16_t cfheader;
+		__LA_UINT16_T cfheader;
 		cfheader = archive_le16dec(p + CFHEADER_cbCFHeader);
 		if (cfheader > 60000U)
 			goto invalid;
@@ -715,7 +715,7 @@
 	 * Read CFFILE.
 	 */
 	/* Seek read pointer to the offset of CFFILE if needed. */
-	skip = (int64_t)hd->files_offset - cab->cab_offset;
+	skip = (__LA_INT64_T)hd->files_offset - cab->cab_offset;
 	if (skip <  0) {
 		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
 		    "Invalid offset of CFFILE %jd < %jd",
@@ -735,7 +735,7 @@
 	prev_folder = -1;
 	for (i = 0; i < hd->file_count; i++) {
 		struct cffile *file = &(hd->file_array[i]);
-		ssize_t avail;
+		__LA_SSIZE_T avail;
 
 		if ((p = __archive_read_ahead(a, 16, NULL)) == NULL)
 			return (truncated_error(a));
@@ -764,7 +764,7 @@
 		 */
 		if (file->uncompressed_size > 0x7FFF8000)
 			goto invalid;/* Too large */
-		if ((int64_t)file->offset + (int64_t)file->uncompressed_size
+		if ((__LA_INT64_T)file->offset + (__LA_INT64_T)file->uncompressed_size
 		    > ARCHIVE_LITERAL_LL(0x7FFF8000))
 			goto invalid;/* Too large */
 		switch (file->folder) {
@@ -911,7 +911,7 @@
 
 static int
 archive_read_format_cab_read_data(struct archive_read *a,
-    const void **buff, size_t *size, int64_t *offset)
+    const void **buff, size_t *size, __LA_INT64_T *offset)
 {
 	struct cab *cab = (struct cab *)(a->format->data);
 	int r;
@@ -950,12 +950,12 @@
 	return (cab_read_data(a, buff, size, offset));
 }
 
-static uint32_t
-cab_checksum_cfdata_4(const void *p, size_t bytes, uint32_t seed)
+static __LA_UINT32_T
+cab_checksum_cfdata_4(const void *p, size_t bytes, __LA_UINT32_T seed)
 {
 	const unsigned char *b;
 	int u32num;
-	uint32_t sum;
+	__LA_UINT32_T sum;
 
 	u32num = bytes / 4;
 	sum = seed;
@@ -967,12 +967,12 @@
 	return (sum);
 }
 
-static uint32_t
-cab_checksum_cfdata(const void *p, size_t bytes, uint32_t seed)
+static __LA_UINT32_T
+cab_checksum_cfdata(const void *p, size_t bytes, __LA_UINT32_T seed)
 {
 	const unsigned char *b;
-	uint32_t sum;
-	uint32_t t;
+	__LA_UINT32_T sum;
+	__LA_UINT32_T t;
 
 	sum = cab_checksum_cfdata_4(p, bytes, seed);
 	b = p;
@@ -980,10 +980,10 @@
 	t = 0;
 	switch (bytes & 3) {
 	case 3:
-		t |= ((uint32_t)(*b++)) << 16;
+		t |= ((__LA_UINT32_T)(*b++)) << 16;
 		/* FALL THROUGH */
 	case 2:
-		t |= ((uint32_t)(*b++)) << 8;
+		t |= ((__LA_UINT32_T)(*b++)) << 8;
 		/* FALL THROUGH */
 	case 1:
 		t |= *b;
@@ -1087,7 +1087,7 @@
 		return (ARCHIVE_OK);
 
 	if (cfdata == NULL) {
-		int64_t skip;
+		__LA_INT64_T skip;
 
 		cab->entry_cffolder->cfdata_index = 0;
 
@@ -1225,7 +1225,7 @@
  * Read ahead CFDATA.
  */
 static const void *
-cab_read_ahead_cfdata(struct archive_read *a, ssize_t *avail)
+cab_read_ahead_cfdata(struct archive_read *a, __LA_SSIZE_T *avail)
 {
 	struct cab *cab = (struct cab *)(a->format->data);
 	int err;
@@ -1256,12 +1256,12 @@
  * Read ahead CFDATA as uncompressed data.
  */
 static const void *
-cab_read_ahead_cfdata_none(struct archive_read *a, ssize_t *avail)
+cab_read_ahead_cfdata_none(struct archive_read *a, __LA_SSIZE_T *avail)
 {
 	struct cab *cab = (struct cab *)(a->format->data);
 	struct cfdata *cfdata;
 	const void *d;
-	int64_t skipped_bytes;
+	__LA_INT64_T skipped_bytes;
 
 	cfdata = cab->entry_cfdata;
 
@@ -1309,13 +1309,13 @@
  */
 #ifdef HAVE_ZLIB_H
 static const void *
-cab_read_ahead_cfdata_deflate(struct archive_read *a, ssize_t *avail)
+cab_read_ahead_cfdata_deflate(struct archive_read *a, __LA_SSIZE_T *avail)
 {
 	struct cab *cab = (struct cab *)(a->format->data);
 	struct cfdata *cfdata;
 	const void *d;
 	int r, mszip;
-	uint16_t uavail;
+	__LA_UINT16_T uavail;
 	char eod = 0;
 
 	cfdata = cab->entry_cfdata;
@@ -1373,7 +1373,7 @@
 	 * We always uncompress all data in current CFDATA.
 	 */
 	while (!eod && cab->stream.total_out < cfdata->uncompressed_size) {
-		ssize_t bytes_avail;
+		__LA_SSIZE_T bytes_avail;
 
 		cab->stream.next_out =
 		    cab->uncompressed_buffer + cab->stream.total_out;
@@ -1464,7 +1464,7 @@
 	 * CFDATA.
 	 */
 	if (cfdata->compressed_bytes_remaining > 0) {
-		ssize_t bytes_avail;
+		__LA_SSIZE_T bytes_avail;
 
 		d = __archive_read_ahead(a, cfdata->compressed_bytes_remaining,
 		    &bytes_avail);
@@ -1526,7 +1526,7 @@
 #else /* HAVE_ZLIB_H */
 
 static const void *
-cab_read_ahead_cfdata_deflate(struct archive_read *a, ssize_t *avail)
+cab_read_ahead_cfdata_deflate(struct archive_read *a, __LA_SSIZE_T *avail)
 {
 	*avail = ARCHIVE_FATAL;
 	archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
@@ -1537,13 +1537,13 @@
 #endif /* HAVE_ZLIB_H */
 
 static const void *
-cab_read_ahead_cfdata_lzx(struct archive_read *a, ssize_t *avail)
+cab_read_ahead_cfdata_lzx(struct archive_read *a, __LA_SSIZE_T *avail)
 {
 	struct cab *cab = (struct cab *)(a->format->data);
 	struct cfdata *cfdata;
 	const void *d;
 	int r;
-	uint16_t uavail;
+	__LA_UINT16_T uavail;
 
 	cfdata = cab->entry_cfdata;
 	/* If the buffer hasn't been allocated, allocate it now. */
@@ -1583,7 +1583,7 @@
 	lzx_cleanup_bitstream(&cab->xstrm);
 	cab->xstrm.total_out = uavail;
 	while (cab->xstrm.total_out < cfdata->uncompressed_size) {
-		ssize_t bytes_avail;
+		__LA_SSIZE_T bytes_avail;
 
 		cab->xstrm.next_out =
 		    cab->uncompressed_buffer + cab->xstrm.total_out;
@@ -1629,7 +1629,7 @@
 	 * Make sure a read pointer advances to next CFDATA.
 	 */
 	if (cfdata->compressed_bytes_remaining > 0) {
-		ssize_t bytes_avail;
+		__LA_SSIZE_T bytes_avail;
 
 		d = __archive_read_ahead(a, cfdata->compressed_bytes_remaining,
 		    &bytes_avail);
@@ -1668,12 +1668,12 @@
  * iFoldCONTINUED_FROM_PREV, we won't decompress because a CFDATA for
  * the CFFILE is remaining bytes of previous Multivolume CAB file.
  */
-static int64_t
-cab_consume_cfdata(struct archive_read *a, int64_t consumed_bytes)
+static __LA_INT64_T
+cab_consume_cfdata(struct archive_read *a, __LA_INT64_T consumed_bytes)
 {
 	struct cab *cab = (struct cab *)(a->format->data);
 	struct cfdata *cfdata;
-	int64_t cbytes, rbytes;
+	__LA_INT64_T cbytes, rbytes;
 	int err;
 
 	rbytes = cab_minimum_consume_cfdata(a, consumed_bytes);
@@ -1682,7 +1682,7 @@
 
 	cfdata = cab->entry_cfdata;
 	while (rbytes > 0) {
-		ssize_t avail;
+		__LA_SSIZE_T avail;
 
 		if (cfdata->compressed_size == 0) {
 			archive_set_error(&a->archive,
@@ -1764,12 +1764,12 @@
  * Consume CFDATA as much as we have already gotten and
  * compute the sum of CFDATA.
  */
-static int64_t
-cab_minimum_consume_cfdata(struct archive_read *a, int64_t consumed_bytes)
+static __LA_INT64_T
+cab_minimum_consume_cfdata(struct archive_read *a, __LA_INT64_T consumed_bytes)
 {
 	struct cab *cab = (struct cab *)(a->format->data);
 	struct cfdata *cfdata;
-	int64_t cbytes, rbytes;
+	__LA_INT64_T cbytes, rbytes;
 	int err;
 
 	cfdata = cab->entry_cfdata;
@@ -1822,10 +1822,10 @@
  */
 static int
 cab_read_data(struct archive_read *a, const void **buff,
-    size_t *size, int64_t *offset)
+    size_t *size, __LA_INT64_T *offset)
 {
 	struct cab *cab = (struct cab *)(a->format->data);
-	ssize_t bytes_avail;
+	__LA_SSIZE_T bytes_avail;
 
 	if (cab->entry_bytes_remaining == 0) {
 		*buff = NULL;
@@ -1866,7 +1866,7 @@
 archive_read_format_cab_read_data_skip(struct archive_read *a)
 {
 	struct cab *cab;
-	int64_t bytes_skipped;
+	__LA_INT64_T bytes_skipped;
 	int r;
 
 	cab = (struct cab *)(a->format->data);
@@ -2076,7 +2076,7 @@
  * E8 Call Translation reversal.
  */
 static void
-lzx_translation(struct lzx_stream *strm, void *p, size_t size, uint32_t offset)
+lzx_translation(struct lzx_stream *strm, void *p, size_t size, __LA_UINT32_T offset)
 {
 	struct lzx_dec *ds = strm->ds;
 	unsigned char *b, *end;
@@ -2096,7 +2096,7 @@
 				displacement = value - cp;
 			else
 				displacement = value + ds->translation_size;
-			archive_le32enc(&b[1], (uint32_t)displacement);
+			archive_le32enc(&b[1], (__LA_UINT32_T)displacement);
 		}
 		b += 5;
 	}
@@ -2109,10 +2109,10 @@
 #define lzx_br_has(strm, n)	((strm)->ds->br.cache_avail >= n)
 /* Get compressed data by bit. */
 #define lzx_br_bits(strm, n)				\
-	(((uint16_t)((strm)->ds->br.cache_buffer >>	\
+	(((__LA_UINT16_T)((strm)->ds->br.cache_buffer >>	\
 		((strm)->ds->br.cache_avail - (n)))) & cache_masks[n])
 #define lzx_br_bits_forced(strm, n)			\
-	(((uint16_t)((strm)->ds->br.cache_buffer <<	\
+	(((__LA_UINT16_T)((strm)->ds->br.cache_buffer <<	\
 		((n) - (strm)->ds->br.cache_avail))) & cache_masks[n])
 /* Read ahead to make sure the cache buffer has enough compressed data we
  * will use.
@@ -2132,7 +2132,7 @@
 #define lzx_br_consume_unalined_bits(strm)	\
 	((strm)->ds->br.cache_avail &= ~0x0f)
 
-static uint16_t cache_masks[] = {
+static __LA_UINT16_T cache_masks[] = {
 	0x0000, 0x0001, 0x0003, 0x0007,
 	0x000F, 0x001F, 0x003F, 0x007F,
 	0x00FF, 0x01FF, 0x03FF, 0x07FF,
@@ -2156,7 +2156,7 @@
 	if (ds->br.have_odd && n >= 16 && strm->avail_in > 0) {
 		ds->br.cache_buffer =
 		   (ds->br.cache_buffer << 16) |
-		   ((uint16_t)(*strm->next_in)) << 8 |
+		   ((__LA_UINT16_T)(*strm->next_in)) << 8 |
 		    ds->br.odd;
 		strm->next_in++;
 		strm->avail_in--;
@@ -2182,20 +2182,20 @@
 			switch (words = (n >> 4)) {
 			case 4:
 				ds->br.cache_buffer =
-				    (((uint64_t)archive_le16dec(
+				    (((__LA_UINT64_T)archive_le16dec(
 					strm->next_in)) << 48) |
-				    (((uint64_t)archive_le16dec(
+				    (((__LA_UINT64_T)archive_le16dec(
 					strm->next_in+2)) << 32) |
-				    (((uint32_t)archive_le16dec(
+				    (((__LA_UINT32_T)archive_le16dec(
 					strm->next_in+4)) << 16) |
 				    archive_le16dec(strm->next_in+6);
 				break;
 			case 3:
 				ds->br.cache_buffer =
 		 		   (ds->br.cache_buffer << 48) |
-				    (((uint64_t)archive_le16dec(
+				    (((__LA_UINT64_T)archive_le16dec(
 					strm->next_in)) << 32) |
-				    (((uint32_t)archive_le16dec(
+				    (((__LA_UINT32_T)archive_le16dec(
 					strm->next_in+2)) << 16) |
 				    archive_le16dec(strm->next_in+4);
 				break;
@@ -2352,7 +2352,7 @@
 		case ST_RD_R1:
 		case ST_RD_R2:
 			do {
-				uint16_t u16;
+				__LA_UINT16_T u16;
 				/* Drain bits in the cache buffer of
 				 * bit-stream. */
 				if (lzx_br_has(strm, 32)) {
@@ -2952,7 +2952,7 @@
 	 * Make the table.
 	 */
 	for (i = 0; i < hf->len_size; i++) {
-		uint16_t *p;
+		__LA_UINT16_T *p;
 		int len, cnt;
 
 		if ((len = hf->bitlen[i]) == 0)
@@ -2966,7 +2966,7 @@
 		/* Update the table */
 		p = &(hf->tbl[ptn]);
 		while (--cnt >= 0)
-			*p++ = (uint16_t)i;
+			*p++ = (__LA_UINT16_T)i;
 	}
 	return (1);
 }
Index: libarchive/archive_read_open_memory.c
===================================================================
--- libarchive/archive_read_open_memory.c	(revision 2914)
+++ libarchive/archive_read_open_memory.c	(working copy)
@@ -43,7 +43,7 @@
 struct read_memory_data {
 	unsigned char	*buffer;
 	unsigned char	*end;
-	ssize_t	 read_size;
+	__LA_SSIZE_T	 read_size;
 };
 
 static int	memory_read_close(struct archive *, void *);
@@ -51,9 +51,9 @@
 #if ARCHIVE_VERSION_NUMBER < 3000000
 static off_t	memory_read_skip(struct archive *, void *, off_t request);
 #else
-static int64_t	memory_read_skip(struct archive *, void *, int64_t request);
+static __LA_INT64_T	memory_read_skip(struct archive *, void *, __LA_INT64_T request);
 #endif
-static ssize_t	memory_read(struct archive *, void *, const void **buff);
+static __LA_SSIZE_T	memory_read(struct archive *, void *, const void **buff);
 
 int
 archive_read_open_memory(struct archive *a, void *buff, size_t size)
@@ -103,11 +103,11 @@
  * in a test harness.  Production use should not specify a block
  * size; then this is much faster.
  */
-static ssize_t
+static __LA_SSIZE_T
 memory_read(struct archive *a, void *client_data, const void **buff)
 {
 	struct read_memory_data *mine = (struct read_memory_data *)client_data;
-	ssize_t size;
+	__LA_SSIZE_T size;
 
 	(void)a; /* UNUSED */
 	*buff = mine->buffer;
@@ -127,14 +127,14 @@
 static off_t
 memory_read_skip(struct archive *a, void *client_data, off_t skip)
 #else
-static int64_t
-memory_read_skip(struct archive *a, void *client_data, int64_t skip)
+static __LA_INT64_T
+memory_read_skip(struct archive *a, void *client_data, __LA_INT64_T skip)
 #endif
 {
 	struct read_memory_data *mine = (struct read_memory_data *)client_data;
 
 	(void)a; /* UNUSED */
-	if ((int64_t)skip > (int64_t)(mine->end - mine->buffer))
+	if ((__LA_INT64_T)skip > (__LA_INT64_T)(mine->end - mine->buffer))
 		skip = mine->end - mine->buffer;
 	/* Round down to block size. */
 	skip /= mine->read_size;
Index: libarchive/archive_write_add_filter_xz.c
===================================================================
--- libarchive/archive_write_add_filter_xz.c	(revision 2914)
+++ libarchive/archive_write_add_filter_xz.c	(working copy)
@@ -103,12 +103,12 @@
 	lzma_stream	 stream;
 	lzma_filter	 lzmafilters[2];
 	lzma_options_lzma lzma_opt;
-	int64_t		 total_in;
+	__LA_INT64_T		 total_in;
 	unsigned char	*compressed;
 	size_t		 compressed_buffer_size;
-	int64_t		 total_out;
+	__LA_INT64_T		 total_out;
 	/* the CRC32 value of uncompressed data for lzip */
-	uint32_t	 crc32;
+	__LA_UINT32_T	 crc32;
 };
 
 static int	archive_compressor_xz_options(struct archive_write_filter *,
@@ -122,8 +122,8 @@
 		    struct private_data *, int finishing);
 
 struct option_value {
-	uint32_t dict_size;
-	uint32_t nice_len;
+	__LA_UINT32_T dict_size;
+	__LA_UINT32_T nice_len;
 	lzma_match_finder mf;
 };
 static const struct option_value option_values[] = {
Index: libarchive/archive_read_open_file.c
===================================================================
--- libarchive/archive_read_open_file.c	(revision 2914)
+++ libarchive/archive_read_open_file.c	(working copy)
@@ -58,11 +58,11 @@
 };
 
 static int	file_close(struct archive *, void *);
-static ssize_t	file_read(struct archive *, void *, const void **buff);
+static __LA_SSIZE_T	file_read(struct archive *, void *, const void **buff);
 #if ARCHIVE_VERSION_NUMBER < 3000000
 static off_t	file_skip(struct archive *, void *, off_t request);
 #else
-static int64_t	file_skip(struct archive *, void *, int64_t request);
+static __LA_INT64_T	file_skip(struct archive *, void *, __LA_INT64_T request);
 #endif
 
 int
@@ -105,11 +105,11 @@
 		    file_skip, file_close));
 }
 
-static ssize_t
+static __LA_SSIZE_T
 file_read(struct archive *a, void *client_data, const void **buff)
 {
 	struct read_FILE_data *mine = (struct read_FILE_data *)client_data;
-	ssize_t bytes_read;
+	__LA_SSIZE_T bytes_read;
 
 	*buff = mine->buffer;
 	bytes_read = fread(mine->buffer, 1, mine->block_size, mine->f);
@@ -123,8 +123,8 @@
 static off_t
 file_skip(struct archive *a, void *client_data, off_t request)
 #else
-static int64_t
-file_skip(struct archive *a, void *client_data, int64_t request)
+static __LA_INT64_T
+file_skip(struct archive *a, void *client_data, __LA_INT64_T request)
 #endif
 {
 	struct read_FILE_data *mine = (struct read_FILE_data *)client_data;
Index: libarchive/archive_read_open_filename.c
===================================================================
--- libarchive/archive_read_open_filename.c	(revision 2914)
+++ libarchive/archive_read_open_filename.c	(working copy)
@@ -69,17 +69,17 @@
 	int	 fd;
 	size_t	 block_size;
 	void	*buffer;
-	mode_t	 st_mode;  /* Mode bits for opened file. */
+	__LA_MODE_T	 st_mode;  /* Mode bits for opened file. */
 	char	 use_lseek;
 	char	 filename[1]; /* Must be last! */
 };
 
 static int	file_close(struct archive *, void *);
-static ssize_t	file_read(struct archive *, void *, const void **buff);
+static __LA_SSIZE_T	file_read(struct archive *, void *, const void **buff);
 #if ARCHIVE_VERSION_NUMBER < 3000000
 static off_t	file_skip(struct archive *, void *, off_t request);
 #else
-static int64_t	file_skip(struct archive *, void *, int64_t request);
+static __LA_INT64_T	file_skip(struct archive *, void *, __LA_INT64_T request);
 #endif
 static off_t	file_skip_lseek(struct archive *, void *, off_t request);
 
@@ -225,11 +225,11 @@
 		NULL, file_read, file_skip, file_close));
 }
 
-static ssize_t
+static __LA_SSIZE_T
 file_read(struct archive *a, void *client_data, const void **buff)
 {
 	struct read_file_data *mine = (struct read_file_data *)client_data;
-	ssize_t bytes_read;
+	__LA_SSIZE_T bytes_read;
 
 	/* TODO: If a recent lseek() operation has left us
 	 * mis-aligned, read and return a short block to try to get
@@ -317,8 +317,8 @@
 static off_t
 file_skip(struct archive *a, void *client_data, off_t request)
 #else
-static int64_t
-file_skip(struct archive *a, void *client_data, int64_t request)
+static __LA_INT64_T
+file_skip(struct archive *a, void *client_data, __LA_INT64_T request)
 #endif
 {
 	struct read_file_data *mine = (struct read_file_data *)client_data;
@@ -354,7 +354,7 @@
 		if (!S_ISREG(mine->st_mode)
 		    && !S_ISCHR(mine->st_mode)
 		    && !S_ISBLK(mine->st_mode)) {
-			ssize_t bytesRead;
+			__LA_SSIZE_T bytesRead;
 			do {
 				bytesRead = read(mine->fd, mine->buffer,
 				    mine->block_size);
